##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    15/Mar/2023  22:35:34 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \string_util.c                                       #
#    Command line    =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \string_util.c -D NEWSGOLD -D DEBUG -lCN             #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\ -la D:\Users\alfinant\Documents\Si #
#                       emens\Dev\IAR\VK.ELF_C\Releas_NSG\List\ -o           #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\ -s9 --cpu_mode arm --endian little  #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork         #
#                       --diag_suppress Pe301 -e --fpu None --dlib_config    #
#                       D:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I D:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\string_util.lst                     #
#    Object file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\string_util.r79                      #
#                                                                            #
#                                                                            #
##############################################################################

D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C\string_util.c
      1          #include <siemens\swilib.h>
      2          #include "string_util.h"
      3          
      4          /////////////////////////////////////////// Разный стафф для замены спецсимволов
      5          
      6          // Структура, описывающая, что на что менять
      7          typedef struct
      8          {
      9            char mask[7];
     10            char replace;
     11          }REPL_ARRAY;
     12          
     13          // Сами замены и их количество

   \                                 In segment DATA_C, align 4, align-sorted
     14          const int Repl_chars_count = 6;
   \                     Repl_chars_count:
   \   00000000   06000000           DC32 6

   \                                 In segment DATA_I, align 4, align-sorted
     15          REPL_ARRAY Repl_chars[] = {"&apos;\0",0x27,
   \                     Repl_chars:
   \   00000000                      DS8 48
   \   00000030                      REQUIRE `?<Initializer for Repl_chars>`
     16                                     "&#39;\0\0",0x27,//added 25.09.2017 by alfinant
     17                                     "&quot;\0",'"',
     18                                     "&lt;\0\0\0", '<',
     19                                     "&gt;\0\0\0", '>',
     20                                     "&amp;\0\0", '&',
     21          };
     22          
     23          /*
     24           * UTF8 -> UTF16
     25           */

   \                                 In segment CODE, align 4, keep-with-next
     26          int utf8_2unicode(const char **res, const char *str)
     27          {
   \                     utf8_2unicode:
   \   00000000   10002DE9           PUSH     {R4}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
     28            int zz=0;
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   00308DE5           STR      R3,[SP, #+0]
     29            int c=*str++;
   \   00000010   ........           LDRB     R2,[R1], #+1
     30            char *s=(char *)&zz;
     31            *res=NULL;
   \   00000014   003080E5           STR      R3,[R0, #+0]
     32            if ((c >> 7) == 0x0)
   \   00000018   C233B0E1           ASRS     R3,R2,#+7
     33            {
     34              zz=c;
   \   0000001C   00208D05           STREQ    R2,[SP, #+0]
   \   00000020   1E00000A           BEQ      ??utf8_2unicode_0
     35            }
     36            else if ((c >> 5) == 0x6)
   \   00000024   C232A0E1           ASR      R3,R2,#+5
   \   00000028   060053E3           CMP      R3,#+6
   \   0000002C   0900001A           BNE      ??utf8_2unicode_1
     37            {
     38              s[1] = ((c & 0x1f) >> 2);
   \   00000030   1FC002E2           AND      R12,R2,#0x1F
   \   00000034   4CC1A0E1           ASR      R12,R12,#+2
   \   00000038   01C0CDE5           STRB     R12,[SP, #+1]
     39              s[0] = c << 6;
   \   0000003C   0223A0E1           LSL      R2,R2,#+6
   \   00000040   0020CDE5           STRB     R2,[SP, #+0]
     40              c = *str++;
   \   00000044   ........           LDRB     R2,[R1], #+1
     41              s[0] |= (c & 0x3f);
   \   00000048   00C0DDE5           LDRB     R12,[SP, #+0]
   \   0000004C   3F2002E2           AND      R2,R2,#0x3F
   \   00000050   0C2082E1           ORR      R2,R2,R12
   \   00000054   100000EA           B        ??utf8_2unicode_2
     42            }
     43            else if ((c >> 4) == 0xe)
   \                     ??utf8_2unicode_1:
   \   00000058   4232A0E1           ASR      R3,R2,#+4
   \   0000005C   0E0053E3           CMP      R3,#+14
   \   00000060   0E00001A           BNE      ??utf8_2unicode_0
     44            {
     45              s[1] = c << 4;
   \   00000064   0222A0E1           LSL      R2,R2,#+4
   \   00000068   0120CDE5           STRB     R2,[SP, #+1]
     46              c = *str++;
   \   0000006C   ........           LDRB     R2,[R1], #+1
     47              s[1] |= ((c >> 2) & 0xf);
   \   00000070   01C0DDE5           LDRB     R12,[SP, #+1]
   \   00000074   4241A0E1           ASR      R4,R2,#+2
   \   00000078   0F4004E2           AND      R4,R4,#0xF
   \   0000007C   0C4084E1           ORR      R4,R4,R12
   \   00000080   0140CDE5           STRB     R4,[SP, #+1]
     48              s[0] = c << 6;
   \   00000084   0223A0E1           LSL      R2,R2,#+6
   \   00000088   0020CDE5           STRB     R2,[SP, #+0]
     49              c = *str++;
   \   0000008C   ........           LDRB     R2,[R1], #+1
     50              s[0] |= (c & 0x3f);
   \   00000090   0040DDE5           LDRB     R4,[SP, #+0]
   \   00000094   3F2002E2           AND      R2,R2,#0x3F
   \   00000098   042082E1           ORR      R2,R2,R4
   \                     ??utf8_2unicode_2:
   \   0000009C   0020CDE5           STRB     R2,[SP, #+0]
     51            }
     52            *res=str;
   \                     ??utf8_2unicode_0:
   \   000000A0   001080E5           STR      R1,[R0, #+0]
     53            return zz;
   \   000000A4   00009DE5           LDR      R0,[SP, #+0]
   \   000000A8   1200BDE8           POP      {R1,R4}
   \   000000AC   1EFF2FE1           BX       LR               ;; return
     54          }
     55          
     56          /*
     57              Получить спецсимвол по его маске
     58          IN: mask_begin - строка символов
     59              out_ofs - число, к которому прибавится длина обработанной последовательности
     60          OUT: out_ofs - смещение в строке, откуда начинаются необработанные данные
     61              <return> - спецсимвол
     62          */

   \                                 In segment CODE, align 4, keep-with-next
     63          char GetSpecialSym(char *mask_begin, int *out_ofs)
     64          {
   \                     GetSpecialSym:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0050A0E1           MOV      R5,R0
     65            int i=0;
     66            int replen;
     67            char rep_ex[10];
     68            if(*mask_begin!='&')return *(mask_begin);
   \   0000000C   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000010   0140A0E1           MOV      R4,R1
   \   00000014   260050E3           CMP      R0,#+38
   \   00000018   0100000A           BEQ      ??GetSpecialSym_0
   \                     ??GetSpecialSym_1:
   \   0000001C   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000020   FE81BDE8           POP      {R1-R8,PC}
     69            for(i=0;i<Repl_chars_count;i++)
   \                     ??GetSpecialSym_0:
   \   00000024   0060A0E3           MOV      R6,#+0
   \   00000028   020000EA           B        ??GetSpecialSym_2
   \                     ??GetSpecialSym_3:
   \   0000002C   016086E2           ADD      R6,R6,#+1
   \   00000030   060056E3           CMP      R6,#+6
   \   00000034   F8FFFFAA           BGE      ??GetSpecialSym_1
     70            {
     71              replen = strlen(Repl_chars[i].mask);  // Определяем длину очередной маски
   \                     ??GetSpecialSym_2:
   \   00000038   ........           LDR      R0,??DataTable2  ;; Repl_chars
   \   0000003C   867180E0           ADD      R7,R0,R6, LSL #+3
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   1B0000EF           SWI      +27
   \   00000048   0080A0E1           MOV      R8,R0
     72              zeromem(rep_ex,10);
   \   0000004C   0A10A0E3           MOV      R1,#+10
   \   00000050   0D00A0E1           MOV      R0,SP
   \   00000054   1D0100EF           SWI      +285
     73              strncpy(rep_ex,mask_begin,replen);    // Копируем строку такой длины с текущей позиции
   \   00000058   0820A0E1           MOV      R2,R8
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   160100EF           SWI      +278
     74              if(!strcmp(rep_ex,Repl_chars[i].mask))// Если совпало с очередной маской
   \   00000068   0710A0E1           MOV      R1,R7
   \   0000006C   0D00A0E1           MOV      R0,SP
   \   00000070   190000EF           SWI      +25
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   EBFFFF1A           BNE      ??GetSpecialSym_3
     75              {
     76                *out_ofs+=replen-1;                   // Увеличиваем обработанную длину на длину маски
   \   0000007C   000094E5           LDR      R0,[R4, #+0]
   \   00000080   011048E2           SUB      R1,R8,#+1
   \   00000084   000081E0           ADD      R0,R1,R0
   \   00000088   000084E5           STR      R0,[R4, #+0]
     77                return Repl_chars[i].replace;       // Возвращаем символ для замены
   \   0000008C   0700D7E5           LDRB     R0,[R7, #+7]
   \   00000090   FE81BDE8           POP      {R1-R8,PC}       ;; return
     78              }
     79            }
     80            return *(mask_begin);       //  Масок не нашлось, возвращаем как есть
     81          }
     82          

   \                                 In segment CODE, align 4, keep-with-next
     83          int GetSpecialSymMaskN(char sym)
     84          {
     85            for(int i=0; i<Repl_chars_count; i++)
   \                     GetSpecialSymMaskN:
   \   00000000   0010A0E3           MOV      R1,#+0
     86              if(Repl_chars[i].replace==sym)
   \                     ??GetSpecialSymMaskN_0:
   \   00000004   ........           LDR      R2,??DataTable2  ;; Repl_chars
   \   00000008   812182E0           ADD      R2,R2,R1, LSL #+3
   \   0000000C   0720D2E5           LDRB     R2,[R2, #+7]
   \   00000010   000052E1           CMP      R2,R0
     87                return i;
   \   00000014   0100A001           MOVEQ    R0,R1
   \   00000018   1EFF2F01           BXEQ     LR
   \   0000001C   011081E2           ADD      R1,R1,#+1
   \   00000020   060051E3           CMP      R1,#+6
   \   00000024   F6FFFFBA           BLT      ??GetSpecialSymMaskN_0
     88            return -1;
   \   00000028   0000E0E3           MVN      R0,#+0
   \   0000002C   1EFF2FE1           BX       LR               ;; return
     89          }
     90          

   \                                 In segment CODE, align 4, keep-with-next
     91          char * Replace_Special_Syms(char * unrep_str)
     92          {
   \                     Replace_Special_Syms:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0050A0E1           MOV      R5,R0
     93            unsigned int unrep_len=strlen(unrep_str);
   \   0000000C   1B0000EF           SWI      +27
   \   00000010   0060A0E1           MOV      R6,R0
     94            char *rep_buffer = malloc(unrep_len+1);
   \   00000014   017086E2           ADD      R7,R6,#+1
   \   00000018   0700A0E1           MOV      R0,R7
   \   0000001C   140000EF           SWI      +20
   \   00000020   0040A0E1           MOV      R4,R0
     95            zeromem(rep_buffer, unrep_len+1);
   \   00000024   0710A0E1           MOV      R1,R7
   \   00000028   1D0100EF           SWI      +285
     96            char tmp=0;
     97            unsigned int rpl_c=0;
   \   0000002C   0070A0E3           MOV      R7,#+0
     98            for(int j=0;j<unrep_len;j++)
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   00108DE5           STR      R1,[SP, #+0]
   \   00000038   000056E3           CMP      R6,#+0
   \   0000003C   0800001A           BNE      ??Replace_Special_Syms_0
   \   00000040   0A0000EA           B        ??Replace_Special_Syms_1
     99            {
    100              tmp = *(unrep_str+j);
    101              tmp = GetSpecialSym(unrep_str+j,&j);
    102              //ShowMSG(1,(int)"fnd");
    103              rep_buffer[rpl_c++]=tmp;
   \                     ??Replace_Special_Syms_2:
   \   00000044   0D10A0E1           MOV      R1,SP
   \   00000048   050080E0           ADD      R0,R0,R5
   \   0000004C   ........           BL       GetSpecialSym
   \   00000050   0400C7E7           STRB     R0,[R7, +R4]
    104            }
   \   00000054   00109DE5           LDR      R1,[SP, #+0]
   \   00000058   017087E2           ADD      R7,R7,#+1
   \   0000005C   011081E2           ADD      R1,R1,#+1
   \   00000060   00108DE5           STR      R1,[SP, #+0]
   \                     ??Replace_Special_Syms_0:
   \   00000064   00009DE5           LDR      R0,[SP, #+0]
   \   00000068   060050E1           CMP      R0,R6
   \   0000006C   F4FFFF3A           BCC      ??Replace_Special_Syms_2
    105            rep_buffer = realloc(rep_buffer,rpl_c+1);
   \                     ??Replace_Special_Syms_1:
   \   00000070   011087E2           ADD      R1,R7,#+1
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   BA0000EF           SWI      +186
    106            return rep_buffer;
   \   0000007C   F280BDE8           POP      {R1,R4-R7,PC}    ;; return
    107          }
    108          

   \                                 In segment CODE, align 4, keep-with-next
    109          char * Mask_Special_Syms(const char * unrep_str)
    110          {
   \                     Mask_Special_Syms:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    111            unsigned int unrep_len = strlen(unrep_str);
    112            unsigned int rep_buffer_size = unrep_len*2+16;
    113            char *rep_buffer = malloc(rep_buffer_size);
    114            unsigned int c_pos = 0;
   \   00000008   0060A0E3           MOV      R6,#+0
   \   0000000C   0070A0E3           MOV      R7,#+0
   \   00000010   1B0000EF           SWI      +27
   \   00000014   0050A0E1           MOV      R5,R0
   \   00000018   1000A0E3           MOV      R0,#+16
   \   0000001C   858080E0           ADD      R8,R0,R5, LSL #+1
   \   00000020   0800A0E1           MOV      R0,R8
   \   00000024   140000EF           SWI      +20
   \   00000028   0090A0E1           MOV      R9,R0
    115            for(int i=0; i<unrep_len; i++)
   \   0000002C   06A0A0E1           MOV      R10,R6
   \   00000030   000055E3           CMP      R5,#+0
   \   00000034   1000001A           BNE      ??Mask_Special_Syms_0
    116            {
    117              int n=GetSpecialSymMaskN(unrep_str[i]);
    118              if(n!=-1)
    119              {
    120                strcpy(rep_buffer+c_pos, Repl_chars[n].mask);
    121                c_pos += strlen(Repl_chars[n].mask);
    122              }
    123              else
    124              {
    125                rep_buffer[c_pos++] = unrep_str[i];
    126              }
    127              if (c_pos+10>rep_buffer_size)
    128              {
    129                rep_buffer_size *= 2;
    130                rep_buffer = realloc(rep_buffer, rep_buffer_size);
    131              }
    132            }
    133            rep_buffer[c_pos] = '\0';
   \                     ??Mask_Special_Syms_1:
   \   00000038   0960C7E7           STRB     R6,[R7, +R9]
    134            rep_buffer = realloc(rep_buffer, c_pos+1);
   \   0000003C   011087E2           ADD      R1,R7,#+1
   \   00000040   0900A0E1           MOV      R0,R9
   \   00000044   BA0000EF           SWI      +186
    135            return rep_buffer;
   \   00000048   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??Mask_Special_Syms_2:
   \   0000004C   0410DAE7           LDRB     R1,[R10, +R4]
   \   00000050   017087E2           ADD      R7,R7,#+1
   \   00000054   0010C0E5           STRB     R1,[R0, #+0]
   \                     ??Mask_Special_Syms_3:
   \   00000058   0A0087E2           ADD      R0,R7,#+10
   \   0000005C   000058E1           CMP      R8,R0
   \   00000060   0400002A           BCS      ??Mask_Special_Syms_4
   \   00000064   8880A0E1           LSL      R8,R8,#+1
   \   00000068   0810A0E1           MOV      R1,R8
   \   0000006C   0900A0E1           MOV      R0,R9
   \   00000070   BA0000EF           SWI      +186
   \   00000074   0090A0E1           MOV      R9,R0
   \                     ??Mask_Special_Syms_4:
   \   00000078   01A08AE2           ADD      R10,R10,#+1
   \                     ??Mask_Special_Syms_0:
   \   0000007C   05005AE1           CMP      R10,R5
   \   00000080   ECFFFF2A           BCS      ??Mask_Special_Syms_1
   \   00000084   0400DAE7           LDRB     R0,[R10, +R4]
   \   00000088   ........           BL       GetSpecialSymMaskN
   \   0000008C   0010A0E1           MOV      R1,R0
   \   00000090   090087E0           ADD      R0,R7,R9
   \   00000094   010071E3           CMN      R1,#+1
   \   00000098   EBFFFF0A           BEQ      ??Mask_Special_Syms_2
   \   0000009C   ........           LDR      R2,??DataTable2  ;; Repl_chars
   \   000000A0   81B182E0           ADD      R11,R2,R1, LSL #+3
   \   000000A4   0B10A0E1           MOV      R1,R11
   \   000000A8   1A0000EF           SWI      +26
   \   000000AC   0B00A0E1           MOV      R0,R11
   \   000000B0   1B0000EF           SWI      +27
   \   000000B4   077080E0           ADD      R7,R0,R7
   \   000000B8   E6FFFFEA           B        ??Mask_Special_Syms_3
    136          }
    137          
    138          /* Вернуть значение параметра по имени параметра из строки вида:
    139           nonce="2444323444",qop="auth",charset=utf-8,algorithm=md5-sess
    140          
    141          IN: ch - строка
    142              req - имя требуемого параметра
    143              cut_quotes - обрезать ли кавычки, если параметр в кавычках
    144          OUT: Искомое значение; нужно освободить память!
    145          */

   \                                 In segment CODE, align 4, keep-with-next
    146          char *Get_Param_Value(char *ch, char *req, char cut_quotes)
    147          {
   \                     Get_Param_Value:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    148          //  char ch[]="nonce=\"2444323444\",qop=\"auth\",charset=utf-8,algorithm=md5-sess";
    149          //  char req[]="qop";
    150            char *n_displace = strstr(ch, req);     // начало строки с именем параметра
   \   00000010   180100EF           SWI      +280
   \   00000014   0070A0E1           MOV      R7,R0
    151            char *eq=n_displace + strlen(req);
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   1B0000EF           SWI      +27
   \   00000020   074080E0           ADD      R4,R0,R7
    152            if(!(eq[0]=='='))return NULL;
   \   00000024   ........           LDRB     R0,[R4], #+1
   \   00000028   3D0050E3           CMP      R0,#+61
   \   0000002C   0000A013           MOVNE    R0,#+0
   \   00000030   F080BD18           POPNE    {R4-R7,PC}
    153            eq+=1;
    154            char *zpt= strchr(n_displace,',');
   \   00000034   2C10A0E3           MOV      R1,#+44
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   180000EF           SWI      +24
    155            if(!zpt)zpt=ch+strlen(ch);
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0200001A           BNE      ??Get_Param_Value_0
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   1B0000EF           SWI      +27
   \   00000050   050080E0           ADD      R0,R0,R5
    156            int len;
    157            char *val;
    158            if(cut_quotes)
   \                     ??Get_Param_Value_0:
   \   00000054   045040E0           SUB      R5,R0,R4
   \   00000058   000056E3           CMP      R6,#+0
   \   0000005C   0C00000A           BEQ      ??Get_Param_Value_1
    159            {
    160              len=zpt-eq-2;
   \   00000060   025045E2           SUB      R5,R5,#+2
    161              val=malloc(len+1);
   \   00000064   010085E2           ADD      R0,R5,#+1
   \   00000068   140000EF           SWI      +20
    162              for(int i=0;i<len;i++) val[i]=*(eq+i+1);
   \   0000006C   0010A0E3           MOV      R1,#+0
   \   00000070   010055E3           CMP      R5,#+1
   \   00000074   130000BA           BLT      ??Get_Param_Value_2
   \                     ??Get_Param_Value_3:
   \   00000078   050051E1           CMP      R1,R5
   \   0000007C   110000AA           BGE      ??Get_Param_Value_2
   \   00000080   042081E0           ADD      R2,R1,R4
   \   00000084   0120D2E5           LDRB     R2,[R2, #+1]
   \   00000088   0020C1E7           STRB     R2,[R1, +R0]
   \   0000008C   011081E2           ADD      R1,R1,#+1
   \   00000090   F8FFFFEA           B        ??Get_Param_Value_3
    163            }
    164            else
    165            {
    166              len=zpt-eq;
    167              val=malloc(len+1);
   \                     ??Get_Param_Value_1:
   \   00000094   010085E2           ADD      R0,R5,#+1
   \   00000098   140000EF           SWI      +20
    168              for(int i=0;i<len;i++) val[i]=*(eq+i);
   \   0000009C   0010A0E3           MOV      R1,#+0
   \   000000A0   010055E3           CMP      R5,#+1
   \   000000A4   050000AA           BGE      ??Get_Param_Value_4
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0010C5E7           STRB     R1,[R5, +R0]
   \   000000B0   F080BDE8           POP      {R4-R7,PC}
   \                     ??Get_Param_Value_5:
   \   000000B4   0420D1E7           LDRB     R2,[R1, +R4]
   \   000000B8   0020C1E7           STRB     R2,[R1, +R0]
   \   000000BC   011081E2           ADD      R1,R1,#+1
   \                     ??Get_Param_Value_4:
   \   000000C0   050051E1           CMP      R1,R5
   \   000000C4   FAFFFFBA           BLT      ??Get_Param_Value_5
    169            }
    170            val[len]=0x0;
   \                     ??Get_Param_Value_2:
   \   000000C8   0010A0E3           MOV      R1,#+0
   \   000000CC   0010C5E7           STRB     R1,[R5, +R0]
    171            return val;
   \   000000D0   F080BDE8           POP      {R4-R7,PC}       ;; return
    172          }
    173          
    174          
    175          /*
    176            Преобразование буфера данных из кодировки UTF-8 в ANSI
    177          IN:
    178            - tmp_out: куда положить результат. Буфер уже должен существовать
    179                       и в нем должно быть достаточно места
    180            - UTF8_str: откуда брать данные для преобразования
    181            - size: сколько длина буфера для преобразования (UTF8_str)
    182            - fact - куда положить итоговый размер данных в буфере
    183          
    184          OUT:  результирующий буфер.
    185          */

   \                                 In segment CODE, align 4, keep-with-next
    186          void* convUTF8_to_ANSI(char* tmp_out, char *UTF8_str, unsigned int size, int* fact)
    187          {
   \                     convUTF8_to_ANSI:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0350A0E1           MOV      R5,R3
    188            // Рассматривая строку UTF8 как обычную, определяем её длину
    189            if(!UTF8_str)return NULL;
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   1C00000A           BEQ      ??convUTF8_to_ANSI_0
    190            int st_len = size;
    191          
    192            // Выделяем память - на всякий случай столько же. Это предельный случай,
    193            // когда весь поступивший буфер - на русском языке. Реально будет, скорее всего,
    194            // занято меньше, посему в конце сделаем realloc
    195            int lastchar = 0;
   \   00000014   0060A0E3           MOV      R6,#+0
    196            int dummy;
    197            char chr, chr2, chr3;
    198            for(int i=0;i<st_len;i++)
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   040000EA           B        ??convUTF8_to_ANSI_1
    199            {
    200            chr = (*(UTF8_str+i));
    201          
    202          	if (chr<0x80)
    203                  {
    204                    *(tmp_out+lastchar)=chr;
    205                    lastchar++;
    206                    goto L_END_CYCLE;
    207                  }
    208          	if (chr<0xc0)
    209                  {
    210                    ShowMSG(1,(int)"Bad UTF-8 Encoding encountered (chr<0xC0)");
    211                    mfree(tmp_out);
    212                    return NULL;
    213                  }
    214          	
    215                  chr2 = *(UTF8_str+i+1);
    216          
    217                  if (chr2<0x80)
    218                  {
    219                    ShowMSG(1,(int)"Bad UTF-8 Encoding encountered (chr2<0x80)");
    220                    mfree(tmp_out);
    221                    return NULL;
    222                  }
    223          	
    224          	if (chr<0xe0) {
    225          	    // cx, dx
    226          	    char test1 = (chr & 0x1f)<<6;
    227                      char test2 = chr2 & 0x3f;
    228                      *(tmp_out+lastchar)= test1 | test2 + 127 + 0x31;
    229                      i++;
    230                      lastchar++;
    231                      goto L_END_CYCLE;
    232          	}
    233          	if (chr<0xf0) {
    234          	    // cx, dx
    235          	    chr3= *(UTF8_str+i+2);
    236          
    237          	    if (chr3<0x80)
    238                      {
    239                        ShowMSG(1,(int)"Bad UTF-8 Encoding encountered");
    240                        mfree(tmp_out);
    241                        return NULL;
    242                      }
    243          	    else
    244                      {
    245                        *(tmp_out+lastchar) =  ((chr & 0x0f)<<12) | ((chr2 &0x3f) <<6) | (chr3 &0x3f);
   \                     ??convUTF8_to_ANSI_2:
   \   00000020   3F3003E2           AND      R3,R3,#0x3F
   \   00000024   0E3383E1           ORR      R3,R3,LR, LSL #+6
   \   00000028   0430C6E7           STRB     R3,[R6, +R4]
    246                        i=i+2;
   \   0000002C   020080E2           ADD      R0,R0,#+2
    247                      }
    248          	}
    249          
    250            L_END_CYCLE:
    251              dummy++;
   \                     ??convUTF8_to_ANSI_3:
   \   00000030   010080E2           ADD      R0,R0,#+1
   \                     ??convUTF8_to_ANSI_1:
   \   00000034   020050E1           CMP      R0,R2
   \   00000038   240000AA           BGE      ??convUTF8_to_ANSI_4
   \   0000003C   01C0D0E7           LDRB     R12,[R0, +R1]
   \   00000040   013086E2           ADD      R3,R6,#+1
   \   00000044   80005CE3           CMP      R12,#+128
   \   00000048   0200002A           BCS      ??convUTF8_to_ANSI_5
   \   0000004C   04C0C6E7           STRB     R12,[R6, +R4]
   \                     ??convUTF8_to_ANSI_6:
   \   00000050   0360A0E1           MOV      R6,R3
   \   00000054   F5FFFFEA           B        ??convUTF8_to_ANSI_3
   \                     ??convUTF8_to_ANSI_5:
   \   00000058   C0005CE3           CMP      R12,#+192
   \   0000005C   ........           LDRCC    R1,??DataTable6  ;; `?<Constant "Bad UTF-8 Encoding en...">`
   \   00000060   0400003A           BCC      ??convUTF8_to_ANSI_7
   \   00000064   01E080E0           ADD      LR,R0,R1
   \   00000068   01E0DEE5           LDRB     LR,[LR, #+1]
   \   0000006C   80005EE3           CMP      LR,#+128
   \   00000070   0600002A           BCS      ??convUTF8_to_ANSI_8
   \   00000074   ........           LDR      R1,??DataTable7  ;; `?<Constant "Bad UTF-8 Encoding en...">` + 44
   \                     ??convUTF8_to_ANSI_7:
   \   00000078   0100A0E3           MOV      R0,#+1
   \   0000007C   480100EF           SWI      +328
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   150000EF           SWI      +21
   \                     ??convUTF8_to_ANSI_0:
   \   00000088   0000A0E3           MOV      R0,#+0
   \   0000008C   F080BDE8           POP      {R4-R7,PC}
   \                     ??convUTF8_to_ANSI_8:
   \   00000090   E0005CE3           CMP      R12,#+224
   \   00000094   0500002A           BCS      ??convUTF8_to_ANSI_9
   \   00000098   3F700EE2           AND      R7,LR,#0x3F
   \   0000009C   B07087E2           ADD      R7,R7,#+176
   \   000000A0   0C7387E1           ORR      R7,R7,R12, LSL #+6
   \   000000A4   0470C6E7           STRB     R7,[R6, +R4]
   \   000000A8   010080E2           ADD      R0,R0,#+1
   \   000000AC   E7FFFFEA           B        ??convUTF8_to_ANSI_6
   \                     ??convUTF8_to_ANSI_9:
   \   000000B0   F0005CE3           CMP      R12,#+240
   \   000000B4   DDFFFF2A           BCS      ??convUTF8_to_ANSI_3
   \   000000B8   013080E0           ADD      R3,R0,R1
   \   000000BC   0230D3E5           LDRB     R3,[R3, #+2]
   \   000000C0   800053E3           CMP      R3,#+128
   \   000000C4   D5FFFF2A           BCS      ??convUTF8_to_ANSI_2
   \   000000C8   ........           LDR      R1,??DataTable8  ;; `?<Constant "Bad UTF-8 Encoding en...">` + 88
   \   000000CC   E9FFFFEA           B        ??convUTF8_to_ANSI_7
    252            }
    253            tmp_out = realloc(tmp_out,lastchar);
   \                     ??convUTF8_to_ANSI_4:
   \   000000D0   0610A0E1           MOV      R1,R6
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   BA0000EF           SWI      +186
    254            *fact = lastchar;
   \   000000DC   006085E5           STR      R6,[R5, #+0]
    255            return tmp_out;
   \   000000E0   F080BDE8           POP      {R4-R7,PC}       ;; return
    256          }
    257          
    258          // Преобразование в нижний регистр

   \                                 In segment CODE, align 4, keep-with-next
    259          char* str2lower(char *st)
    260          {
   \                     str2lower:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    261            unsigned int len = strlen(st);
   \   00000008   1B0000EF           SWI      +27
    262            for(int i=0;i<len;i++)
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0B00001A           BNE      ??str2lower_0
    263            {
    264              char sym = *(st+i);
    265              if(sym<0x80)
    266              {
    267                if(st[i]>='A' && st[i]<='Z') st[i] += ('a' - 'A');
    268                continue;
    269              }
    270              if(sym<0xe0)
    271              {
    272                i++;
    273                if(st[i] >= 0x90 && st[i]<=0xAF) st[i]+= (0xB0 - 0x90);
    274              }
    275            }
    276            return st;
   \                     ??str2lower_1:
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??str2lower_2:
   \   00000020   E00052E3           CMP      R2,#+224
   \   00000024   0600002A           BCS      ??str2lower_3
   \   00000028   011081E2           ADD      R1,R1,#+1
   \   0000002C   0420D1E7           LDRB     R2,[R1, +R4]
   \   00000030   900052E3           CMP      R2,#+144
   \   00000034   0200003A           BCC      ??str2lower_3
   \   00000038   B00052E3           CMP      R2,#+176
   \                     ??str2lower_4:
   \   0000003C   20208232           ADDCC    R2,R2,#+32
   \   00000040   0420C137           STRBCC   R2,[R1, +R4]
   \                     ??str2lower_3:
   \   00000044   011081E2           ADD      R1,R1,#+1
   \                     ??str2lower_0:
   \   00000048   000051E1           CMP      R1,R0
   \   0000004C   F1FFFF2A           BCS      ??str2lower_1
   \   00000050   0420D1E7           LDRB     R2,[R1, +R4]
   \   00000054   800052E3           CMP      R2,#+128
   \   00000058   F0FFFF2A           BCS      ??str2lower_2
   \   0000005C   410052E3           CMP      R2,#+65
   \   00000060   F7FFFF3A           BCC      ??str2lower_3
   \   00000064   5B0052E3           CMP      R2,#+91
   \   00000068   F3FFFFEA           B        ??str2lower_4
    277          }
    278          
    279          ////////////////////////////////////////////////////////////////////////////////
    280          #pragma inline

   \                                 In segment CODE, align 4, keep-with-next
    281          int tolower(int C)
    282          {
    283          //  if ((C>='A' && C<='Z')) C-='A'-'a';
    284              if(C<0x80)
   \                     tolower:
   \   00000000   201080E2           ADD      R1,R0,#+32
   \   00000004   800050E3           CMP      R0,#+128
   \   00000008   040000AA           BGE      ??tolower_0
    285              {
    286                if(C>='A' && C<='Z') C += ('a' - 'A');
   \   0000000C   410050E3           CMP      R0,#+65
   \   00000010   1EFF2FB1           BXLT     LR
   \   00000014   5B0050E3           CMP      R0,#+91
   \   00000018   0100A0B1           MOVLT    R0,R1
    287                return C;
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    288              }
    289                if(C >= 0x90 && C<=0xAF) C+= (0xB0 - 0x90);
   \                     ??tolower_0:
   \   00000020   900050E3           CMP      R0,#+144
   \   00000024   1EFF2FB1           BXLT     LR
   \   00000028   B00050E3           CMP      R0,#+176
   \   0000002C   1EFF2FA1           BXGE     LR
   \   00000030   0100A0E1           MOV      R0,R1
   \   00000034   1EFF2FE1           BX       LR
    290            return(C);
    291          }
    292          
    293          
    294          // Аналог strcmp, но без чувствительности к регистру

   \                                 In segment CODE, align 4, keep-with-next
    295          int stricmp(const char *s, const char *d)
    296          {
   \                     stricmp:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    297            int cs;
    298            int ds;
    299            do
    300            {
    301              cs=tolower(*s++);
   \                     ??stricmp_0:
   \   0000000C   ........           LDRB     R0,[R4], #+1
   \   00000010   ........           _BLF     tolower,??tolower??rA
   \   00000014   0060A0E1           MOV      R6,R0
    302              ds=tolower(*d++);
   \   00000018   ........           LDRB     R0,[R5], #+1
   \   0000001C   ........           _BLF     tolower,??tolower??rA
    303              cs-=ds;
   \   00000020   001056E0           SUBS     R1,R6,R0
    304              if (cs) break;
   \   00000024   0100001A           BNE      ??stricmp_1
    305            }
    306            while(ds);
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   F6FFFF1A           BNE      ??stricmp_0
    307            return(cs);
   \                     ??stricmp_1:
   \   00000030   0100A0E1           MOV      R0,R1
   \   00000034   7080BDE8           POP      {R4-R6,PC}       ;; return
    308          }
    309          

   \                                 In segment CODE, align 4, keep-with-next
    310          int strnicmp(const char *s1, const char *s2, size_t len)
    311          {
   \                     strnicmp:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
    312          	/* Yes, Virginia, it had better be unsigned */
    313          	unsigned int c1, c2;
    314          
    315          	c1 = 0;	c2 = 0;
   \   00000010   0070A0E3           MOV      R7,#+0
   \   00000014   0080A0E3           MOV      R8,#+0
    316          	if (len) {
   \   00000018   1000000A           BEQ      ??strnicmp_0
    317          		do {
    318          			c1 = *s1; c2 = *s2;
   \                     ??strnicmp_1:
   \   0000001C   ........           LDRB     R7,[R4], #+1
   \   00000020   ........           LDRB     R8,[R5], #+1
    319          			s1++; s2++;
    320          			if (!c1)
   \   00000024   000057E3           CMP      R7,#+0
    321          				break;
    322          			if (!c2)
   \   00000028   00005813           CMPNE    R8,#+0
   \   0000002C   0B00000A           BEQ      ??strnicmp_0
    323          				break;
    324          			if (c1 == c2)
   \   00000030   080057E1           CMP      R7,R8
   \   00000034   0700000A           BEQ      ??strnicmp_2
    325          				continue;
    326          			c1 = tolower(c1);
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   ........           _BLF     tolower,??tolower??rA
   \   00000040   0070A0E1           MOV      R7,R0
    327          			c2 = tolower(c2);
   \   00000044   0800A0E1           MOV      R0,R8
   \   00000048   ........           _BLF     tolower,??tolower??rA
   \   0000004C   0080A0E1           MOV      R8,R0
    328          			if (c1 != c2)
   \   00000050   080057E1           CMP      R7,R8
   \   00000054   0100001A           BNE      ??strnicmp_0
    329          				break;
    330          		} while (--len);
   \                     ??strnicmp_2:
   \   00000058   016056E2           SUBS     R6,R6,#+1
   \   0000005C   EEFFFF1A           BNE      ??strnicmp_1
    331          	}
    332          	return c1 - c2;
   \                     ??strnicmp_0:
   \   00000060   080047E0           SUB      R0,R7,R8
   \   00000064   F081BDE8           POP      {R4-R8,PC}       ;; return
    333          }
    334          
    335          // Аналог strstr, но без чувствительности к регистру
    336          /*
    337           * Find the first occurrence of find in s.
    338           */

   \                                 In segment CODE, align 4, keep-with-next
    339          char *stristr(const char *s, const char *find)
    340          {
   \                     stristr:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    341              char c, sc;
    342              size_t len;
    343          
    344              if ((c = tolower((unsigned char)(*find++))) != 0) {
   \   0000000C   ........           LDRB     R0,[R5], #+1
   \   00000010   ........           _BLF     tolower,??tolower??rA
   \   00000014   FF6010E2           ANDS     R6,R0,#0xFF
   \   00000018   1000000A           BEQ      ??stristr_0
    345                  len = strlen(find);
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   1B0000EF           SWI      +27
   \   00000024   0070A0E1           MOV      R7,R0
    346                  do {
    347                      do {
    348                          if ((sc = tolower((unsigned char)(*s++))) == 0)
   \                     ??stristr_1:
   \   00000028   ........           LDRB     R0,[R4], #+1
   \   0000002C   ........           _BLF     tolower,??tolower??rA
   \   00000030   000CB0E1           MOVS     R0,R0, LSL #+24
    349                              return (NULL);
   \   00000034   0000A003           MOVEQ    R0,#+0
   \   00000038   F080BD08           POPEQ    {R4-R7,PC}
    350                      } while (sc != c);
   \   0000003C   200C56E1           CMP      R6,R0, LSR #+24
   \   00000040   F8FFFF1A           BNE      ??stristr_1
    351                  } while (strnicmp(s, find, len) != 0);
   \   00000044   0720A0E1           MOV      R2,R7
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       strnicmp
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   F2FFFF1A           BNE      ??stristr_1
    352                  s--;
   \   0000005C   014044E2           SUB      R4,R4,#+1
    353              }
    354              return ((char *)s);
   \                     ??stristr_0:
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   F080BDE8           POP      {R4-R7,PC}       ;; return
    355          }
    356          ////////////////////////////////////////////////////////////////////////////////
    357          
    358          /*
    359          // Аналог strstr, но без чувствительности к регистру
    360          char *stristr(char *haystack, char *needle)
    361          {
    362            if(!haystack || !needle)return NULL;
    363            char *i_haystack = malloc(strlen(haystack)+1);
    364            char *i_needle = malloc(strlen(needle)+1);
    365            strcpy(i_haystack, haystack);
    366            strcpy(i_needle, needle);
    367            str2lower(i_haystack);
    368            str2lower(i_needle);
    369            // Сравниваем уже строки в нижнем регистре и считаем смещение
    370            char *q = strstr(i_haystack, i_needle);
    371            mfree(i_haystack);
    372            mfree(i_needle);
    373            if(!q)  // Значит, нет подстроки
    374            {
    375              return NULL;
    376            }
    377            int delta = q - i_haystack;
    378            return haystack + delta;  // Есть подстрока, очевидно, по тому же смещению
    379          }
    380          
    381          // Аналог strcmp, но без чувствительности к регистру
    382          int stricmp(char *str1, char *str2)
    383          {
    384            if(!str1 || !str2)return NULL;
    385            char *i_str1 = malloc(strlen(str1)+1);
    386            char *i_str2 = malloc(strlen(str2)+1);
    387            strcpy(i_str1, str1);
    388            strcpy(i_str2, str2);
    389            str2lower(i_str1);
    390            str2lower(i_str2);
    391            // Сравниваем уже строки в нижнем регистре
    392            int res= strcmp(i_str1, i_str2);
    393            mfree(i_str1);
    394            mfree(i_str2);
    395            return res;
    396          }
    397          */

   \                                 In segment CODE, align 4, keep-with-next
    398          char* str2lower_ANSI(char *st)
    399          {
   \                     str2lower_ANSI:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    400            unsigned int len = strlen(st);
   \   00000008   1B0000EF           SWI      +27
    401            for(int i=0;i<len;i++)
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0300001A           BNE      ??str2lower_ANSI_0
    402            {
    403              char sym = *(st+i);
    404              char *cc = st+i;
    405              *cc= sym>='A' && sym<='Z' ? sym + ('a' - 'A') : sym >= 'А' && sym <= 'Я'? sym + ('а' - 'А') : sym;
    406            }
    407            return st;
   \                     ??str2lower_ANSI_1:
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??str2lower_ANSI_2:
   \   00000020   0420C1E7           STRB     R2,[R1, +R4]
   \   00000024   011081E2           ADD      R1,R1,#+1
   \                     ??str2lower_ANSI_0:
   \   00000028   000051E1           CMP      R1,R0
   \   0000002C   F9FFFF2A           BCS      ??str2lower_ANSI_1
   \   00000030   0420D1E7           LDRB     R2,[R1, +R4]
   \   00000034   410052E3           CMP      R2,#+65
   \   00000038   0300003A           BCC      ??str2lower_ANSI_3
   \   0000003C   5B0052E3           CMP      R2,#+91
   \   00000040   0100002A           BCS      ??str2lower_ANSI_3
   \                     ??str2lower_ANSI_4:
   \   00000044   202082E2           ADD      R2,R2,#+32
   \   00000048   F4FFFFEA           B        ??str2lower_ANSI_2
   \                     ??str2lower_ANSI_3:
   \   0000004C   C00052E3           CMP      R2,#+192
   \   00000050   F2FFFF3A           BCC      ??str2lower_ANSI_2
   \   00000054   E00052E3           CMP      R2,#+224
   \   00000058   F0FFFF2A           BCS      ??str2lower_ANSI_2
   \   0000005C   F8FFFFEA           B        ??str2lower_ANSI_4
    408          }
    409          
    410          
    411          // Строковый вариант

   \                                 In segment CODE, align 4, keep-with-next
    412          char* convUTF8_to_ANSI_STR(char *UTF8_str)
    413          {
   \                     convUTF8_to_ANSI_STR:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    414            // Рассматривая строку UTF8 как обычную, определяем её длину
    415            if(!UTF8_str)return NULL;
   \   00000008   2400000A           BEQ      ??convUTF8_to_ANSI_STR_0
    416            int st_len = strlen(UTF8_str);
   \   0000000C   1B0000EF           SWI      +27
   \   00000010   0050A0E1           MOV      R5,R0
    417          
    418            // Выделяем память - на всякий случай дохера
    419            int lastchar = 0;
   \   00000014   0060A0E3           MOV      R6,#+0
    420            int dummy;
    421            char* tmp_out = malloc(st_len+1);
   \   00000018   018085E2           ADD      R8,R5,#+1
   \   0000001C   0800A0E1           MOV      R0,R8
   \   00000020   140000EF           SWI      +20
   \   00000024   0070A0E1           MOV      R7,R0
    422            zeromem(tmp_out,st_len+1);
   \   00000028   0810A0E1           MOV      R1,R8
   \   0000002C   1D0100EF           SWI      +285
    423            char chr, chr2, chr3;
    424            for(int i=0;i<st_len;i++)
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   040000EA           B        ??convUTF8_to_ANSI_STR_1
    425            {
    426            chr = (*(UTF8_str+i));
    427          
    428          	if (chr<0x80)
    429                  {
    430                    *(tmp_out+lastchar)=chr;
    431                    lastchar++;
    432                    goto L_END_CYCLE;
    433                  }
    434          	if (chr<0xc0)
    435                  {
    436                    ShowMSG(1,(int)"Bad UTF-8 Encoding encountered (chr<0xC0)");
    437                    mfree(tmp_out);
    438                    return NULL;
    439                  }
    440          	
    441                  chr2 = *(UTF8_str+i+1);
    442          
    443                  if (chr2<0x80)
    444                  {
    445                    ShowMSG(1,(int)"Bad UTF-8 Encoding encountered (chr2<0x80)");
    446                    mfree(tmp_out);
    447                    return NULL;
    448                  }
    449          	
    450          	if (chr<0xe0) {
    451          	    // cx, dx
    452                            if ((chr == 0xD0)&&(chr2 == 0x81)){*(tmp_out+lastchar) = 0xA8;}//Ё
    453                       else if ((chr == 0xD0)&&(chr2 == 0x86)){*(tmp_out+lastchar) = 0xB2;}//І
    454                       else if ((chr == 0xD0)&&(chr2 == 0x87)){*(tmp_out+lastchar) = 0xAF;}//Ї
    455                       else if ((chr == 0xD0)&&(chr2 == 0x84)){*(tmp_out+lastchar) = 0xAA;}//Є
    456                       else if ((chr == 0xD1)&&(chr2 == 0x91)){*(tmp_out+lastchar) = 0xB8;}//ё
    457                       else if ((chr == 0xD1)&&(chr2 == 0x96)){*(tmp_out+lastchar) = 0xB3;}//і
    458                       else if ((chr == 0xD1)&&(chr2 == 0x97)){*(tmp_out+lastchar) = 0xBF;}//ї
    459                       else if ((chr == 0xD1)&&(chr2 == 0x94)){*(tmp_out+lastchar) = 0xBA;}//є
    460                       else if ((chr == 0xD2)&&(chr2 == 0x91)){*(tmp_out+lastchar) = 0xE3;}//ґ->г
    461                       else if ((chr == 0xD2)&&(chr2 == 0x90)){*(tmp_out+lastchar) = 0xC3;}//Ґ->Г
    462                       else
    463                    {
    464          	    char test1 = (chr & 0x1f)<<6;
    465                      char test2 = chr2 & 0x3f;
    466                      *(tmp_out+lastchar)= test1 | test2 + 127 + 0x31;
    467                    }
    468                      i++;
    469                      lastchar++;
    470                      goto L_END_CYCLE;
    471          	}
    472          	if (chr<0xf0) {
    473          	    // cx, dx
    474          	    chr3= *(UTF8_str+i+2);
    475          
    476          	    if (chr3<0x80)
    477                      {
    478                        ShowMSG(1,(int)"Bad UTF-8 Encoding encountered");
    479                        mfree(tmp_out);
    480                        return NULL;
    481                      }
    482          	    else
    483                      {
    484                        *(tmp_out+lastchar) =  ((chr & 0x0f)<<12) | ((chr2 &0x3f) <<6) | (chr3 &0x3f);
   \                     ??convUTF8_to_ANSI_STR_2:
   \   00000038   3F1001E2           AND      R1,R1,#0x3F
   \   0000003C   031381E1           ORR      R1,R1,R3, LSL #+6
   \   00000040   0710C6E7           STRB     R1,[R6, +R7]
    485                        i=i+2;
   \   00000044   020080E2           ADD      R0,R0,#+2
    486                      }
    487          	}
    488          
    489            L_END_CYCLE:
    490              dummy++;
   \                     ??convUTF8_to_ANSI_STR_3:
   \   00000048   010080E2           ADD      R0,R0,#+1
   \                     ??convUTF8_to_ANSI_STR_1:
   \   0000004C   050050E1           CMP      R0,R5
   \   00000050   4C0000AA           BGE      ??convUTF8_to_ANSI_STR_4
   \   00000054   0410D0E7           LDRB     R1,[R0, +R4]
   \   00000058   012086E2           ADD      R2,R6,#+1
   \   0000005C   800051E3           CMP      R1,#+128
   \   00000060   0200002A           BCS      ??convUTF8_to_ANSI_STR_5
   \   00000064   0710C6E7           STRB     R1,[R6, +R7]
   \                     ??convUTF8_to_ANSI_STR_6:
   \   00000068   0260A0E1           MOV      R6,R2
   \   0000006C   F5FFFFEA           B        ??convUTF8_to_ANSI_STR_3
   \                     ??convUTF8_to_ANSI_STR_5:
   \   00000070   C00051E3           CMP      R1,#+192
   \   00000074   ........           LDRCC    R1,??DataTable6  ;; `?<Constant "Bad UTF-8 Encoding en...">`
   \   00000078   0400003A           BCC      ??convUTF8_to_ANSI_STR_7
   \   0000007C   043080E0           ADD      R3,R0,R4
   \   00000080   0130D3E5           LDRB     R3,[R3, #+1]
   \   00000084   800053E3           CMP      R3,#+128
   \   00000088   0600002A           BCS      ??convUTF8_to_ANSI_STR_8
   \   0000008C   ........           LDR      R1,??DataTable7  ;; `?<Constant "Bad UTF-8 Encoding en...">` + 44
   \                     ??convUTF8_to_ANSI_STR_7:
   \   00000090   0100A0E3           MOV      R0,#+1
   \   00000094   480100EF           SWI      +328
   \   00000098   0700A0E1           MOV      R0,R7
   \   0000009C   150000EF           SWI      +21
   \                     ??convUTF8_to_ANSI_STR_0:
   \   000000A0   0000A0E3           MOV      R0,#+0
   \   000000A4   F081BDE8           POP      {R4-R8,PC}
   \                     ??convUTF8_to_ANSI_STR_8:
   \   000000A8   E00051E3           CMP      R1,#+224
   \   000000AC   2D00002A           BCS      ??convUTF8_to_ANSI_STR_9
   \   000000B0   D00051E3           CMP      R1,#+208
   \   000000B4   0C00001A           BNE      ??convUTF8_to_ANSI_STR_10
   \   000000B8   810053E3           CMP      R3,#+129
   \   000000BC   A810A003           MOVEQ    R1,#+168
   \   000000C0   2500000A           BEQ      ??convUTF8_to_ANSI_STR_11
   \   000000C4   860053E3           CMP      R3,#+134
   \   000000C8   B210A003           MOVEQ    R1,#+178
   \   000000CC   2200000A           BEQ      ??convUTF8_to_ANSI_STR_11
   \   000000D0   870053E3           CMP      R3,#+135
   \   000000D4   AF10A003           MOVEQ    R1,#+175
   \   000000D8   1F00000A           BEQ      ??convUTF8_to_ANSI_STR_11
   \   000000DC   840053E3           CMP      R3,#+132
   \   000000E0   1A00001A           BNE      ??convUTF8_to_ANSI_STR_12
   \   000000E4   AA10A0E3           MOV      R1,#+170
   \   000000E8   1B0000EA           B        ??convUTF8_to_ANSI_STR_11
   \                     ??convUTF8_to_ANSI_STR_10:
   \   000000EC   D10051E3           CMP      R1,#+209
   \   000000F0   0300001A           BNE      ??convUTF8_to_ANSI_STR_13
   \   000000F4   910053E3           CMP      R3,#+145
   \   000000F8   0700001A           BNE      ??convUTF8_to_ANSI_STR_14
   \   000000FC   B810A0E3           MOV      R1,#+184
   \   00000100   150000EA           B        ??convUTF8_to_ANSI_STR_11
   \                     ??convUTF8_to_ANSI_STR_13:
   \   00000104   D20051E3           CMP      R1,#+210
   \   00000108   1000001A           BNE      ??convUTF8_to_ANSI_STR_12
   \   0000010C   910053E3           CMP      R3,#+145
   \   00000110   0B00001A           BNE      ??convUTF8_to_ANSI_STR_15
   \   00000114   E310A0E3           MOV      R1,#+227
   \   00000118   0F0000EA           B        ??convUTF8_to_ANSI_STR_11
   \                     ??convUTF8_to_ANSI_STR_14:
   \   0000011C   960053E3           CMP      R3,#+150
   \   00000120   B310A003           MOVEQ    R1,#+179
   \   00000124   0C00000A           BEQ      ??convUTF8_to_ANSI_STR_11
   \   00000128   970053E3           CMP      R3,#+151
   \   0000012C   BF10A003           MOVEQ    R1,#+191
   \   00000130   0900000A           BEQ      ??convUTF8_to_ANSI_STR_11
   \   00000134   940053E3           CMP      R3,#+148
   \   00000138   0400001A           BNE      ??convUTF8_to_ANSI_STR_12
   \   0000013C   BA10A0E3           MOV      R1,#+186
   \   00000140   050000EA           B        ??convUTF8_to_ANSI_STR_11
   \                     ??convUTF8_to_ANSI_STR_15:
   \   00000144   900053E3           CMP      R3,#+144
   \   00000148   C310A003           MOVEQ    R1,#+195
   \   0000014C   0200000A           BEQ      ??convUTF8_to_ANSI_STR_11
   \                     ??convUTF8_to_ANSI_STR_12:
   \   00000150   3F3003E2           AND      R3,R3,#0x3F
   \   00000154   B03083E2           ADD      R3,R3,#+176
   \   00000158   011383E1           ORR      R1,R3,R1, LSL #+6
   \                     ??convUTF8_to_ANSI_STR_11:
   \   0000015C   0710C6E7           STRB     R1,[R6, +R7]
   \   00000160   010080E2           ADD      R0,R0,#+1
   \   00000164   BFFFFFEA           B        ??convUTF8_to_ANSI_STR_6
   \                     ??convUTF8_to_ANSI_STR_9:
   \   00000168   F00051E3           CMP      R1,#+240
   \   0000016C   B5FFFF2A           BCS      ??convUTF8_to_ANSI_STR_3
   \   00000170   041080E0           ADD      R1,R0,R4
   \   00000174   0210D1E5           LDRB     R1,[R1, #+2]
   \   00000178   800051E3           CMP      R1,#+128
   \   0000017C   ADFFFF2A           BCS      ??convUTF8_to_ANSI_STR_2
   \   00000180   ........           LDR      R1,??DataTable8  ;; `?<Constant "Bad UTF-8 Encoding en...">` + 88
   \   00000184   C1FFFFEA           B        ??convUTF8_to_ANSI_STR_7
    491            }
    492            st_len = strlen(tmp_out);
   \                     ??convUTF8_to_ANSI_STR_4:
   \   00000188   0700A0E1           MOV      R0,R7
   \   0000018C   1B0000EF           SWI      +27
    493            tmp_out = realloc(tmp_out,st_len+1);
   \   00000190   011080E2           ADD      R1,R0,#+1
   \   00000194   0700A0E1           MOV      R0,R7
   \   00000198   BA0000EF           SWI      +186
    494            return tmp_out;
   \   0000019C   F081BDE8           POP      {R4-R8,PC}       ;; return
    495          }
    496          
    497          
    498          
    499          // Готовимся к отказу от ANSI вообще. Пока не используется, скоро, наверное, будет...
    500          
    501          /* UTF-8 to UTF-16 conversion.  Surrogates are handeled properly, e.g.
    502           * a single 4-byte UTF-8 character is encoded into a surrogate pair.
    503           * On the other hand, if the UTF-8 string contains surrogate values, this
    504           * is considered an error and returned as such.
    505           *
    506           * The destination array must be able to hold as many Unicode-16 characters
    507           * as there are ASCII characters in the UTF-8 string.  This in case all UTF-8
    508           * characters are ASCII characters.  No more will be needed.
    509           *
    510           * Copyright (c) 2000 Morten Rolland, Screen Media
    511           */
    512          

   \                                 In segment CODE, align 4, keep-with-next
    513          int utf8_to_utf16(char *utf8, int cc, char *unicode16)
    514          {
   \                     utf8_to_utf16:
   \   00000000   F0002DE9           PUSH     {R4-R7}
    515          	int count = 0;
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   010000EA           B        ??utf8_to_utf16_0
    516          	unsigned char c0, c1;
    517          	unsigned long scalar;
    518          
    519          	while(--cc >= 0) {
    520          		c0 = *utf8++;
    521          		/*DPRINTF("Trying: %02x\n",c0);*/
    522          
    523          		if ( c0 < 0x80 ) {
    524          			/* Plain ASCII character, simple translation :-) */
    525          			*unicode16++ = c0;
   \                     ??utf8_to_utf16_1:
   \   0000000C   ........           STRB     R12,[R2], #+1
    526          			count++;
   \                     ??utf8_to_utf16_2:
   \   00000010   0430A0E1           MOV      R3,R4
    527          			continue;
    528          		}
   \                     ??utf8_to_utf16_0:
   \   00000014   011051E2           SUBS     R1,R1,#+1
   \   00000018   3C00004A           BMI      ??utf8_to_utf16_3
   \   0000001C   ........           LDRB     R12,[R0], #+1
   \   00000020   014083E2           ADD      R4,R3,#+1
   \   00000024   80005CE3           CMP      R12,#+128
   \   00000028   F7FFFF3A           BCC      ??utf8_to_utf16_1
    529          
    530          		if ( (c0 & 0xc0) == 0x80 )
   \   0000002C   C0500CE2           AND      R5,R12,#0xC0
   \   00000030   800055E3           CMP      R5,#+128
   \   00000034   0000001A           BNE      ??utf8_to_utf16_4
    531          			/* Illegal; starts with 10xxxxxx */
    532          			return -1;
   \                     ??utf8_to_utf16_5:
   \   00000038   1D0000EA           B        ??utf8_to_utf16_6
    533          
    534          		/* c0 must be 11xxxxxx if we get here => at least 2 bytes */
    535          		scalar = c0;
    536          		if(--cc < 0)
   \                     ??utf8_to_utf16_4:
   \   0000003C   011051E2           SUBS     R1,R1,#+1
   \   00000040   1B00004A           BMI      ??utf8_to_utf16_6
    537          			return -1;
    538          		c1 = *utf8++;
   \   00000044   ........           LDRB     R6,[R0], #+1
    539          		/*DPRINTF("c1=%02x\n",c1);*/
    540          		if ( (c1 & 0xc0) != 0x80 )
   \   00000048   C07006E2           AND      R7,R6,#0xC0
   \   0000004C   800057E3           CMP      R7,#+128
   \   00000050   1700001A           BNE      ??utf8_to_utf16_6
    541          			/* Bad byte */
    542          			return -1;
    543          		scalar <<= 6;
    544          		scalar |= (c1 & 0x3f);
   \   00000054   3F6006E2           AND      R6,R6,#0x3F
   \   00000058   0C5386E1           ORR      R5,R6,R12, LSL #+6
    545          
    546          		if ( !(c0 & 0x20) ) {
   \   0000005C   20001CE3           TST      R12,#0x20
   \   00000060   0300001A           BNE      ??utf8_to_utf16_7
    547          			/* Two bytes UTF-8 */
    548          			if ( scalar < 0x80 )
   \   00000064   800055E3           CMP      R5,#+128
   \   00000068   1100003A           BCC      ??utf8_to_utf16_6
    549          				return -1;	/* Overlong encoding */
    550          			*unicode16++ = scalar & 0x7ff;
   \                     ??utf8_to_utf16_8:
   \   0000006C   ........           STRB     R5,[R2], #+1
    551          			count++;
   \   00000070   E6FFFFEA           B        ??utf8_to_utf16_2
    552          			continue;
    553          		}
    554          
    555          		/* c0 must be 111xxxxx if we get here => at least 3 bytes */
    556          		if(--cc < 0)
   \                     ??utf8_to_utf16_7:
   \   00000074   011051E2           SUBS     R1,R1,#+1
   \   00000078   0D00004A           BMI      ??utf8_to_utf16_6
    557          			return -1;
    558          		c1 = *utf8++;
   \   0000007C   ........           LDRB     R6,[R0], #+1
    559          		/*DPRINTF("c1=%02x\n",c1);*/
    560          		if ( (c1 & 0xc0) != 0x80 )
   \   00000080   C07006E2           AND      R7,R6,#0xC0
   \   00000084   800057E3           CMP      R7,#+128
   \   00000088   0900001A           BNE      ??utf8_to_utf16_6
    561          			/* Bad byte */
    562          			return -1;
    563          		scalar <<= 6;
    564          		scalar |= (c1 & 0x3f);
   \   0000008C   3F6006E2           AND      R6,R6,#0x3F
   \   00000090   055386E1           ORR      R5,R6,R5, LSL #+6
    565          
    566          		if ( !(c0 & 0x10) ) {
   \   00000094   10001CE3           TST      R12,#0x10
   \   00000098   0800001A           BNE      ??utf8_to_utf16_9
    567          			/*DPRINTF("####\n");*/
    568          			/* Three bytes UTF-8 */
    569          			if ( scalar < 0x800 )
   \   0000009C   800E55E3           CMP      R5,#+2048
   \   000000A0   0300003A           BCC      ??utf8_to_utf16_6
    570          				return -1;	/* Overlong encoding */
    571          			if ( scalar >= 0xd800 && scalar < 0xe000 )
   \   000000A4   D80C55E3           CMP      R5,#+55296
   \   000000A8   EFFFFF3A           BCC      ??utf8_to_utf16_8
   \   000000AC   E00C55E3           CMP      R5,#+57344
   \   000000B0   EDFFFF2A           BCS      ??utf8_to_utf16_8
   \                     ??utf8_to_utf16_6:
   \   000000B4   F000BDE8           POP      {R4-R7}
   \   000000B8   0000E0E3           MVN      R0,#+0
   \   000000BC   1EFF2FE1           BX       LR
    572          				return -1;	/* UTF-16 high/low halfs */
    573          			*unicode16++ = scalar & 0xffff;
    574          			count++;
    575          			continue;
    576          		}
    577          
    578          		/* c0 must be 1111xxxx if we get here => at least 4 bytes */
    579          		c1 = *utf8++;
   \                     ??utf8_to_utf16_9:
   \   000000C0   ........           LDRB     R6,[R0], #+1
    580          		if(--cc < 0)
   \   000000C4   011051E2           SUBS     R1,R1,#+1
   \   000000C8   F9FFFF4A           BMI      ??utf8_to_utf16_6
    581          			return -1;
    582          		/*DPRINTF("c1=%02x\n",c1);*/
    583          		if ( (c1 & 0xc0) != 0x80 )
   \   000000CC   C04006E2           AND      R4,R6,#0xC0
   \   000000D0   800054E3           CMP      R4,#+128
   \   000000D4   F6FFFF1A           BNE      ??utf8_to_utf16_6
    584          			/* Bad byte */
    585          			return -1;
    586          		scalar <<= 6;
    587          		scalar |= (c1 & 0x3f);
   \   000000D8   3F4006E2           AND      R4,R6,#0x3F
   \   000000DC   055384E1           ORR      R5,R4,R5, LSL #+6
    588          
    589          		if ( !(c0 & 0x08) ) {
   \   000000E0   08001CE3           TST      R12,#0x8
   \   000000E4   F2FFFF1A           BNE      ??utf8_to_utf16_6
    590          			/* Four bytes UTF-8, needs encoding as surrogates */
    591          			if ( scalar < 0x10000 )
   \   000000E8   400B55E3           CMP      R5,#+65536
   \   000000EC   F0FFFF3A           BCC      ??utf8_to_utf16_6
    592          				return -1;	/* Overlong encoding */
    593          			scalar -= 0x10000;
   \   000000F0   FF44A0E3           MOV      R4,#-16777216
   \   000000F4   FF4884E3           ORR      R4,R4,#0xFF0000
   \   000000F8   055084E0           ADD      R5,R4,R5
    594          			*unicode16++ = ((scalar >> 10) & 0x3ff) + 0xd800;
   \   000000FC   2545A0E1           LSR      R4,R5,#+10
   \   00000100   ........           STRB     R4,[R2], #+1
    595          			*unicode16++ = (scalar & 0x3ff) + 0xdc00;
   \   00000104   ........           STRB     R5,[R2], #+1
    596          			count += 2;
   \   00000108   023083E2           ADD      R3,R3,#+2
    597          			continue;
   \   0000010C   C0FFFFEA           B        ??utf8_to_utf16_0
    598          		}
    599          
    600          		return -1;	/* No support for more than four byte UTF-8 */
    601          	}
    602          	return count;
   \                     ??utf8_to_utf16_3:
   \   00000110   F000BDE8           POP      {R4-R7}
   \   00000114   0300A0E1           MOV      R0,R3
   \   00000118   1EFF2FE1           BX       LR               ;; return
    603          }
    604          
    605          
    606          
    607          
    608          /*
    609          Следующая функция взята из файла:
    610          http://www.cs.umd.edu/projects/hpsl/chaos/ResearchAreas/ic/dist/InterComm-1.5.tar.gz/InterComm/src/ezxml/ezxml.c
    611          
    612          В функции отключена проверка на UNICODE LE / BE, ибо в Сименсе используется только LE
    613          */
    614          #define EZXML_BUFSIZE 1024
    615          /* converts a UTF-16 string to UTF-8, returns a new string the must be freed or NULL if no conversion was needed*/
    616          //char *ezxml_to_utf8(char **s, size_t *len) - оригинальный заголовок

   \                                 In segment CODE, align 4, keep-with-next
    617          char *utf16_to_utf8(char **s, size_t *len)
    618          {
   \                     utf16_to_utf8:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0160A0E1           MOV      R6,R1
    619              char *u;
    620              size_t l = 0, sl, max = *len;
   \   00000008   009096E5           LDR      R9,[R6, #+0]
   \   0000000C   0050A0E1           MOV      R5,R0
    621              long c, c2;
    622              int b, be = 0;//be = (**s == '\xFE') ? 1 : (**s == '\xFF') ? 0 : -1; - отключение проверки!!!
    623          
    624              if (be == -1) return NULL; /* not UTF-16*/
    625          
    626              u = malloc(max); zeromem(u, max);
   \   00000010   0900A0E1           MOV      R0,R9
   \   00000014   140000EF           SWI      +20
   \   00000018   00A0A0E1           MOV      R10,R0
   \   0000001C   0910A0E1           MOV      R1,R9
   \   00000020   1D0100EF           SWI      +285
    627              //    for (sl = 2; sl < *len - 1; sl += 2) {      // Второй фикс: у нас строка на 2 байта больше
    628                  for (sl = 2; sl <= *len ; sl += 2) {
   \   00000024   000096E5           LDR      R0,[R6, #+0]
   \   00000028   0040A0E3           MOV      R4,#+0
   \   0000002C   0270A0E3           MOV      R7,#+2
   \   00000030   020050E3           CMP      R0,#+2
   \   00000034   4B00003A           BCC      ??utf16_to_utf8_0
    629                c = (be) ? ((long)(*s)[sl] << 8) | (*s)[sl + 1] : /* big-endian*/
    630          	((long)(*s)[sl + 1] << 8) | (*s)[sl];  /* little-endian*/
   \                     ??utf16_to_utf8_1:
   \   00000038   000095E5           LDR      R0,[R5, #+0]
   \   0000003C   001087E0           ADD      R1,R7,R0
   \   00000040   0120D1E5           LDRB     R2,[R1, #+1]
   \   00000044   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000048   028481E1           ORR      R8,R1,R2, LSL #+8
    631                if (c >= 0xD800 && c <= 0xDFFF && (sl += 2) < *len - 1) { /* high-half*/
   \   0000004C   D80C58E3           CMP      R8,#+55296
   \   00000050   160000BA           BLT      ??utf16_to_utf8_2
   \   00000054   E00C58E3           CMP      R8,#+57344
   \   00000058   140000AA           BGE      ??utf16_to_utf8_2
   \   0000005C   001096E5           LDR      R1,[R6, #+0]
   \   00000060   027087E2           ADD      R7,R7,#+2
   \   00000064   011041E2           SUB      R1,R1,#+1
   \   00000068   010057E1           CMP      R7,R1
   \   0000006C   0F00002A           BCS      ??utf16_to_utf8_2
    632          	c2 = (be) ? ((long)(*s)[sl] << 8) | (*s)[sl + 1] : /* big-endian*/
    633          	  ((long)(*s)[sl + 1] << 8) | (*s)[sl];  /* little-endian*/
    634                      c = (((c & 0x3FF) << 10) | (c2 & 0x3FF)) + 0x10000;
   \   00000070   000087E0           ADD      R0,R7,R0
   \   00000074   0130D0E5           LDRB     R3,[R0, #+1]
   \   00000078   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000007C   FF10A0E3           MOV      R1,#+255
   \   00000080   C01F81E3           ORR      R1,R1,#0x300
   \   00000084   082001E0           AND      R2,R1,R8
   \   00000088   030480E1           ORR      R0,R0,R3, LSL #+8
   \   0000008C   000001E0           AND      R0,R1,R0
   \   00000090   020580E1           ORR      R0,R0,R2, LSL #+10
   \   00000094   408B80E2           ADD      R8,R0,#+65536
   \   00000098   040000EA           B        ??utf16_to_utf8_2
    635                  }
    636          
    637                  while (l + 6 > max) u = realloc(u, max += EZXML_BUFSIZE);
   \                     ??utf16_to_utf8_3:
   \   0000009C   409E89E2           ADD      R9,R9,#+1024
   \   000000A0   0910A0E1           MOV      R1,R9
   \   000000A4   0A00A0E1           MOV      R0,R10
   \   000000A8   BA0000EF           SWI      +186
   \   000000AC   00A0A0E1           MOV      R10,R0
   \                     ??utf16_to_utf8_2:
   \   000000B0   060084E2           ADD      R0,R4,#+6
   \   000000B4   000059E1           CMP      R9,R0
   \   000000B8   F7FFFF3A           BCC      ??utf16_to_utf8_3
    638                  if (c < 0x80) u[l++] = c; /* US-ASCII subset*/
   \   000000BC   0A0084E0           ADD      R0,R4,R10
   \   000000C0   014084E2           ADD      R4,R4,#+1
   \   000000C4   800058E3           CMP      R8,#+128
   \   000000C8   0080C0B5           STRBLT   R8,[R0, #+0]
   \   000000CC   210000BA           BLT      ??utf16_to_utf8_4
    639                  else { /* multi-byte UTF-8 sequence*/
    640          	  for (b = 0, c2 = c; c2; c2 /= 2) b++; /* bits in c*/
   \   000000D0   0010A0E3           MOV      R1,#+0
   \   000000D4   0820A0E1           MOV      R2,R8
   \                     ??utf16_to_utf8_5:
   \   000000D8   011081E2           ADD      R1,R1,#+1
   \   000000DC   A22F82E0           ADD      R2,R2,R2, LSR #+31
   \   000000E0   C220B0E1           ASRS     R2,R2,#+1
   \   000000E4   FBFFFF1A           BNE      ??utf16_to_utf8_5
    641          	  b = (b - 2) / 5; /* bytes in payload;*/
   \   000000E8   8C209FE5           LDR      R2,??utf16_to_utf8_6  ;; 0x66666667
   \   000000EC   021041E2           SUB      R1,R1,#+2
   \   000000F0   9231CCE0           SMULL    R3,R12,R2,R1
    642          	  u[l++] = (0xFF << (7 - b)) | (c >> (6 * b)); /*head*/
   \   000000F4   FF20A0E3           MOV      R2,#+255
   \   000000F8   CCC0A0E1           ASR      R12,R12,#+1
   \   000000FC   A11F8CE0           ADD      R1,R12,R1, LSR #+31
   \   00000100   0130A0E1           MOV      R3,R1
   \   00000104   073063E2           RSB      R3,R3,#+7
   \   00000108   1223A0E1           LSL      R2,R2,R3
   \   0000010C   0130A0E1           MOV      R3,R1
   \   00000110   06C0A0E3           MOV      R12,#+6
   \   00000114   9C0303E0           MUL      R3,R12,R3
   \   00000118   000051E3           CMP      R1,#+0
   \   0000011C   5833A0E1           ASR      R3,R8,R3
   \   00000120   022083E1           ORR      R2,R3,R2
   \   00000124   0020C0E5           STRB     R2,[R0, #+0]
   \   00000128   0620A0E3           MOV      R2,#+6
   \   0000012C   0900000A           BEQ      ??utf16_to_utf8_4
    643          	  while (b) u[l++] = 0x80 | ((c >> (6 * --b)) & 0x3F); /* payload*/
   \                     ??utf16_to_utf8_7:
   \   00000130   011041E2           SUB      R1,R1,#+1
   \   00000134   0100A0E1           MOV      R0,R1
   \   00000138   920000E0           MUL      R0,R2,R0
   \   0000013C   000051E3           CMP      R1,#+0
   \   00000140   5800A0E1           ASR      R0,R8,R0
   \   00000144   3F0000E2           AND      R0,R0,#0x3F
   \   00000148   800080E3           ORR      R0,R0,#0x80
   \   0000014C   0A00C4E7           STRB     R0,[R4, +R10]
   \   00000150   014084E2           ADD      R4,R4,#+1
   \   00000154   F5FFFF1A           BNE      ??utf16_to_utf8_7
    644                  }
    645              }
   \                     ??utf16_to_utf8_4:
   \   00000158   000096E5           LDR      R0,[R6, #+0]
   \   0000015C   027087E2           ADD      R7,R7,#+2
   \   00000160   070050E1           CMP      R0,R7
   \   00000164   B3FFFF2A           BCS      ??utf16_to_utf8_1
    646          
    647              //return *s = realloc(u, *len = l);
    648              *len = l;
   \                     ??utf16_to_utf8_0:
   \   00000168   004086E5           STR      R4,[R6, #+0]
    649              u = realloc(u, l+1);    // Не убиваем исходную WSHDR!
   \   0000016C   011084E2           ADD      R1,R4,#+1
   \   00000170   0A00A0E1           MOV      R0,R10
   \   00000174   BA0000EF           SWI      +186
    650              return u;
   \   00000178   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??utf16_to_utf8_6:
   \   0000017C   67666666           DC32     0x66666667
    651          }
    652          
    653          
    654          /*
    655            Обеспечивает преобразование кривого UTF-8 Сименса в UTF-8 для Jabber
    656          */

   \                                 In segment CODE, align 4, keep-with-next
    657          char* Correct_UTF8_String(char* utf8_str)
    658          {
   \                     Correct_UTF8_String:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    659            int l = strlen(utf8_str)*2;
   \   00000008   1B0000EF           SWI      +27
    660            // ^ так нельзя делать цикл, строка на самом длиннее, чем strlen
    661            int j=0;
    662            int i=0;
    663            char character = *utf8_str;
   \   0000000C   0020D4E5           LDRB     R2,[R4, #+0]
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   0230B0E1           MOVS     R3,R2
   \   0000001C   0600000A           BEQ      ??Correct_UTF8_String_0
    664            while(character!='\0')
    665            {
    666              if(character!=0x1F)
   \                     ??Correct_UTF8_String_1:
   \   00000020   1F0052E3           CMP      R2,#+31
    667              {
    668                utf8_str[j]=character;
   \   00000024   0420C017           STRBNE   R2,[R0, +R4]
    669                j++;
    670              }
    671              i++;
   \   00000028   011081E2           ADD      R1,R1,#+1
    672              character = *(utf8_str+i);
   \   0000002C   0420D1E7           LDRB     R2,[R1, +R4]
   \   00000030   01008012           ADDNE    R0,R0,#+1
    673            }
   \   00000034   0230B0E1           MOVS     R3,R2
   \   00000038   F8FFFF1A           BNE      ??Correct_UTF8_String_1
    674            utf8_str[j]='\0';
   \                     ??Correct_UTF8_String_0:
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   0410C0E7           STRB     R1,[R0, +R4]
    675            utf8_str = realloc(utf8_str, j+1);
   \   00000044   011080E2           ADD      R1,R0,#+1
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   BA0000EF           SWI      +186
    676            return utf8_str;
   \   00000050   1080BDE8           POP      {R4,PC}          ;; return
    677          }
    678          
    679          

   \                                 In segment CODE, align 4, keep-with-next
    680          char * ANSI2UTF8(const char * ansi_str, int maxlen)
    681          {
   \                     ANSI2UTF8:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    682            int utf8_len = NULL;
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   00108DE5           STR      R1,[SP, #+0]
    683            WSHDR * ws_str = AllocWS(maxlen);
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   250100EF           SWI      +293
   \   00000020   0060A0E1           MOV      R6,R0
    684            ascii2ws(ws_str, ansi_str);
   \   00000024   0410A0E1           MOV      R1,R4
   \   00000028   ........           BL       ascii2ws
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   854080E0           ADD      R4,R0,R5, LSL #+1
   \   00000034   0400A0E1           MOV      R0,R4
    685            char * utf8_str = malloc(maxlen * 2 + 1);
   \   00000038   140000EF           SWI      +20
   \   0000003C   0050A0E1           MOV      R5,R0
    686            ws_2utf8(ws_str, utf8_str, &utf8_len, maxlen * 2 + 1);
   \   00000040   0430A0E1           MOV      R3,R4
   \   00000044   0D20A0E1           MOV      R2,SP
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0600A0E1           MOV      R0,R6
   \   00000050   E20100EF           SWI      +482
    687            FreeWS(ws_str);
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   290100EF           SWI      +297
    688            utf8_str = realloc(utf8_str, utf8_len + 1);
   \   0000005C   00009DE5           LDR      R0,[SP, #+0]
   \   00000060   011080E2           ADD      R1,R0,#+1
   \   00000064   0500A0E1           MOV      R0,R5
   \   00000068   BA0000EF           SWI      +186
    689            utf8_str[utf8_len] = '\0';
   \   0000006C   00109DE5           LDR      R1,[SP, #+0]
   \   00000070   0020A0E3           MOV      R2,#+0
   \   00000074   0020C1E7           STRB     R2,[R1, +R0]
    690            return utf8_str;
   \   00000078   7280BDE8           POP      {R1,R4-R6,PC}    ;; return
    691          }
    692          
    693          // From NatICQ
    694          
    695          typedef struct
    696          {
    697            unsigned short u;
    698            char dos;
    699            char win;
    700            char koi8;
    701          } TUNICODE2CHAR;
    702          

   \                                 In segment DATA_C, align 4, align-sorted
    703          const TUNICODE2CHAR unicode2char[]=
   \                     unicode2char:
   \   00000000   1004               DC16 1040
   \   00000002   80C0E100           DC8 128, 192, 225, 0
   \   00000006   1104               DC16 1041
   \   00000008   81C1E200           DC8 129, 193, 226, 0
   \   0000000C   1204               DC16 1042
   \   0000000E   82C2F700           DC8 130, 194, 247, 0
   \   00000012   1304               DC16 1043
   \   00000014   83C3E700           DC8 131, 195, 231, 0
   \   00000018   1404               DC16 1044
   \   0000001A   84C4E400           DC8 132, 196, 228, 0
   \   0000001E   1504               DC16 1045
   \   00000020   85C5E500           DC8 133, 197, 229, 0
   \   00000024   1604               DC16 1046
   \   00000026   86C6F600           DC8 134, 198, 246, 0
   \   0000002A   1704               DC16 1047
   \   0000002C   87C7FA00           DC8 135, 199, 250, 0
   \   00000030   1804               DC16 1048
   \   00000032   88C8E900           DC8 136, 200, 233, 0
   \   00000036   1904               DC16 1049
   \   00000038   89C9EA00           DC8 137, 201, 234, 0
   \   0000003C   1A04               DC16 1050
   \   0000003E   8ACAEB00           DC8 138, 202, 235, 0
   \   00000042   1B04               DC16 1051
   \   00000044   8BCBEC00           DC8 139, 203, 236, 0
   \   00000048   1C04               DC16 1052
   \   0000004A   8CCCED00           DC8 140, 204, 237, 0
   \   0000004E   1D04               DC16 1053
   \   00000050   8DCDEE00           DC8 141, 205, 238, 0
   \   00000054   1E04               DC16 1054
   \   00000056   8ECEEF00           DC8 142, 206, 239, 0
   \   0000005A   1F04               DC16 1055
   \   0000005C   8FCFF000           DC8 143, 207, 240, 0
   \   00000060   2004               DC16 1056
   \   00000062   90D0F200           DC8 144, 208, 242, 0
   \   00000066   2104               DC16 1057
   \   00000068   91D1F300           DC8 145, 209, 243, 0
   \   0000006C   2204               DC16 1058
   \   0000006E   92D2F400           DC8 146, 210, 244, 0
   \   00000072   2304               DC16 1059
   \   00000074   93D3F500           DC8 147, 211, 245, 0
   \   00000078   2404               DC16 1060
   \   0000007A   94D4E600           DC8 148, 212, 230, 0
   \   0000007E   2504               DC16 1061
   \   00000080   95D5E800           DC8 149, 213, 232, 0
   \   00000084   2604               DC16 1062
   \   00000086   96D6E300           DC8 150, 214, 227, 0
   \   0000008A   2704               DC16 1063
   \   0000008C   97D7FE00           DC8 151, 215, 254, 0
   \   00000090   2804               DC16 1064
   \   00000092   98D8FB00           DC8 152, 216, 251, 0
   \   00000096   2904               DC16 1065
   \   00000098   99D9FD00           DC8 153, 217, 253, 0
   \   0000009C   2A04               DC16 1066
   \   0000009E   9ADAFF00           DC8 154, 218, 255, 0
   \   000000A2   2B04               DC16 1067
   \   000000A4   9BDBF900           DC8 155, 219, 249, 0
   \   000000A8   2C04               DC16 1068
   \   000000AA   9CDCF800           DC8 156, 220, 248, 0
   \   000000AE   2D04               DC16 1069
   \   000000B0   9DDDFC00           DC8 157, 221, 252, 0
   \   000000B4   2E04               DC16 1070
   \   000000B6   9EDEE000           DC8 158, 222, 224, 0
   \   000000BA   2F04               DC16 1071
   \   000000BC   9FDFF100           DC8 159, 223, 241, 0
   \   000000C0   0204               DC16 1026
   \   000000C2   5F805F00           DC8 95, 128, 95, 0
   \   000000C6   0304               DC16 1027
   \   000000C8   5F815F00           DC8 95, 129, 95, 0
   \   000000CC   0904               DC16 1033
   \   000000CE   5F8A5F00           DC8 95, 138, 95, 0
   \   000000D2   0A04               DC16 1034
   \   000000D4   5F8C5F00           DC8 95, 140, 95, 0
   \   000000D8   0C04               DC16 1036
   \   000000DA   5F8D5F00           DC8 95, 141, 95, 0
   \   000000DE   0B04               DC16 1035
   \   000000E0   5F8E5F00           DC8 95, 142, 95, 0
   \   000000E4   0F04               DC16 1039
   \   000000E6   5F8F5F00           DC8 95, 143, 95, 0
   \   000000EA   0E04               DC16 1038
   \   000000EC   F6A15F00           DC8 246, 161, 95, 0
   \   000000F0   0804               DC16 1032
   \   000000F2   4AA34A00           DC8 74, 163, 74, 0
   \   000000F6   0904               DC16 1033
   \   000000F8   83A5BD00           DC8 131, 165, 189, 0
   \   000000FC   0104               DC16 1025
   \   000000FE   F0A8B300           DC8 240, 168, 179, 0
   \   00000102   0404               DC16 1028
   \   00000104   F2AAB400           DC8 242, 170, 180, 0
   \   00000108   0704               DC16 1031
   \   0000010A   F4AFB700           DC8 244, 175, 183, 0
   \   0000010E   0604               DC16 1030
   \   00000110   49B2B600           DC8 73, 178, 182, 0
   \   00000114   0504               DC16 1029
   \   00000116   53BD5300           DC8 83, 189, 83, 0
   \   0000011A   3004               DC16 1072
   \   0000011C   A0E0C100           DC8 160, 224, 193, 0
   \   00000120   3104               DC16 1073
   \   00000122   A1E1C200           DC8 161, 225, 194, 0
   \   00000126   3204               DC16 1074
   \   00000128   A2E2D700           DC8 162, 226, 215, 0
   \   0000012C   3304               DC16 1075
   \   0000012E   A3E3C700           DC8 163, 227, 199, 0
   \   00000132   3404               DC16 1076
   \   00000134   A4E4C400           DC8 164, 228, 196, 0
   \   00000138   3504               DC16 1077
   \   0000013A   A5E5C500           DC8 165, 229, 197, 0
   \   0000013E   3604               DC16 1078
   \   00000140   A6E6D600           DC8 166, 230, 214, 0
   \   00000144   3704               DC16 1079
   \   00000146   A7E7DA00           DC8 167, 231, 218, 0
   \   0000014A   3804               DC16 1080
   \   0000014C   A8E8C900           DC8 168, 232, 201, 0
   \   00000150   3904               DC16 1081
   \   00000152   A9E9CA00           DC8 169, 233, 202, 0
   \   00000156   3A04               DC16 1082
   \   00000158   AAEACB00           DC8 170, 234, 203, 0
   \   0000015C   3B04               DC16 1083
   \   0000015E   ABEBCC00           DC8 171, 235, 204, 0
   \   00000162   3C04               DC16 1084
   \   00000164   ACECCD00           DC8 172, 236, 205, 0
   \   00000168   3D04               DC16 1085
   \   0000016A   ADEDCE00           DC8 173, 237, 206, 0
   \   0000016E   3E04               DC16 1086
   \   00000170   AEEECF00           DC8 174, 238, 207, 0
   \   00000174   3F04               DC16 1087
   \   00000176   AFEFD000           DC8 175, 239, 208, 0
   \   0000017A   4004               DC16 1088
   \   0000017C   E0F0D200           DC8 224, 240, 210, 0
   \   00000180   4104               DC16 1089
   \   00000182   E1F1D300           DC8 225, 241, 211, 0
   \   00000186   4204               DC16 1090
   \   00000188   E2F2D400           DC8 226, 242, 212, 0
   \   0000018C   4304               DC16 1091
   \   0000018E   E3F3D500           DC8 227, 243, 213, 0
   \   00000192   4404               DC16 1092
   \   00000194   E4F4C600           DC8 228, 244, 198, 0
   \   00000198   4504               DC16 1093
   \   0000019A   E5F5C800           DC8 229, 245, 200, 0
   \   0000019E   4604               DC16 1094
   \   000001A0   E6F6C300           DC8 230, 246, 195, 0
   \   000001A4   4704               DC16 1095
   \   000001A6   E7F7DE00           DC8 231, 247, 222, 0
   \   000001AA   4804               DC16 1096
   \   000001AC   E8F8DB00           DC8 232, 248, 219, 0
   \   000001B0   4904               DC16 1097
   \   000001B2   E9F9DD00           DC8 233, 249, 221, 0
   \   000001B6   4A04               DC16 1098
   \   000001B8   EAFADF00           DC8 234, 250, 223, 0
   \   000001BC   4B04               DC16 1099
   \   000001BE   EBFBD900           DC8 235, 251, 217, 0
   \   000001C2   4C04               DC16 1100
   \   000001C4   ECFCD800           DC8 236, 252, 216, 0
   \   000001C8   4D04               DC16 1101
   \   000001CA   EDFDDC00           DC8 237, 253, 220, 0
   \   000001CE   4E04               DC16 1102
   \   000001D0   EEFEC000           DC8 238, 254, 192, 0
   \   000001D4   4F04               DC16 1103
   \   000001D6   EFFFD100           DC8 239, 255, 209, 0
   \   000001DA   5204               DC16 1106
   \   000001DC   5F905F00           DC8 95, 144, 95, 0
   \   000001E0   5304               DC16 1107
   \   000001E2   5F835F00           DC8 95, 131, 95, 0
   \   000001E6   5904               DC16 1113
   \   000001E8   5F9A5F00           DC8 95, 154, 95, 0
   \   000001EC   5A04               DC16 1114
   \   000001EE   5F9C5F00           DC8 95, 156, 95, 0
   \   000001F2   5C04               DC16 1116
   \   000001F4   5F9D5F00           DC8 95, 157, 95, 0
   \   000001F8   5B04               DC16 1115
   \   000001FA   5F9E5F00           DC8 95, 158, 95, 0
   \   000001FE   5F04               DC16 1119
   \   00000200   5F9F5F00           DC8 95, 159, 95, 0
   \   00000204   5E04               DC16 1118
   \   00000206   F7A25F00           DC8 247, 162, 95, 0
   \   0000020A   5804               DC16 1112
   \   0000020C   6ABC6A00           DC8 106, 188, 106, 0
   \   00000210   9104               DC16 1169
   \   00000212   A3B4AD00           DC8 163, 180, 173, 0
   \   00000216   5104               DC16 1105
   \   00000218   F1B8A300           DC8 241, 184, 163, 0
   \   0000021C   5404               DC16 1108
   \   0000021E   F3BAA400           DC8 243, 186, 164, 0
   \   00000222   5704               DC16 1111
   \   00000224   F5BFA700           DC8 245, 191, 167, 0
   \   00000228   5604               DC16 1110
   \   0000022A   69B3A600           DC8 105, 179, 166, 0
   \   0000022E   5504               DC16 1109
   \   00000230   73BE7300           DC8 115, 190, 115, 0
   \   00000234   A000               DC16 160
   \   00000236   5FA02000           DC8 95, 160, 32, 0
   \   0000023A   A400               DC16 164
   \   0000023C   5FA4FD00           DC8 95, 164, 253, 0
   \   00000240   A600               DC16 166
   \   00000242   5FA65F00           DC8 95, 166, 95, 0
   \   00000246   B000               DC16 176
   \   00000248   F8B09C00           DC8 248, 176, 156, 0
   \   0000024C   B700               DC16 183
   \   0000024E   FAB79E00           DC8 250, 183, 158, 0
   \   00000252   0000               DC16 0
   \   00000254   00000000           DC8 0, 0, 0, 0
    704          {
    705            // CAPITAL Cyrillic letters (base)
    706            0x410,0x80,0xC0,0xE1, // А
    707            0x411,0x81,0xC1,0xE2, // Б
    708            0x412,0x82,0xC2,0xF7, // В
    709            0x413,0x83,0xC3,0xE7, // Г
    710            0x414,0x84,0xC4,0xE4, // Д
    711            0x415,0x85,0xC5,0xE5, // Е
    712            0x416,0x86,0xC6,0xF6, // Ж
    713            0x417,0x87,0xC7,0xFA, // З
    714            0x418,0x88,0xC8,0xE9, // И
    715            0x419,0x89,0xC9,0xEA, // Й
    716            0x41A,0x8A,0xCA,0xEB, // К
    717            0x41B,0x8B,0xCB,0xEC, // Л
    718            0x41C,0x8C,0xCC,0xED, // М
    719            0x41D,0x8D,0xCD,0xEE, // Н
    720            0x41E,0x8E,0xCE,0xEF, // О
    721            0x41F,0x8F,0xCF,0xF0, // П
    722            0x420,0x90,0xD0,0xF2, // Р
    723            0x421,0x91,0xD1,0xF3, // С
    724            0x422,0x92,0xD2,0xF4, // Т
    725            0x423,0x93,0xD3,0xF5, // У
    726            0x424,0x94,0xD4,0xE6, // Ф
    727            0x425,0x95,0xD5,0xE8, // Х
    728            0x426,0x96,0xD6,0xE3, // Ц
    729            0x427,0x97,0xD7,0xFE, // Ч
    730            0x428,0x98,0xD8,0xFB, // Ш
    731            0x429,0x99,0xD9,0xFD, // Щ
    732            0x42A,0x9A,0xDA,0xFF, // Ъ
    733            0x42B,0x9B,0xDB,0xF9, // Ы
    734            0x42C,0x9C,0xDC,0xF8, // Ь
    735            0x42D,0x9D,0xDD,0xFC, // Э
    736            0x42E,0x9E,0xDE,0xE0, // Ю
    737            0x42F,0x9F,0xDF,0xF1, // Я
    738            // CAPITAL Cyrillic letters (additional)
    739            0x402,'_',0x80,'_', // _ .*.*
    740            0x403,'_',0x81,'_', // _ .*.*
    741            0x409,'_',0x8A,'_', // _ .*.*
    742            0x40A,'_',0x8C,'_', // _ .*.*
    743            0x40C,'_',0x8D,'_', // _ .*.*
    744            0x40B,'_',0x8E,'_', // _ .*.*
    745            0x40F,'_',0x8F,'_', // _ .*.*
    746            0x40E,0xF6,0xA1,'_', // Ў ...*
    747            0x408,0x4A,0xA3,0x4A, // _ .*.*
    748            0x409,0x83,0xA5,0xBD, // _ .*..
    749            0x401,0xF0,0xA8,0xB3, // Ё
    750            0x404,0xF2,0xAA,0xB4, // Є
    751            0x407,0xF4,0xAF,0xB7, // Ї
    752            0x406,0x49,0xB2,0xB6, // _ .*..
    753            0x405,0x53,0xBD,0x53, // _ .*.*
    754            // SMALL Cyrillic letters (base)
    755            0x430,0xA0,0xE0,0xC1, // а
    756            0x431,0xA1,0xE1,0xC2, // б
    757            0x432,0xA2,0xE2,0xD7, // в
    758            0x433,0xA3,0xE3,0xC7, // г
    759            0x434,0xA4,0xE4,0xC4, // д
    760            0x435,0xA5,0xE5,0xC5, // е
    761            0x436,0xA6,0xE6,0xD6, // ж
    762            0x437,0xA7,0xE7,0xDA, // з
    763            0x438,0xA8,0xE8,0xC9, // и
    764            0x439,0xA9,0xE9,0xCA, // й
    765            0x43A,0xAA,0xEA,0xCB, // к
    766            0x43B,0xAB,0xEB,0xCC, // л
    767            0x43C,0xAC,0xEC,0xCD, // м
    768            0x43D,0xAD,0xED,0xCE, // н
    769            0x43E,0xAE,0xEE,0xCF, // о
    770            0x43F,0xAF,0xEF,0xD0, // п
    771            0x440,0xE0,0xF0,0xD2, // р
    772            0x441,0xE1,0xF1,0xD3, // с
    773            0x442,0xE2,0xF2,0xD4, // т
    774            0x443,0xE3,0xF3,0xD5, // у
    775            0x444,0xE4,0xF4,0xC6, // ф
    776            0x445,0xE5,0xF5,0xC8, // х
    777            0x446,0xE6,0xF6,0xC3, // ц
    778            0x447,0xE7,0xF7,0xDE, // ч
    779            0x448,0xE8,0xF8,0xDB, // ш
    780            0x449,0xE9,0xF9,0xDD, // щ
    781            0x44A,0xEA,0xFA,0xDF, // ъ
    782            0x44B,0xEB,0xFB,0xD9, // ы
    783            0x44C,0xEC,0xFC,0xD8, // ь
    784            0x44D,0xED,0xFD,0xDC, // э
    785            0x44E,0xEE,0xFE,0xC0, // ю
    786            0x44F,0xEF,0xFF,0xD1, // я
    787            // SMALL Cyrillic letters (additional)
    788            0x452,'_',0x90,'_', // _ .*.*
    789            0x453,'_',0x83,'_', // _ .*.*
    790            0x459,'_',0x9A,'_', // _ .*.*
    791            0x45A,'_',0x9C,'_', // _ .*.*
    792            0x45C,'_',0x9D,'_', // _ .*.*
    793            0x45B,'_',0x9E,'_', // _ .*.*
    794            0x45F,'_',0x9F,'_', // _ .*.*
    795            0x45E,0xF7,0xA2,'_', // ў ...*
    796            0x458,0x6A,0xBC,0x6A, // _ .*.*
    797            0x491,0xA3,0xB4,0xAD, // _ .*..
    798            0x451,0xF1,0xB8,0xA3, // ё
    799            0x454,0xF3,0xBA,0xA4, // є
    800            0x457,0xF5,0xBF,0xA7, // ї
    801            0x456,0x69,0xB3,0xA6, // _ .*..
    802            0x455,0x73,0xBE,0x73, // _ .*.*
    803            0x0A0,'_',0xA0,0x20, // space .*..
    804            0x0A4,'_',0xA4,0xFD, // ¤   .*..
    805            0x0A6,'_',0xA6,'_', // ¦   .*.*
    806            0x0B0,0xF8,0xB0,0x9C, // °
    807            0x0B7,0xFA,0xB7,0x9E, // ·
    808            // 0x2022,,0x95,0x95, //    .*..
    809            // 0x2116,0xFC,0xB9,0x23, // №   ...*
    810            // 0x2219,,0xF9,0x9E, //    .*..
    811            // 0x221A,0xFB,,0x96, // v   ..*.
    812            // 0x25A0,0xFE,,0x94, // ¦
    813            0x0000,0,0,0
    814          };
    815          

   \                                 In segment DATA_C, align 4, align-sorted
    816          const unsigned short win2unicode[128]=
   \                     win2unicode:
   \   00000000   020403041A20       DC16 1026, 1027, 8218, 1107, 8222, 8230, 8224, 8225, 8364, 8240, 1033
   \              53041E202620
   \              20202120AC20
   \              30200904    
   \   00000016   39200A040C04       DC16 8249, 1034, 1036, 1035, 1039, 1106, 8216, 8217, 8220, 8221, 8226
   \              0B040F045204
   \              182019201C20
   \              1D202220    
   \   0000002C   132014202000       DC16 8211, 8212, 32, 8482, 1113, 8250, 1114, 1116, 1115, 1119, 160
   \              222159043A20
   \              5A045C045B04
   \              5F04A000    
   \   00000042   0E045E040804       DC16 1038, 1118, 1032, 164, 1168, 166, 167, 1025, 169, 1028, 171, 172
   \              A4009004A600
   \              A7000104A900
   \              0404AB00AC00
   \   0000005A   AD00AE000704       DC16 173, 174, 1031, 176, 177, 1030, 1110, 1169, 181, 182, 183, 1105
   \              B000B1000604
   \              56049104B500
   \              B600B7005104
   \   00000072   16215404BB00       DC16 8470, 1108, 187, 1112, 1029, 1109, 1111, 1040, 1041, 1042, 1043
   \              580405045504
   \              570410041104
   \              12041304    
   \   00000088   140415041604       DC16 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054
   \              170418041904
   \              1A041B041C04
   \              1D041E04    
   \   0000009E   1F0420042104       DC16 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065
   \              220423042404
   \              250426042704
   \              28042904    
   \   000000B4   2A042B042C04       DC16 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076
   \              2D042E042F04
   \              300431043204
   \              33043404    
   \   000000CA   350436043704       DC16 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087
   \              380439043A04
   \              3B043C043D04
   \              3E043F04    
   \   000000E0   400441044204       DC16 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098
   \              430444044504
   \              460447044804
   \              49044A04    
   \   000000F6   4B044C044D04       DC16 1099, 1100, 1101, 1102, 1103
   \              4E044F04    
    817          {
    818            0x0402,0x0403,0x201A,0x0453,0x201E,0x2026,0x2020,0x2021,
    819            0x20AC,0x2030,0x0409,0x2039,0x040A,0x040C,0x040B,0x040F,
    820            0x0452,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,
    821            0x0020,0x2122,0x0459,0x203A,0x045A,0x045C,0x045B,0x045F,
    822            0x00A0,0x040E,0x045E,0x0408,0x00A4,0x0490,0x00A6,0x00A7,
    823            0x0401,0x00A9,0x0404,0x00AB,0x00AC,0x00AD,0x00AE,0x0407,
    824            0x00B0,0x00B1,0x0406,0x0456,0x0491,0x00B5,0x00B6,0x00B7,
    825            0x0451,0x2116,0x0454,0x00BB,0x0458,0x0405,0x0455,0x0457,
    826            0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,
    827            0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,
    828            0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,
    829            0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,
    830            0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,
    831            0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,
    832            0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,
    833            0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F
    834          };
    835          

   \                                 In segment CODE, align 4, keep-with-next
    836          unsigned int char8to16(int c)
    837          {
    838            if (c>=128)
   \                     char8to16:
   \   00000000   800050E3           CMP      R0,#+128
   \   00000004   1EFF2FB1           BXLT     LR
    839            {
    840              return(win2unicode[c-128]);
   \   00000008   0C209FE5           LDR      R2,??char8to16_0  ;; win2unicode
   \   0000000C   FF10E0E3           MVN      R1,#+255
   \   00000010   800082E0           ADD      R0,R2,R0, LSL #+1
   \   00000014   B00091E1           LDRH     R0,[R1, +R0]
    841            }
    842            return(c);
   \   00000018   1EFF2FE1           BX       LR               ;; return
   \                     ??char8to16_0:
   \   0000001C   ........           DC32     win2unicode
    843          }
    844          

   \                                 In segment CODE, align 4, keep-with-next
    845          unsigned int char16to8(unsigned int c)
    846          {
    847            const TUNICODE2CHAR *p=unicode2char;
   \                     char16to8:
   \   00000000   38109FE5           LDR      R1,??char16to8_0  ;; unicode2char
    848            unsigned int i;
    849            if (c<128) return(c);
   \   00000004   800050E3           CMP      R0,#+128
   \   00000008   0100002A           BCS      ??char16to8_1
   \   0000000C   1EFF2FE1           BX       LR
    850            while((i=p->u))
    851            {
    852              if (c==i)
    853              {
    854                return(p->win);
    855              }
    856              p++;
   \                     ??char16to8_2:
   \   00000010   061081E2           ADD      R1,R1,#+6
   \                     ??char16to8_1:
   \   00000014   B020D1E1           LDRH     R2,[R1, #+0]
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   0300000A           BEQ      ??char16to8_3
   \   00000020   020050E1           CMP      R0,R2
   \   00000024   F9FFFF1A           BNE      ??char16to8_2
   \   00000028   0300D1E5           LDRB     R0,[R1, #+3]
   \   0000002C   1EFF2FE1           BX       LR
    857            }
    858            c&=0xFF;
   \                     ??char16to8_3:
   \   00000030   FF0000E2           AND      R0,R0,#0xFF
    859            if (c<32) return(' ');
   \   00000034   200050E3           CMP      R0,#+32
   \   00000038   2000A033           MOVCC    R0,#+32
    860            return(c);
   \   0000003C   1EFF2FE1           BX       LR               ;; return
   \                     ??char16to8_0:
   \   00000040   ........           DC32     unicode2char
    861          }
    862          

   \                                 In segment CODE, align 4, keep-with-next
    863          void ascii2ws(WSHDR *ws, const char *s)
    864          {
   \                     ascii2ws:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    865            char c;
    866            CutWSTR(ws,0);
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   260100EF           SWI      +294
   \   00000014   030000EA           B        ??ascii2ws_0
    867            while((c=*s++))
    868            {
    869              wsAppendChar(ws,char8to16(c));
   \                     ??ascii2ws_1:
   \   00000018   ........           BL       char8to16
   \   0000001C   0010A0E1           MOV      R1,R0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   1C0000EF           SWI      +28
    870            }
   \                     ??ascii2ws_0:
   \   00000028   ........           LDRB     R1,[R5], #+1
   \   0000002C   0100B0E1           MOVS     R0,R1
   \   00000030   F8FFFF1A           BNE      ??ascii2ws_1
    871          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
    872          

   \                                 In segment CODE, align 4, keep-with-next
    873          void utf82win(char *d, const char *s)
    874          {
   \                     utf82win:
   \   00000000   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000004   000052E3           CMP      R2,#+0
   \   00000008   3500000A           BEQ      ??utf82win_0
    875            for (; *s; s+=2)
    876            {
    877              unsigned char ub = *s, lb = *(s+1);
   \                     ??utf82win_1:
   \   0000000C   0030D1E5           LDRB     R3,[R1, #+0]
   \   00000010   0120D1E5           LDRB     R2,[R1, #+1]
    878              if (ub == 0xD0)
   \   00000014   D00053E3           CMP      R3,#+208
   \   00000018   1000001A           BNE      ??utf82win_2
    879              {
    880                               if(lb == 0x81){*d = 0xA8;}//Ё
   \   0000001C   810052E3           CMP      R2,#+129
   \   00000020   0200001A           BNE      ??utf82win_3
   \   00000024   A820A0E3           MOV      R2,#+168
   \                     ??utf82win_4:
   \   00000028   0020C0E5           STRB     R2,[R0, #+0]
   \   0000002C   280000EA           B        ??utf82win_5
    881          		else if(lb == 0x86){*d = 0xB2;}//І
   \                     ??utf82win_3:
   \   00000030   860052E3           CMP      R2,#+134
   \   00000034   B220A003           MOVEQ    R2,#+178
   \   00000038   FAFFFF0A           BEQ      ??utf82win_4
    882          		else if(lb == 0x87){*d = 0xAF;}//Ї
   \   0000003C   870052E3           CMP      R2,#+135
   \   00000040   0100001A           BNE      ??utf82win_6
   \   00000044   AF20A0E3           MOV      R2,#+175
   \                     ??utf82win_7:
   \   00000048   F6FFFFEA           B        ??utf82win_4
    883          		else if(lb == 0x84){*d = 0xAA;}//Є
   \                     ??utf82win_6:
   \   0000004C   840052E3           CMP      R2,#+132
   \   00000050   AA20A003           MOVEQ    R2,#+170
   \   00000054   F3FFFF0A           BEQ      ??utf82win_4
    884          	  else {*d = lb + 48;}
   \   00000058   302082E2           ADD      R2,R2,#+48
   \   0000005C   F1FFFFEA           B        ??utf82win_4
    885              } else
    886              if (ub == 0xD1)
   \                     ??utf82win_2:
   \   00000060   D10053E3           CMP      R3,#+209
   \   00000064   0F00001A           BNE      ??utf82win_8
    887              {
    888                               if(lb == 0x91){*d = 0xB8;}//ё
   \   00000068   910052E3           CMP      R2,#+145
   \   0000006C   B820A003           MOVEQ    R2,#+184
   \   00000070   ECFFFF0A           BEQ      ??utf82win_4
    889          		else if(lb == 0x96){*d = 0xB3;}//і
   \   00000074   960052E3           CMP      R2,#+150
   \   00000078   0200001A           BNE      ??utf82win_9
   \   0000007C   B320A0E3           MOV      R2,#+179
   \                     ??utf82win_10:
   \   00000080   0020C0E5           STRB     R2,[R0, #+0]
   \   00000084   120000EA           B        ??utf82win_5
    890          		else if(lb == 0x97){*d = 0xBF;}//ї
   \                     ??utf82win_9:
   \   00000088   970052E3           CMP      R2,#+151
   \   0000008C   BF20A003           MOVEQ    R2,#+191
   \   00000090   E4FFFF0A           BEQ      ??utf82win_4
    891          		else if(lb == 0x94){*d = 0xBA;}//є
   \   00000094   940052E3           CMP      R2,#+148
   \   00000098   BA20A003           MOVEQ    R2,#+186
   \   0000009C   E1FFFF0A           BEQ      ??utf82win_4
    892          	        else {*d = lb + 112;}
   \   000000A0   702082E2           ADD      R2,R2,#+112
   \   000000A4   DFFFFFEA           B        ??utf82win_4
    893              } else
    894              if (ub == 0xD2)
   \                     ??utf82win_8:
   \   000000A8   D20053E3           CMP      R3,#+210
   \   000000AC   0600001A           BNE      ??utf82win_11
    895              {
    896          //        if(lb == 0x91){*d = 0xB4;}//ґ
    897          //        if(lb == 0x90){*d = 0xA5;}//Ґ
    898                  if(lb == 0x91){*d = 0xE3;}//ґ->г
   \   000000B0   910052E3           CMP      R2,#+145
   \   000000B4   E320A003           MOVEQ    R2,#+227
   \   000000B8   F0FFFF0A           BEQ      ??utf82win_10
    899                  if(lb == 0x90){*d = 0xC3;}//Ґ->Г
   \   000000BC   900052E3           CMP      R2,#+144
   \   000000C0   0300001A           BNE      ??utf82win_5
   \   000000C4   C320A0E3           MOV      R2,#+195
   \   000000C8   D6FFFFEA           B        ??utf82win_4
    900              } else
    901              {
    902                *d = ub;
   \                     ??utf82win_11:
   \   000000CC   0030C0E5           STRB     R3,[R0, #+0]
    903                s--;
   \   000000D0   011041E2           SUB      R1,R1,#+1
    904              }
    905                d++;
    906            }
   \                     ??utf82win_5:
   \   000000D4   0220F1E5           LDRB     R2,[R1, #+2]!
   \   000000D8   010080E2           ADD      R0,R0,#+1
   \   000000DC   000052E3           CMP      R2,#+0
   \   000000E0   C9FFFF1A           BNE      ??utf82win_1
    907            *d = 0;
   \                     ??utf82win_0:
   \   000000E4   0010A0E3           MOV      R1,#+0
   \   000000E8   0010C0E5           STRB     R1,[R0, #+0]
    908          }
   \   000000EC   1EFF2FE1           BX       LR               ;; return
    909          

   \                                 In segment CODE, align 4, keep-with-next
    910          long GetIDLETime(TTime intime, TDate indate)
    911          {
   \                     GetIDLETime:
   \   00000000   1F402DE9           PUSH     {R0-R4,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
    912           TTime endt;
    913           TDate endd;
    914          // TDate endd, resd;
    915           signed int res=0, rmin=0;
    916           long resul=0;
    917           GetDateTime(&endd, &endt);
   \   00000008   0D10A0E1           MOV      R1,SP
   \   0000000C   08008DE2           ADD      R0,SP,#+8
   \   00000010   B40000EF           SWI      +180
    918           res = endt.sec - intime.sec;
   \   00000014   0200DDE5           LDRB     R0,[SP, #+2]
   \   00000018   1210DDE5           LDRB     R1,[SP, #+18]
    919           if (res < 0)
    920           {
    921             res = 60 + res;
    922             rmin = 1;
    923           }
    924           resul = res;
    925           res = endt.min - intime.min - rmin;
   \   0000001C   1120DDE5           LDRB     R2,[SP, #+17]
   \   00000020   0040A0E3           MOV      R4,#+0
   \   00000024   010050E0           SUBS     R0,R0,R1
   \   00000028   0110DDE5           LDRB     R1,[SP, #+1]
   \   0000002C   3C008042           ADDMI    R0,R0,#+60
   \   00000030   0140A043           MOVMI    R4,#+1
   \   00000034   021041E0           SUB      R1,R1,R2
   \   00000038   041051E0           SUBS     R1,R1,R4
    926           rmin = 0;
    927           if (res <0 )
    928           {
    929             res = 60 + res;
   \   0000003C   3C108142           ADDMI    R1,R1,#+60
    930             rmin = 1;
    931           }
    932           resul = resul + res*60;
   \   00000040   3C30A0E3           MOV      R3,#+60
   \   00000044   930120E0           MLA      R0,R3,R1,R0
    933           res = endt.hour - intime.hour - rmin;
   \   00000048   0010DDE5           LDRB     R1,[SP, #+0]
   \   0000004C   1030DDE5           LDRB     R3,[SP, #+16]
   \   00000050   0020A0E3           MOV      R2,#+0
   \   00000054   0120A043           MOVMI    R2,#+1
   \   00000058   031041E0           SUB      R1,R1,R3
   \   0000005C   021051E0           SUBS     R1,R1,R2
    934           rmin = 0;
    935           if (res < 0) 
    936           {
    937             res = 24 + res;
   \   00000060   18108142           ADDMI    R1,R1,#+24
    938             rmin = 1;
    939           }
    940           resul = resul + res*3600;
   \   00000064   E13EA0E3           MOV      R3,#+3600
   \   00000068   930120E0           MLA      R0,R3,R1,R0
    941           res = endd.day - indate.day - rmin;
   \   0000006C   0D10DDE5           LDRB     R1,[SP, #+13]
   \   00000070   1D30DDE5           LDRB     R3,[SP, #+29]
   \   00000074   0020A0E3           MOV      R2,#+0
   \   00000078   0120A043           MOVMI    R2,#+1
   \   0000007C   031041E0           SUB      R1,R1,R3
   \   00000080   021051E0           SUBS     R1,R1,R2
    942           rmin = 0; 
    943           if (res < 0)
    944           {
    945             res = 31 + res;
   \   00000084   1F108142           ADDMI    R1,R1,#+31
    946          //   rmin=1;
    947           }
    948           resul = resul + res*86400;
    949          /*
    950           res = end.mounth - indate.mounth - rmin;
    951           rmin = 0;
    952           if (res < 0 )
    953           {
    954             res = 12 + res;
    955           }
    956           res = resul + res*2678400; mnogovato trowki
    957             */
    958           return(resul);
   \   00000088   502BA0E3           MOV      R2,#+81920
   \   0000008C   462D82E3           ORR      R2,R2,#0x1180
   \   00000090   920120E0           MLA      R0,R2,R1,R0
   \   00000094   20D08DE2           ADD      SP,SP,#+32
   \   00000098   1080BDE8           POP      {R4,PC}          ;; return
    959          }
    960          

   \                                 In segment CODE, align 4, keep-with-next
    961          char *utf82filename(char *str)
    962          {
   \                     utf82filename:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    963            int len = strlen(str)+16;
   \   00000008   1B0000EF           SWI      +27
   \   0000000C   105080E2           ADD      R5,R0,#+16
    964            WSHDR *ws = AllocWS(len);
   \   00000010   0500A0E1           MOV      R0,R5
   \   00000014   250100EF           SWI      +293
   \   00000018   0060A0E1           MOV      R6,R0
    965            char *res = malloc(len);
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   140000EF           SWI      +20
   \   00000024   0070A0E1           MOV      R7,R0
    966            utf8_2ws(ws, str, len);
   \   00000028   0520A0E1           MOV      R2,R5
   \   0000002C   0410A0E1           MOV      R1,R4
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   E30100EF           SWI      +483
    967            ws_2str(ws, res, len);
   \   00000038   0520A0E1           MOV      R2,R5
   \   0000003C   0710A0E1           MOV      R1,R7
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   A30000EF           SWI      +163
    968            FreeWS(ws);
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   290100EF           SWI      +297
    969            return res;
   \   00000050   0700A0E1           MOV      R0,R7
   \   00000054   F080BDE8           POP      {R4-R7,PC}       ;; return
    970          }
    971          

   \                                 In segment CODE, align 4, keep-with-next
    972          void CutWSStringWidth(WSHDR *ws, int width, int font)
    973          {
   \                     CutWSStringWidth:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    974            unsigned short *wsbody=ws->wsbody;
   \   00000008   007094E5           LDR      R7,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    975            int wi = 0;
   \   00000014   0080A0E3           MOV      R8,#+0
    976            int index=0;
   \   00000018   0090A0E3           MOV      R9,#+0
   \   0000001C   050000EA           B        ??CutWSStringWidth_0
    977            while((wi<width)&&(index<=wsbody[0]))
    978            {
    979              index++;
   \                     ??CutWSStringWidth_1:
   \   00000020   019089E2           ADD      R9,R9,#+1
    980              wi += GetSymbolWidth(wsbody[index],font);
   \   00000024   890087E0           ADD      R0,R7,R9, LSL #+1
   \   00000028   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000002C   0610A0E1           MOV      R1,R6
   \   00000030   E10100EF           SWI      +481
   \   00000034   088080E0           ADD      R8,R0,R8
    981            }
   \                     ??CutWSStringWidth_0:
   \   00000038   050058E1           CMP      R8,R5
   \   0000003C   020000AA           BGE      ??CutWSStringWidth_2
   \   00000040   B000D7E1           LDRH     R0,[R7, #+0]
   \   00000044   090050E1           CMP      R0,R9
   \   00000048   F4FFFFAA           BGE      ??CutWSStringWidth_1
    982            CutWSTR(ws, index-1);
   \                     ??CutWSStringWidth_2:
   \   0000004C   011049E2           SUB      R1,R9,#+1
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   260100EF           SWI      +294
    983          }
   \   00000058   F083BDE8           POP      {R4-R9,PC}       ;; return
    984          

   \                                 In segment DATA_C, align 4, align-sorted
    985          const char badchars[] = {'?', '*', '"', ':', '<', '>', '/', '\\', '|', '\n', '\r', ','};
   \                     badchars:
   \   00000000   3F2A223A3C3E       DC8 63, 42, 34, 58, 60, 62, 47, 92, 124, 10, 13, 44
   \              2F5C7C0A0D2C
    986          

   \                                 In segment CODE, align 4, keep-with-next
    987          void remove_bad_chars(char *s)
    988          {
   \                     remove_bad_chars:
   \   00000000   090000EA           B        ??remove_bad_chars_0
    989            int c;
    990            while((c=*s))
    991            {
    992              for (int i=0; i<(sizeof(badchars)/sizeof(char)); i++)
   \                     ??remove_bad_chars_1:
   \   00000004   011081E2           ADD      R1,R1,#+1
   \                     ??remove_bad_chars_2:
   \   00000008   0C0051E3           CMP      R1,#+12
   \   0000000C   0500002A           BCS      ??remove_bad_chars_3
    993              {
    994                if (c==badchars[i])
   \   00000010   28309FE5           LDR      R3,??remove_bad_chars_4  ;; badchars
   \   00000014   0330D1E7           LDRB     R3,[R1, +R3]
   \   00000018   030052E1           CMP      R2,R3
   \   0000001C   F8FFFF1A           BNE      ??remove_bad_chars_1
    995                {
    996                  *s='_';
   \   00000020   5F10A0E3           MOV      R1,#+95
   \   00000024   0010C0E5           STRB     R1,[R0, #+0]
    997                  break;
    998                }    
    999              }
   1000              s++;
   \                     ??remove_bad_chars_3:
   \   00000028   010080E2           ADD      R0,R0,#+1
   \                     ??remove_bad_chars_0:
   \   0000002C   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000030   000052E3           CMP      R2,#+0
   \   00000034   0010A013           MOVNE    R1,#+0
   \   00000038   F2FFFF1A           BNE      ??remove_bad_chars_2
   1001            }
   1002          }
   \   0000003C   1EFF2FE1           BX       LR               ;; return
   \                     ??remove_bad_chars_4:
   \   00000040   ........           DC32     badchars
   1003          //EOL,EOF
   1004          
   1005          //************************ added by alfinant ***********************************
   1006          //вычисляет размер памяти занимаемый символом utf8 
   1007          static int UTF8_GetSize(char *uchar)
   1008          {
   1009            int n=0;
   1010            
   1011            if (*uchar < 0x80) n=1;
   1012            else
   1013              if ((*uchar & 0xF8) == 0xF0) n=4;
   1014              else
   1015                if ((*uchar & 0xF0) == 0xE0) n=3;
   1016                else
   1017                  if ((*uchar & 0xE0) == 0xC0) n=2;
   1018                //else
   1019                //if (*uchar == 0) n=0;
   1020                return n;  
   1021          }
   1022          
   1023          static int DecodeUTF8(const char *bytes, unsigned *ch)
   1024          {
   1025            int n;
   1026            
   1027            if(*bytes < 0x80)
   1028            {
   1029              *ch = *bytes;
   1030              return(1);
   1031            }
   1032            
   1033            if ((*bytes & 0xF8) == 0xF0) n=4;
   1034            else
   1035              if ((*bytes & 0xF0) == 0xE0) n=3;
   1036            else
   1037              if ((*bytes & 0xE0) == 0xC0) n=2;
   1038            else
   1039              return(0);
   1040            
   1041            *ch= *bytes & ((0x07 << (4 - n)) | 0x03);
   1042            
   1043            for (int i=1; i < n; ++i)
   1044            {
   1045             *ch <<=6;
   1046             *ch |= (*++bytes & 0x3F);
   1047            }
   1048            return n;
   1049          }
   1050          

   \                                 In segment CODE, align 4, keep-with-next
   1051          static int EncodeUTF8(unsigned ch, int len, char *bytes)
   1052          {
   \                     EncodeUTF8:
   \   00000000   10002DE9           PUSH     {R4}
   1053            if (ch <= 0x7F)
   \   00000004   800050E3           CMP      R0,#+128
   \   00000008   0500002A           BCS      ??EncodeUTF8_0
   1054            {
   1055              if (len >=1)
   \   0000000C   010051E3           CMP      R1,#+1
   \   00000010   300000BA           BLT      ??EncodeUTF8_1
   1056              {
   1057                *bytes = ch;
   \   00000014   0000C2E5           STRB     R0,[R2, #+0]
   1058                return(1);
   \   00000018   1000BDE8           POP      {R4}
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   1EFF2FE1           BX       LR
   1059              } 
   1060            }
   1061            else
   1062              if (ch <= 0x7FF)
   \                     ??EncodeUTF8_0:
   \   00000024   3F3000E2           AND      R3,R0,#0x3F
   \   00000028   803083E3           ORR      R3,R3,#0x80
   \   0000002C   20C3A0E1           LSR      R12,R0,#+6
   \   00000030   800E50E3           CMP      R0,#+2048
   \   00000034   0800002A           BCS      ??EncodeUTF8_2
   1063              {
   1064                if (len >=2)
   \   00000038   020051E3           CMP      R1,#+2
   \   0000003C   250000BA           BLT      ??EncodeUTF8_1
   1065                {
   1066                  *bytes++ = (0xC0 | (0x1F & (ch >> 6)));
   \   00000040   1F000CE2           AND      R0,R12,#0x1F
   \   00000044   C00080E3           ORR      R0,R0,#0xC0
   \   00000048   ........           STRB     R0,[R2], #+1
   1067                  *bytes = 0x80 |(0x3F & ch);
   \   0000004C   0030C2E5           STRB     R3,[R2, #+0]
   1068                  return(2);
   \   00000050   1000BDE8           POP      {R4}
   \   00000054   0200A0E3           MOV      R0,#+2
   \   00000058   1EFF2FE1           BX       LR
   1069                }
   1070              }
   1071            else
   1072              if (ch <= 0xFFFF)
   \                     ??EncodeUTF8_2:
   \   0000005C   3F400CE2           AND      R4,R12,#0x3F
   \   00000060   80C084E3           ORR      R12,R4,#0x80
   \   00000064   2046A0E1           LSR      R4,R0,#+12
   \   00000068   400B50E3           CMP      R0,#+65536
   \   0000006C   0900002A           BCS      ??EncodeUTF8_3
   1073              {
   1074                if (len >=3)
   \   00000070   030051E3           CMP      R1,#+3
   \   00000074   170000BA           BLT      ??EncodeUTF8_1
   1075                {
   1076                  *bytes++ = 0xE0 | (0x0F & (ch >> 12));
   \   00000078   0F0004E2           AND      R0,R4,#0xF
   \   0000007C   E00080E3           ORR      R0,R0,#0xE0
   \   00000080   ........           STRB     R0,[R2], #+1
   1077                  *bytes++ = 0x80 | (0x3F & (ch >> 6));
   \   00000084   ........           STRB     R12,[R2], #+1
   1078                  *bytes = 0x80 | (0x3F & ch);
   \   00000088   0030C2E5           STRB     R3,[R2, #+0]
   1079                  return(3);
   \   0000008C   1000BDE8           POP      {R4}
   \   00000090   0300A0E3           MOV      R0,#+3
   \   00000094   1EFF2FE1           BX       LR
   1080                }
   1081              }
   1082            else
   1083              if (ch <= 0x10FFFF)
   \                     ??EncodeUTF8_3:
   \   00000098   440950E3           CMP      R0,#+1114112
   \   0000009C   0D00002A           BCS      ??EncodeUTF8_1
   1084              {
   1085                if (len >=4)
   \   000000A0   040051E3           CMP      R1,#+4
   \   000000A4   0B0000BA           BLT      ??EncodeUTF8_1
   1086                {
   1087                  *bytes++ = 0xF0 | (0x07 & (ch >> 18));
   \   000000A8   2009A0E1           LSR      R0,R0,#+18
   \   000000AC   070000E2           AND      R0,R0,#0x7
   \   000000B0   F00080E3           ORR      R0,R0,#0xF0
   \   000000B4   ........           STRB     R0,[R2], #+1
   1088                  *bytes++ = 0x80 | (0x3F & (ch >> 12));
   \   000000B8   3F0004E2           AND      R0,R4,#0x3F
   \   000000BC   800080E3           ORR      R0,R0,#0x80
   \   000000C0   ........           STRB     R0,[R2], #+1
   1089                  *bytes++ = 0x80 | (0x3F & (ch >> 6));
   \   000000C4   ........           STRB     R12,[R2], #+1
   1090                  *bytes = 0x80 | (0x3F & ch);
   \   000000C8   0030C2E5           STRB     R3,[R2, #+0]
   1091                  return(4);
   \   000000CC   1000BDE8           POP      {R4}
   \   000000D0   0400A0E3           MOV      R0,#+4
   \   000000D4   1EFF2FE1           BX       LR
   1092                }
   1093              }
   1094            return(0);
   \                     ??EncodeUTF8_1:
   \   000000D8   1000BDE8           POP      {R4}
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   1EFF2FE1           BX       LR               ;; return
   1095          }
   1096          
   1097          //получить кол-во символов в utf8 строке

   \                                 In segment CODE, align 4, keep-with-next
   1098          int utf8_syms_n(char* utf8_str, int len)
   1099          {
   \                     utf8_syms_n:
   \   00000000   10002DE9           PUSH     {R4}
   1100            int n=0;
   \   00000004   0020A0E3           MOV      R2,#+0
   1101            char* s = utf8_str;  
   \   00000008   001081E0           ADD      R1,R1,R0
   \   0000000C   010050E1           CMP      R0,R1
   \   00000010   1300002A           BCS      ??utf8_syms_n_0
   1102            
   1103            while (s < (utf8_str + len))
   1104            {
   1105             s+=UTF8_GetSize(s);
   \                     ??utf8_syms_n_1:
   \   00000014   00C0D0E5           LDRB     R12,[R0, #+0]
   \   00000018   0030A0E3           MOV      R3,#+0
   \   0000001C   80005CE3           CMP      R12,#+128
   \   00000020   0130A033           MOVCC    R3,#+1
   \   00000024   0A00003A           BCC      ??utf8_syms_n_2
   \   00000028   F8400CE2           AND      R4,R12,#0xF8
   \   0000002C   F00054E3           CMP      R4,#+240
   \   00000030   0430A003           MOVEQ    R3,#+4
   \   00000034   0600000A           BEQ      ??utf8_syms_n_2
   \   00000038   F0400CE2           AND      R4,R12,#0xF0
   \   0000003C   E00054E3           CMP      R4,#+224
   \   00000040   0330A003           MOVEQ    R3,#+3
   \   00000044   0200000A           BEQ      ??utf8_syms_n_2
   \   00000048   E0400CE2           AND      R4,R12,#0xE0
   \   0000004C   C00054E3           CMP      R4,#+192
   \   00000050   0230A003           MOVEQ    R3,#+2
   \                     ??utf8_syms_n_2:
   \   00000054   000083E0           ADD      R0,R3,R0
   1106             n++;
   \   00000058   012082E2           ADD      R2,R2,#+1
   1107            }
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   EBFFFF3A           BCC      ??utf8_syms_n_1
   1108            return n;
   \                     ??utf8_syms_n_0:
   \   00000064   1000BDE8           POP      {R4}
   \   00000068   0200A0E1           MOV      R0,R2
   \   0000006C   1EFF2FE1           BX       LR               ;; return
   1109          }
   1110          

   \                                 In segment CODE, align 4, keep-with-next
   1111          int Replace_Smiles_Syms(char* utf8_str)
   1112          {//адаптирует utf-8 стороку под WSHDR, если там есть смайлы и символы выше 0xFFFF 
   \                     Replace_Smiles_Syms:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1113            unsigned ch;
   1114            unsigned short wchar;
   1115            int n=0;
   \   00000008   0080A0E3           MOV      R8,#+0
   1116            char* b = utf8_str;
   \   0000000C   0450A0E1           MOV      R5,R4
   1117            char* u = utf8_str;
   \   00000010   0460A0E1           MOV      R6,R4
   1118            
   1119            int len = strlen(utf8_str);
   \   00000014   1B0000EF           SWI      +27
   \   00000018   0070A0E1           MOV      R7,R0
   \   0000001C   020000EA           B        ??Replace_Smiles_Syms_0
   1120            
   1121            while (b < (utf8_str + len))
   1122            {
   1123              wchar=0xFFFF;
   1124              ch=0;
   1125              
   1126              switch(UTF8_GetSize(b))
   1127              {
   1128              case 0:
   1129                return(0);
   1130              
   1131              case 1:
   1132                *u++ = *b++;
   \                     ??Replace_Smiles_Syms_1:
   \   00000020   ........           LDRB     R0,[R5], #+1
   1133                n++;
   \   00000024   018088E2           ADD      R8,R8,#+1
   \                     ??Replace_Smiles_Syms_2:
   \   00000028   ........           STRB     R0,[R6], #+1
   \                     ??Replace_Smiles_Syms_0:
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   040087E0           ADD      R0,R7,R4
   \   00000034   000055E1           CMP      R5,R0
   \   00000038   A100002A           BCS      ??Replace_Smiles_Syms_3
   \   0000003C   0030D5E5           LDRB     R3,[R5, #+0]
   \   00000040   FF00A0E3           MOV      R0,#+255
   \   00000044   FF0C80E3           ORR      R0,R0,#0xFF00
   \   00000048   800053E3           CMP      R3,#+128
   \   0000004C   F3FFFF3A           BCC      ??Replace_Smiles_Syms_1
   \   00000050   0720A0E3           MOV      R2,#+7
   \   00000054   F8C003E2           AND      R12,R3,#0xF8
   \   00000058   F0005CE3           CMP      R12,#+240
   \   0000005C   0600001A           BNE      ??Replace_Smiles_Syms_4
   1134              break;
   1135              
   1136              case 2:
   1137                *u++ = *b++;
   1138                *u++ = *b++;
   1139                n+=2;
   1140                break; 
   1141              
   1142              case 3:
   1143                DecodeUTF8(b, &ch);
   1144          
   1145                if (ch >= 0x2600 && ch <= 0x27BF)
   1146                {
   1147                  if (ch==0x2639) wchar=0xE200+113;
   1148                  if (ch==0x263A) wchar=0xE200+114;
   1149                  if (ch==0x270C) wchar=0xE200+115;
   1150                  if (ch==0x2764) wchar=0xE200+116;
   1151                  
   1152                  int i= EncodeUTF8(wchar, 4, u);
   1153                  n+=i;
   1154                  u+=i;
   1155                  b+=3;
   1156                }
   1157                else
   1158                  if (ch >= 0xFE00 && ch <= 0xFE0F)//селекторы вариантов начертания-игнор
   1159                    b+=3;
   1160                  else
   1161                  {
   1162                    *u++ = *b++;
   1163                    *u++ = *b++;
   1164                    *u++ = *b++;
   1165                    n+=3;
   1166                  }
   1167                  break;
   1168              
   1169              case 4:
   1170                b += DecodeUTF8(b, &ch);
   \   00000060   0530A0E1           MOV      R3,R5
   \   00000064   00C0D3E5           LDRB     R12,[R3, #+0]
   \   00000068   80005CE3           CMP      R12,#+128
   \   0000006C   5700002A           BCS      ??Replace_Smiles_Syms_5
   \   00000070   0C10A0E1           MOV      R1,R12
   \   00000074   01E0A0E3           MOV      LR,#+1
   \   00000078   6F0000EA           B        ??Replace_Smiles_Syms_6
   \                     ??Replace_Smiles_Syms_4:
   \   0000007C   F01003E2           AND      R1,R3,#0xF0
   \   00000080   E00051E3           CMP      R1,#+224
   \   00000084   0400001A           BNE      ??Replace_Smiles_Syms_7
   \   00000088   0530A0E1           MOV      R3,R5
   \   0000008C   0010D3E5           LDRB     R1,[R3, #+0]
   \   00000090   800051E3           CMP      R1,#+128
   \   00000094   0A00002A           BCS      ??Replace_Smiles_Syms_8
   \   00000098   220000EA           B        ??Replace_Smiles_Syms_9
   \                     ??Replace_Smiles_Syms_7:
   \   0000009C   E00003E2           AND      R0,R3,#0xE0
   \   000000A0   C00050E3           CMP      R0,#+192
   \   000000A4   0400001A           BNE      ??Replace_Smiles_Syms_10
   \   000000A8   ........           LDRB     R0,[R5], #+1
   \   000000AC   028088E2           ADD      R8,R8,#+2
   \   000000B0   ........           STRB     R0,[R6], #+1
   \   000000B4   ........           LDRB     R0,[R5], #+1
   \   000000B8   DAFFFFEA           B        ??Replace_Smiles_Syms_2
   \                     ??Replace_Smiles_Syms_10:
   \   000000BC   0000A0E3           MOV      R0,#+0
   \   000000C0   F083BDE8           POP      {R4-R9,PC}
   \                     ??Replace_Smiles_Syms_8:
   \   000000C4   F8C001E2           AND      R12,R1,#0xF8
   \   000000C8   F0005CE3           CMP      R12,#+240
   \   000000CC   04C0A003           MOVEQ    R12,#+4
   \   000000D0   0700000A           BEQ      ??Replace_Smiles_Syms_11
   \   000000D4   F0C001E2           AND      R12,R1,#0xF0
   \   000000D8   E0005CE3           CMP      R12,#+224
   \   000000DC   03C0A003           MOVEQ    R12,#+3
   \   000000E0   0300000A           BEQ      ??Replace_Smiles_Syms_11
   \   000000E4   E0C001E2           AND      R12,R1,#0xE0
   \   000000E8   C0005CE3           CMP      R12,#+192
   \   000000EC   3000001A           BNE      ??Replace_Smiles_Syms_12
   \   000000F0   02C0A0E3           MOV      R12,#+2
   \                     ??Replace_Smiles_Syms_11:
   \   000000F4   0CE0A0E1           MOV      LR,R12
   \   000000F8   04E06EE2           RSB      LR,LR,#+4
   \   000000FC   0390A0E3           MOV      R9,#+3
   \   00000100   122E89E1           ORR      R2,R9,R2, LSL LR
   \   00000104   011002E0           AND      R1,R2,R1
   \   00000108   0120A0E3           MOV      R2,#+1
   \   0000010C   030000EA           B        ??Replace_Smiles_Syms_13
   \                     ??Replace_Smiles_Syms_14:
   \   00000110   0190F3E5           LDRB     R9,[R3, #+1]!
   \   00000114   012082E2           ADD      R2,R2,#+1
   \   00000118   3F9009E2           AND      R9,R9,#0x3F
   \   0000011C   011389E1           ORR      R1,R9,R1, LSL #+6
   \                     ??Replace_Smiles_Syms_13:
   \   00000120   0C0052E1           CMP      R2,R12
   \   00000124   F9FFFFBA           BLT      ??Replace_Smiles_Syms_14
   \                     ??Replace_Smiles_Syms_9:
   \   00000128   980D51E3           CMP      R1,#+9728
   \   0000012C   1A00003A           BCC      ??Replace_Smiles_Syms_15
   \   00000130   9F0D51E3           CMP      R1,#+10176
   \   00000134   1800002A           BCS      ??Replace_Smiles_Syms_15
   \   00000138   3920A0E3           MOV      R2,#+57
   \   0000013C   982D82E3           ORR      R2,R2,#0x2600
   \   00000140   020051E1           CMP      R1,R2
   \   00000144   7100A003           MOVEQ    R0,#+113
   \   00000148   0B00000A           BEQ      ??Replace_Smiles_Syms_16
   \   0000014C   012082E2           ADD      R2,R2,#+1
   \   00000150   020051E1           CMP      R1,R2
   \   00000154   7200A003           MOVEQ    R0,#+114
   \   00000158   0700000A           BEQ      ??Replace_Smiles_Syms_16
   \   0000015C   D22082E2           ADD      R2,R2,#+210
   \   00000160   020051E1           CMP      R1,R2
   \   00000164   7300A003           MOVEQ    R0,#+115
   \   00000168   0300000A           BEQ      ??Replace_Smiles_Syms_16
   \   0000016C   582082E2           ADD      R2,R2,#+88
   \   00000170   020051E1           CMP      R1,R2
   \   00000174   0100001A           BNE      ??Replace_Smiles_Syms_17
   \   00000178   7400A0E3           MOV      R0,#+116
   \                     ??Replace_Smiles_Syms_16:
   \   0000017C   E20C80E3           ORR      R0,R0,#0xE200
   \                     ??Replace_Smiles_Syms_17:
   \   00000180   0620A0E1           MOV      R2,R6
   \   00000184   0410A0E3           MOV      R1,#+4
   \   00000188   ........           BL       EncodeUTF8
   \   0000018C   088080E0           ADD      R8,R0,R8
   \   00000190   066080E0           ADD      R6,R0,R6
   \                     ??Replace_Smiles_Syms_18:
   \   00000194   035085E2           ADD      R5,R5,#+3
   \   00000198   A3FFFFEA           B        ??Replace_Smiles_Syms_0
   \                     ??Replace_Smiles_Syms_15:
   \   0000019C   FE0C51E3           CMP      R1,#+65024
   \   000001A0   0300003A           BCC      ??Replace_Smiles_Syms_12
   \   000001A4   1000A0E3           MOV      R0,#+16
   \   000001A8   FE0C80E3           ORR      R0,R0,#0xFE00
   \   000001AC   000051E1           CMP      R1,R0
   \   000001B0   F7FFFF3A           BCC      ??Replace_Smiles_Syms_18
   \                     ??Replace_Smiles_Syms_12:
   \   000001B4   ........           LDRB     R0,[R5], #+1
   \   000001B8   038088E2           ADD      R8,R8,#+3
   \   000001BC   ........           STRB     R0,[R6], #+1
   \   000001C0   ........           LDRB     R0,[R5], #+1
   \   000001C4   ........           STRB     R0,[R6], #+1
   \   000001C8   ........           LDRB     R0,[R5], #+1
   \   000001CC   95FFFFEA           B        ??Replace_Smiles_Syms_2
   \                     ??Replace_Smiles_Syms_5:
   \   000001D0   F8900CE2           AND      R9,R12,#0xF8
   \   000001D4   F00059E3           CMP      R9,#+240
   \   000001D8   0700001A           BNE      ??Replace_Smiles_Syms_19
   \   000001DC   04E0A0E3           MOV      LR,#+4
   \                     ??Replace_Smiles_Syms_20:
   \   000001E0   0E10A0E1           MOV      R1,LR
   \   000001E4   041061E2           RSB      R1,R1,#+4
   \   000001E8   0390A0E3           MOV      R9,#+3
   \   000001EC   121189E1           ORR      R1,R9,R2, LSL R1
   \   000001F0   0C1001E0           AND      R1,R1,R12
   \   000001F4   0120A0E3           MOV      R2,#+1
   \   000001F8   0D0000EA           B        ??Replace_Smiles_Syms_21
   \                     ??Replace_Smiles_Syms_19:
   \   000001FC   F0900CE2           AND      R9,R12,#0xF0
   \   00000200   E00059E3           CMP      R9,#+224
   \   00000204   03E0A003           MOVEQ    LR,#+3
   \   00000208   F4FFFF0A           BEQ      ??Replace_Smiles_Syms_20
   \   0000020C   E0900CE2           AND      R9,R12,#0xE0
   \   00000210   C00059E3           CMP      R9,#+192
   \   00000214   02E0A003           MOVEQ    LR,#+2
   \   00000218   F0FFFF0A           BEQ      ??Replace_Smiles_Syms_20
   \   0000021C   00E0A0E3           MOV      LR,#+0
   \   00000220   050000EA           B        ??Replace_Smiles_Syms_6
   \                     ??Replace_Smiles_Syms_22:
   \   00000224   0190F3E5           LDRB     R9,[R3, #+1]!
   \   00000228   012082E2           ADD      R2,R2,#+1
   \   0000022C   3F9009E2           AND      R9,R9,#0x3F
   \   00000230   011389E1           ORR      R1,R9,R1, LSL #+6
   \                     ??Replace_Smiles_Syms_21:
   \   00000234   0E0052E1           CMP      R2,LR
   \   00000238   F9FFFFBA           BLT      ??Replace_Smiles_Syms_22
   \                     ??Replace_Smiles_Syms_6:
   \   0000023C   05508EE0           ADD      R5,LR,R5
   1171                if (ch >= 0x1F600 && ch < 0x1F650)//emoji
   \   00000240   402BA0E3           MOV      R2,#+65536
   \   00000244   F62C82E3           ORR      R2,R2,#0xF600
   \   00000248   020051E1           CMP      R1,R2
   \   0000024C   0600003A           BCC      ??Replace_Smiles_Syms_23
   \   00000250   502082E3           ORR      R2,R2,#0x50
   \   00000254   020051E1           CMP      R1,R2
   \   00000258   1100002A           BCS      ??Replace_Smiles_Syms_24
   1172                  wchar=0xE200 + (ch - 0x1F600) + 3;
   \   0000025C   0300A0E3           MOV      R0,#+3
   \   00000260   EC0C80E3           ORR      R0,R0,#0xEC00
   \                     ??Replace_Smiles_Syms_25:
   \   00000264   010080E0           ADD      R0,R0,R1
   \   00000268   0D0000EA           B        ??Replace_Smiles_Syms_24
   1173                else
   1174                  if (ch >= 0x1F440 && ch <= 0x1F450)
   \                     ??Replace_Smiles_Syms_23:
   \   0000026C   702F42E2           SUB      R2,R2,#+448
   \   00000270   020051E1           CMP      R1,R2
   \   00000274   0500003A           BCC      ??Replace_Smiles_Syms_26
   \   00000278   112082E3           ORR      R2,R2,#0x11
   \   0000027C   020051E1           CMP      R1,R2
   \   00000280   0700002A           BCS      ??Replace_Smiles_Syms_24
   1175                    wchar=0xE200 + ch - 0x1F440 + 96;      
   \   00000284   2000A0E3           MOV      R0,#+32
   \   00000288   EE0C80E3           ORR      R0,R0,#0xEE00
   \   0000028C   F4FFFFEA           B        ??Replace_Smiles_Syms_25
   1176                  else
   1177                    if (ch >= 0x1F3FB && ch <= 0x1F3FF)//модификаторы эмоджи-игнор
   \                     ??Replace_Smiles_Syms_26:
   \   00000290   452042E2           SUB      R2,R2,#+69
   \   00000294   020051E1           CMP      R1,R2
   \   00000298   0100003A           BCC      ??Replace_Smiles_Syms_24
   \   0000029C   7D0B51E3           CMP      R1,#+128000
   \   000002A0   61FFFF3A           BCC      ??Replace_Smiles_Syms_0
   1178                      break;
   1179                  int i= EncodeUTF8(wchar, 4, u);
   \                     ??Replace_Smiles_Syms_24:
   \   000002A4   0620A0E1           MOV      R2,R6
   \   000002A8   0410A0E3           MOV      R1,#+4
   \   000002AC   0008A0E1           MOV      R0,R0, LSL #+16
   \   000002B0   2008A0E1           MOV      R0,R0, LSR #+16
   \   000002B4   ........           BL       EncodeUTF8
   1180                  n+=i;
   \   000002B8   088080E0           ADD      R8,R0,R8
   1181                  u+=i;
   \   000002BC   066080E0           ADD      R6,R0,R6
   \   000002C0   59FFFFEA           B        ??Replace_Smiles_Syms_0
   1182                  break;
   1183              }
   1184            }
   1185            
   1186            *u='\0';
   \                     ??Replace_Smiles_Syms_3:
   \   000002C4   0010C6E5           STRB     R1,[R6, #+0]
   1187            return n;
   \   000002C8   0800A0E1           MOV      R0,R8
   \   000002CC   F083BDE8           POP      {R4-R9,PC}       ;; return
   1188          }
   1189          

   \                                 In segment CODE, align 4, keep-with-next
   1190          WSHDR * CreateWS_emoji(char *utf8_str)//создает WSHDR строку с поддержкой смайлов(некоторых).Не работает без dyn_images.c
   1191          {
   \                     CreateWS_emoji:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   1192            if (utf8_str == 0 || *utf8_str == 0)//Если указатель нулевой или строка пуста
   \   00000008   0000D415           LDRBNE   R0,[R4, #+0]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   0200001A           BNE      ??CreateWS_emoji_0
   1193              return AllocWS(4);
   \   00000014   0400A0E3           MOV      R0,#+4
   \   00000018   250100EF           SWI      +293
   \   0000001C   7080BDE8           POP      {R4-R6,PC}
   1194          
   1195            int len = strlen(utf8_str);
   \                     ??CreateWS_emoji_0:
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   1B0000EF           SWI      +27
   1196            char* __utf8_str = malloc(len + 1);
   \   00000028   010080E2           ADD      R0,R0,#+1
   \   0000002C   140000EF           SWI      +20
   \   00000030   0050A0E1           MOV      R5,R0
   1197            strcpy(__utf8_str, utf8_str);
   \   00000034   0410A0E1           MOV      R1,R4
   \   00000038   1A0000EF           SWI      +26
   1198            len = Replace_Smiles_Syms(__utf8_str);
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   ........           BL       Replace_Smiles_Syms
   \   00000044   0040A0E1           MOV      R4,R0
   1199            WSHDR *ws = AllocWS(utf8_syms_n(__utf8_str, len));
   \   00000048   0410A0E1           MOV      R1,R4
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   ........           BL       utf8_syms_n
   \   00000054   250100EF           SWI      +293
   \   00000058   0060A0E1           MOV      R6,R0
   1200            utf8_2ws(ws, __utf8_str, len);
   \   0000005C   0420A0E1           MOV      R2,R4
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   E30100EF           SWI      +483
   1201            mfree(__utf8_str);
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   150000EF           SWI      +21
   1202            
   1203            return ws;
   \   00000070   0600A0E1           MOV      R0,R6
   \   00000074   7080BDE8           POP      {R4-R6,PC}       ;; return
   1204          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     Repl_chars

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     `?<Constant "Bad UTF-8 Encoding en...">`

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     `?<Constant "Bad UTF-8 Encoding en...">` + 44

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     `?<Constant "Bad UTF-8 Encoding en...">` + 88

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for Repl_chars>`:
   \   00000000   2661706F733B       DC8 "&apos;"
   \              00          
   \   00000007   27                 DC8 39
   \   00000008   262333393B00       DC8 26H, 23H, 33H, 39H, 3BH, 0, 0
   \              00          
   \   0000000F   27                 DC8 39
   \   00000010   2671756F743B       DC8 "&quot;"
   \              00          
   \   00000017   22                 DC8 34
   \   00000018   266C743B0000       DC8 26H, 6CH, 74H, 3BH, 0, 0, 0
   \              00          
   \   0000001F   3C                 DC8 60
   \   00000020   2667743B0000       DC8 26H, 67H, 74H, 3BH, 0, 0, 0
   \              00          
   \   00000027   3E                 DC8 62
   \   00000028   26616D703B00       DC8 26H, 61H, 6DH, 70H, 3BH, 0, 0
   \              00          
   \   0000002F   26                 DC8 38

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Bad UTF-8 Encoding en...">`:
   \   00000000   426164205554       DC8 "Bad UTF-8 Encoding encountered (chr<0xC0)"
   \              462D3820456E
   \              636F64696E67
   \              20656E636F75
   \              6E7465726564
   \              20286368723C
   \              307843302900
   \   0000002A   0000               DC8 0, 0
   \   0000002C   426164205554       DC8 "Bad UTF-8 Encoding encountered (chr2<0x80)"
   \              462D3820456E
   \              636F64696E67
   \              20656E636F75
   \              6E7465726564
   \              202863687232
   \              3C3078383029
   \              00          
   \   00000057   00                 DC8 0
   \   00000058   426164205554       DC8 "Bad UTF-8 Encoding encountered"
   \              462D3820456E
   \              636F64696E67
   \              20656E636F75
   \              6E7465726564
   \              00          
   \   00000077   00                 DC8 0

   Maximum stack usage in bytes:

     Function             CSTACK
     --------             ------
     ANSI2UTF8               20
     Correct_UTF8_String      8
     CreateWS_emoji          16
     CutWSStringWidth        28
     EncodeUTF8               4
     GetIDLETime             40
     GetSpecialSym           36
     GetSpecialSymMaskN       0
     Get_Param_Value         20
     Mask_Special_Syms       36
     Replace_Smiles_Syms     28
     Replace_Special_Syms    24
     ascii2ws                12
     char16to8                0
     char8to16                0
     convUTF8_to_ANSI        20
     convUTF8_to_ANSI_STR    24
     remove_bad_chars         0
     str2lower                8
     str2lower_ANSI           8
     stricmp                 16
     stristr                 20
     strnicmp                24
     tolower                  0
     utf16_to_utf8           32
     utf82filename           20
     utf82win                 0
     utf8_2unicode            8
     utf8_syms_n              4
     utf8_to_utf16           16


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     Repl_chars_count                  4
     Repl_chars                       48
     utf8_2unicode                   176
     GetSpecialSym                   148
     GetSpecialSymMaskN               48
     Replace_Special_Syms            128
     Mask_Special_Syms               188
     Get_Param_Value                 212
     convUTF8_to_ANSI                228
     str2lower                       108
     tolower                          56
     stricmp                          56
     strnicmp                        104
     stristr                         104
     str2lower_ANSI                   96
     convUTF8_to_ANSI_STR            416
     utf8_to_utf16                   284
     utf16_to_utf8                   384
     Correct_UTF8_String              84
     ANSI2UTF8                       124
     unicode2char                    600
     win2unicode                     256
     char8to16                        32
     char16to8                        68
     ascii2ws                         56
     utf82win                        240
     GetIDLETime                     156
     utf82filename                    88
     CutWSStringWidth                 92
     badchars                         12
     remove_bad_chars                 68
     EncodeUTF8                      228
     utf8_syms_n                     112
     Replace_Smiles_Syms             720
     CreateWS_emoji                  120
     ??DataTable2                      4
     ??DataTable6                      4
     ??DataTable7                      4
     ??DataTable8                      4
     ?<Initializer for Repl_chars>    48
     ?<Constant "Bad UTF-8 Encoding en...">
                                     120
      Others                         140

 
 5 068 bytes in segment CODE
   992 bytes in segment DATA_C
    48 bytes in segment DATA_I
    48 bytes in segment DATA_ID
    12 bytes in segment INITTAB
 
 4 884 bytes of CODE  memory (+ 196 bytes shared)
 1 040 bytes of CONST memory
    48 bytes of DATA  memory

Errors: none
Warnings: none
