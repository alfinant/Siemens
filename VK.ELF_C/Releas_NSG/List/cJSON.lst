##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    15/Mar/2023  22:35:39 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \json\cJSON.c                                        #
#    Command line    =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \json\cJSON.c -D NEWSGOLD -D DEBUG -lCN              #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\ -la D:\Users\alfinant\Documents\Si #
#                       emens\Dev\IAR\VK.ELF_C\Releas_NSG\List\ -o           #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\ -s9 --cpu_mode arm --endian little  #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork         #
#                       --diag_suppress Pe301 -e --fpu None --dlib_config    #
#                       D:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I D:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\cJSON.lst                           #
#    Object file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\cJSON.r79                            #
#                                                                            #
#                                                                            #
##############################################################################

D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C\json\cJSON.c
      1          /*
      2            Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
      3          
      4            Permission is hereby granted, free of charge, to any person obtaining a copy
      5            of this software and associated documentation files (the "Software"), to deal
      6            in the Software without restriction, including without limitation the rights
      7            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      8            copies of the Software, and to permit persons to whom the Software is
      9            furnished to do so, subject to the following conditions:
     10          
     11            The above copyright notice and this permission notice shall be included in
     12            all copies or substantial portions of the Software.
     13          
     14            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     15            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     16            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     17            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     18            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     19            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     20            THE SOFTWARE.
     21          */
     22          
     23          /* cJSON */
     24          /* JSON parser in C. */
     25          
     26          /* disable warnings about old C89 functions in MSVC */
     27          #if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
     28          #define _CRT_SECURE_NO_DEPRECATE
     29          #endif
     30          
     31          #ifdef __GNUC__
     32          #pragma GCC visibility push(default)
     33          #endif
     34          #if defined(_MSC_VER)
     35          #pragma warning (push)
     36          /* disable warning about single line comments in system headers */
     37          #pragma warning (disable : 4001)
     38          #endif
     39          
     40          #include <siemens\swilib.h>
     41          
     42          //#include <string.h>
     43          //#include <stdio.h>
     44          //#include <math.h>
     45          //#include <stdlib.h>
     46          #include <limits.h>
     47          //#include <ctype.h>
     48          
     49          #ifdef ENABLE_LOCALES
     50          #include <locale.h>
     51          #endif
     52          
     53          #if defined(_MSC_VER)
     54          #pragma warning (pop)
     55          #endif
     56          #ifdef __GNUC__
     57          #pragma GCC visibility pop
     58          #endif
     59          
     60          #include "cJSON.h"
     61          
     62          /* define our own boolean type */
     63          #define true ((cJSON_bool)1)
     64          #define false ((cJSON_bool)0)
     65          

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "null">`:
   \   00000000   6E756C6C00         DC8 "null"
   \   00000005   000000             DC8 0, 0, 0
   \   00000008   66616C736500       DC8 "false"
   \   0000000E   0000               DC8 0, 0
   \   00000010   7472756500         DC8 "true"
   \   00000015   000000             DC8 0, 0, 0
   \   00000018   25312E313567       DC8 "%1.15g"
   \              00          
   \   0000001F   00                 DC8 0
   \   00000020   25312E313767       DC8 "%1.17g"
   \              00          
   \   00000027   00                 DC8 0
   \   00000028   256C6700           DC8 "%lg"
     66          static const char percent_1_15g[] = "%1.15g";
     67          static const char percent_1_17g[] = "%1.17g";
     68          static const char percent_lg[] = "%lg";
     69          
     70          typedef struct {
     71              const unsigned char *json;
     72              size_t position;
     73          } error;
     74          static error global_error = { NULL, 0 };
     75          

   \                                 In segment CODE, align 4, keep-with-next
     76          CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
     77          {
     78              return (const char*) (global_error.json + global_error.position);
   \                     cJSON_GetErrorPtr:
   \   00000000   ........           LDR      R0,??DataTable2  ;; global_hooks
   \   00000004   101090E5           LDR      R1,[R0, #+16]
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   000081E0           ADD      R0,R1,R0
   \   00000010   1EFF2FE1           BX       LR               ;; return
     79          }
     80          

   \                                 In segment CODE, align 4, keep-with-next
     81          CJSON_PUBLIC(char *) cJSON_GetStringValue(cJSON *item) {
   \                     cJSON_GetStringValue:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     82              if (!cJSON_IsString(item)) {
   \   00000008   ........           BL       cJSON_IsString
   \   0000000C   000050E3           CMP      R0,#+0
     83                  return NULL;
   \   00000010   1080BD08           POPEQ    {R4,PC}
     84              }
     85          
     86              return item->valuestring;
   \   00000014   100094E5           LDR      R0,[R4, #+16]
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return
     87          }
     88          
     89          /* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
     90          #if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 8)
     91              #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
     92          #endif
     93          

   \                                 In segment CODE, align 4, keep-with-next
     94          CJSON_PUBLIC(const char*) cJSON_Version(void)
     95          {
   \                     cJSON_Version:
   \   00000000   10402DE9           PUSH     {R4,LR}
     96              static char version[15];
     97              sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
   \   00000004   20409FE5           LDR      R4,??cJSON_Version_0  ;; ??version
   \   00000008   20109FE5           LDR      R1,??cJSON_Version_0+0x4  ;; `?<Constant "%i.%i.%i">`
   \   0000000C   0800A0E3           MOV      R0,#+8
   \   00000010   01002DE9           PUSH     {R0}
   \   00000014   0730A0E3           MOV      R3,#+7
   \   00000018   0120A0E3           MOV      R2,#+1
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   160000EF           SWI      +22
     98          
     99              return version;
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   1280BDE8           POP      {R1,R4,PC}       ;; return
   \                     ??cJSON_Version_0:
   \   0000002C   ........           DC32     ??version
   \   00000030   ........           DC32     `?<Constant "%i.%i.%i">`
    100          }

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??version:
   \   00000000                      DS8 16
    101          
    102          /* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
    103          static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
    104          {
    105              if ((string1 == NULL) || (string2 == NULL))
    106              {
    107                  return 1;
    108              }
    109          
    110              if (string1 == string2)
    111              {
    112                  return 0;
    113              }
    114          
    115              for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
    116              {
    117                  if (*string1 == '\0')
    118                  {
    119                      return 0;
    120                  }
    121              }
    122          
    123              return tolower(*string1) - tolower(*string2);
    124          }
    125          
    126          typedef struct internal_hooks
    127          {
    128              void *(CJSON_CDECL *allocate)(size_t size);
    129              void (CJSON_CDECL *deallocate)(void *pointer);
    130              void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
    131          } internal_hooks;
    132          
    133          //#if defined(_MSC_VER)
    134          /* work around MSVC error C2322: '...' address of dillimport '...' is not static */

   \                                 In segment CODE, align 4, keep-with-next
    135          static void * CJSON_CDECL internal_malloc(size_t size)
    136          {
   \                     internal_malloc:
   \   00000000   00402DE9           PUSH     {LR}
    137              return malloc(size);
   \   00000004   140000EF           SWI      +20
   \   00000008   0080BDE8           POP      {PC}             ;; return
    138          }

   \                                 In segment CODE, align 4, keep-with-next
    139          static void CJSON_CDECL internal_free(void *pointer)
    140          {
   \                     internal_free:
   \   00000000   00402DE9           PUSH     {LR}
    141              mfree(pointer);
   \   00000004   150000EF           SWI      +21
    142          }
   \   00000008   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
    143          static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
    144          {
   \                     internal_realloc:
   \   00000000   00402DE9           PUSH     {LR}
    145              return realloc(pointer, size);
   \   00000004   BA0000EF           SWI      +186
   \   00000008   0080BDE8           POP      {PC}             ;; return
    146          }

   \                                 In segment DATA_I, align 4, align-sorted
    147          //#else
    148          //#define internal_malloc malloc
    149          //#define internal_free free
    150          //#define internal_realloc realloc
    151          //#endif
    152          
    153          static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
   \                     global_hooks:
   \   00000000                      DS8 12
   \   0000000C                      REQUIRE `?<Initializer for global_hooks>`
   \   0000000C                      DS8 8
   \   00000014                      REQUIRE `?<Initializer for global_error>`
    154          

   \                                 In segment CODE, align 4, keep-with-next
    155          static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
    156          {
   \                     cJSON_strdup:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    157              size_t length = 0;
    158              unsigned char *copy = NULL;
    159          
    160              if (string == NULL)
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   0600000A           BEQ      ??cJSON_strdup_0
    161              {
    162                  return NULL;
    163              }
    164          
    165              length = strlen((const char*)string) + sizeof("");
   \   00000014   1B0000EF           SWI      +27
    166              copy = (unsigned char*)hooks->allocate(length);
   \   00000018   001095E5           LDR      R1,[R5, #+0]
   \   0000001C   016080E2           ADD      R6,R0,#+1
   \   00000020   0600A0E1           MOV      R0,R6
   \   00000024   31FF2FE1           BLX      R1
   \   00000028   0050B0E1           MOVS     R5,R0
    167              if (copy == NULL)
   \   0000002C   0100001A           BNE      ??cJSON_strdup_1
    168              {
    169                  return NULL;
   \                     ??cJSON_strdup_0:
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   7080BDE8           POP      {R4-R6,PC}
    170              }
    171              memcpy(copy, string, length);
   \                     ??cJSON_strdup_1:
   \   00000038   0620A0E1           MOV      R2,R6
   \   0000003C   0410A0E1           MOV      R1,R4
   \   00000040   1E0100EF           SWI      +286
    172          
    173              return copy;
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
    174          }
    175          

   \                                 In segment CODE, align 4, keep-with-next
    176          CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
    177          {
   \                     cJSON_InitHooks:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    178              if (hooks == NULL)
   \   00000004   ........           LDR      R4,??DataTable2  ;; global_hooks
   \   00000008   0050B0E1           MOVS     R5,R0
   \   0000000C   0400001A           BNE      ??cJSON_InitHooks_0
    179              {
    180                  /* Reset hooks */
    181                  global_hooks.allocate = (void*(*)(size_t)) malloc_adr();
   \   00000010   148000EF           SWI      +32788
   \   00000014   000084E5           STR      R0,[R4, #+0]
    182                  global_hooks.deallocate = (void(*)(void*)) mfree_adr();
   \   00000018   158000EF           SWI      +32789
   \   0000001C   040084E5           STR      R0,[R4, #+4]
    183                  global_hooks.reallocate = (void*(*)(void*, size_t)) realloc_adr();
   \   00000020   130000EA           B        ??cJSON_InitHooks_1
    184                  return;
    185              }
    186          
    187              global_hooks.allocate = (void*(*)(size_t)) malloc_adr();
   \                     ??cJSON_InitHooks_0:
   \   00000024   148000EF           SWI      +32788
    188              if (hooks->malloc_fn != NULL)
   \   00000028   001095E5           LDR      R1,[R5, #+0]
   \   0000002C   000051E3           CMP      R1,#+0
    189              {
    190                  global_hooks.allocate = hooks->malloc_fn;
   \   00000030   0100A011           MOVNE    R0,R1
   \   00000034   000084E5           STR      R0,[R4, #+0]
    191              }
    192          
    193              global_hooks.deallocate = (void(*)(void*)) mfree_adr();
   \   00000038   158000EF           SWI      +32789
    194              if (hooks->free_fn != NULL)
   \   0000003C   041095E5           LDR      R1,[R5, #+4]
   \   00000040   000051E3           CMP      R1,#+0
    195              {
    196                  global_hooks.deallocate = hooks->free_fn;
   \   00000044   0100A011           MOVNE    R0,R1
   \   00000048   040084E5           STR      R0,[R4, #+4]
    197              }
    198          
    199              /* use realloc only if both free and malloc are used */
    200              global_hooks.reallocate = NULL;
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   080084E5           STR      R0,[R4, #+8]
    201              if ((global_hooks.allocate == (void*(*)(size_t))malloc_adr()) && (global_hooks.deallocate == (void(*)(void*))mfree_adr()))
   \   00000054   148000EF           SWI      +32788
   \   00000058   001094E5           LDR      R1,[R4, #+0]
   \   0000005C   000051E1           CMP      R1,R0
   \   00000060   3080BD18           POPNE    {R4,R5,PC}
   \   00000064   158000EF           SWI      +32789
   \   00000068   041094E5           LDR      R1,[R4, #+4]
   \   0000006C   000051E1           CMP      R1,R0
   \   00000070   3080BD18           POPNE    {R4,R5,PC}
    202              {
    203                  global_hooks.reallocate = (void*(*)(void*, size_t))realloc_adr();
   \                     ??cJSON_InitHooks_1:
   \   00000074   BA8000EF           SWI      +32954
   \   00000078   080084E5           STR      R0,[R4, #+8]
   \   0000007C   3080BDE8           POP      {R4,R5,PC}       ;; return
    204              }
    205          }
    206          
    207          /* Internal constructor. */

   \                                 In segment CODE, align 4, keep-with-next
    208          static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
    209          {
   \                     cJSON_New_Item:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0010A0E1           MOV      R1,R0
    210              cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
   \   00000008   001091E5           LDR      R1,[R1, #+0]
   \   0000000C   2400A0E3           MOV      R0,#+36
   \   00000010   31FF2FE1           BLX      R1
   \   00000014   0040B0E1           MOVS     R4,R0
    211              if (node)
   \   00000018   0200000A           BEQ      ??cJSON_New_Item_0
    212              {
    213                  memset(node, '\0', sizeof(cJSON));
   \   0000001C   2420A0E3           MOV      R2,#+36
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   BB0000EF           SWI      +187
    214              }
    215          
    216              return node;
   \                     ??cJSON_New_Item_0:
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
    217          }
    218          
    219          /* Delete a cJSON structure. */

   \                                 In segment CODE, align 4, keep-with-next
    220          CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
    221          {
   \                     cJSON_Delete:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    222              cJSON *next = NULL;
   \   00000008   7080BD08           POPEQ    {R4-R6,PC}
   \   0000000C   ........           LDR      R5,??DataTable2  ;; global_hooks
    223              while (item != NULL)
    224              {
    225                  next = item->next;
    226                  if (!(item->type & cJSON_IsReference) && (item->child != NULL))
   \                     ??cJSON_Delete_0:
   \   00000010   0C0094E5           LDR      R0,[R4, #+12]
   \   00000014   006094E5           LDR      R6,[R4, #+0]
   \   00000018   400F10E3           TST      R0,#0x100
   \   0000001C   0300001A           BNE      ??cJSON_Delete_1
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0000000A           BEQ      ??cJSON_Delete_1
    227                  {
    228                      cJSON_Delete(item->child);
   \   0000002C   F3FFFFEB           BL       cJSON_Delete
    229                  }
    230                  if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
   \                     ??cJSON_Delete_1:
   \   00000030   0C0094E5           LDR      R0,[R4, #+12]
   \   00000034   400F10E3           TST      R0,#0x100
   \   00000038   0400001A           BNE      ??cJSON_Delete_2
   \   0000003C   100094E5           LDR      R0,[R4, #+16]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0100000A           BEQ      ??cJSON_Delete_2
    231                  {
    232                      global_hooks.deallocate(item->valuestring);
   \   00000048   041095E5           LDR      R1,[R5, #+4]
   \   0000004C   31FF2FE1           BLX      R1
    233                  }
    234                  if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
   \                     ??cJSON_Delete_2:
   \   00000050   0C0094E5           LDR      R0,[R4, #+12]
   \   00000054   800F10E3           TST      R0,#0x200
   \   00000058   0400001A           BNE      ??cJSON_Delete_3
   \   0000005C   200094E5           LDR      R0,[R4, #+32]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0100000A           BEQ      ??cJSON_Delete_3
    235                  {
    236                      global_hooks.deallocate(item->string);
   \   00000068   041095E5           LDR      R1,[R5, #+4]
   \   0000006C   31FF2FE1           BLX      R1
    237                  }
    238                  global_hooks.deallocate(item);
   \                     ??cJSON_Delete_3:
   \   00000070   041095E5           LDR      R1,[R5, #+4]
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   31FF2FE1           BLX      R1
    239                  item = next;
   \   0000007C   0640B0E1           MOVS     R4,R6
    240              }
   \   00000080   E2FFFF1A           BNE      ??cJSON_Delete_0
    241          }
   \   00000084   7080BDE8           POP      {R4-R6,PC}       ;; return
    242          
    243          /* get the decimal point character of the current locale */
    244          static unsigned char get_decimal_point(void)
    245          {
    246          #ifdef ENABLE_LOCALES
    247              struct lconv *lconv = localeconv();
    248              return (unsigned char) lconv->decimal_point[0];
    249          #else
    250              return '.';
    251          #endif
    252          }
    253          
    254          typedef struct
    255          {
    256              const unsigned char *content;
    257              size_t length;
    258              size_t offset;
    259              size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
    260              internal_hooks hooks;
    261          } parse_buffer;
    262          
    263          /* check if the given size is left to read in a given parse buffer (starting with 1) */
    264          #define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
    265          /* check if the buffer can be accessed at the given index (starting with 0) */
    266          #define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
    267          #define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
    268          /* get a pointer to the buffer at the position */
    269          #define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
    270          
    271          /* Parse the input text to generate a number, and populate the result into item. */

   \                                 In segment CODE, align 4, keep-with-next
    272          static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
    273          {
   \                     parse_number:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   44D04DE2           SUB      SP,SP,#+68
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150B0E1           MOVS     R5,R1
    274              double number = 0;
    275              unsigned char *after_end = NULL;
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   00008DE5           STR      R0,[SP, #+0]
    276              unsigned char number_c_string[64];
    277              unsigned char decimal_point = get_decimal_point();
    278              size_t i = 0;
    279          
    280              if ((input_buffer == NULL) || (input_buffer->content == NULL))
   \   00000018   00109515           LDRNE    R1,[R5, #+0]
   \   0000001C   00005113           CMPNE    R1,#+0
   \   00000020   0200001A           BNE      ??parse_number_1
    281              {
    282                  return false;
   \                     ??parse_number_2:
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   44D08DE2           ADD      SP,SP,#+68
   \   0000002C   F080BDE8           POP      {R4-R7,PC}
    283              }
    284          
    285              /* copy the number into a temporary buffer and replace '.' with the decimal point
    286               * of the current locale (for strtod)
    287               * This also takes care of '\0' not necessarily being available for marking the end of the input */
    288              for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
   \                     ??parse_number_1:
   \   00000030   0010A0E3           MOV      R1,#+0
   \                     ??parse_number_3:
   \   00000034   082095E5           LDR      R2,[R5, #+8]
   \   00000038   04C095E5           LDR      R12,[R5, #+4]
   \   0000003C   023081E0           ADD      R3,R1,R2
   \   00000040   0C0053E1           CMP      R3,R12
   \   00000044   2100002A           BCS      ??parse_number_4
    289              {
    290                  switch (buffer_at_offset(input_buffer)[i])
   \   00000048   003095E5           LDR      R3,[R5, #+0]
   \   0000004C   032082E0           ADD      R2,R2,R3
   \   00000050   022081E0           ADD      R2,R1,R2
   \   00000054   00C0D2E5           LDRB     R12,[R2, #+0]
   \   00000058   04308DE2           ADD      R3,SP,#+4
   \   0000005C   033081E0           ADD      R3,R1,R3
   \   00000060   2BC04CE2           SUB      R12,R12,#+43
   \   00000064   3A005CE3           CMP      R12,#+58
   \   00000068   1800008A           BHI      ??parse_number_4
   \   0000006C   01EF8FE2           ADR      LR,??parse_number_0
   \   00000070   0CE0DEE7           LDRB     LR,[LR, R12]
   \   00000074   0EF18FE0           ADD      PC,PC,LR, LSL #+2
   \                     ??parse_number_0:
   \   00000078   0E150E10           DC8      +14,+21,+14,+16
   \   0000007C   150E0E0E           DC8      +21,+14,+14,+14
   \   00000080   0E0E0E0E           DC8      +14,+14,+14,+14
   \   00000084   0E0E0E15           DC8      +14,+14,+14,+21
   \   00000088   15151515           DC8      +21,+21,+21,+21
   \   0000008C   15151515           DC8      +21,+21,+21,+21
   \   00000090   15150E15           DC8      +21,+21,+14,+21
   \   00000094   15151515           DC8      +21,+21,+21,+21
   \   00000098   15151515           DC8      +21,+21,+21,+21
   \   0000009C   15151515           DC8      +21,+21,+21,+21
   \   000000A0   15151515           DC8      +21,+21,+21,+21
   \   000000A4   15151515           DC8      +21,+21,+21,+21
   \   000000A8   15151515           DC8      +21,+21,+21,+21
   \   000000AC   15151515           DC8      +21,+21,+21,+21
   \   000000B0   15150E00           DC8      +21,+21,+14,+0
    291                  {
    292                      case '0':
    293                      case '1':
    294                      case '2':
    295                      case '3':
    296                      case '4':
    297                      case '5':
    298                      case '6':
    299                      case '7':
    300                      case '8':
    301                      case '9':
    302                      case '+':
    303                      case '-':
    304                      case 'e':
    305                      case 'E':
    306                          number_c_string[i] = buffer_at_offset(input_buffer)[i];
   \                     ??parse_number_5:
   \   000000B4   0020D2E5           LDRB     R2,[R2, #+0]
   \   000000B8   000000EA           B        ??parse_number_6
    307                          break;
    308          
    309                      case '.':
    310                          number_c_string[i] = decimal_point;
   \                     ??parse_number_7:
   \   000000BC   2E20A0E3           MOV      R2,#+46
    311                          break;
    312          
    313                      default:
    314                          goto loop_end;
    315                  }
    316              }
   \                     ??parse_number_6:
   \   000000C0   011081E2           ADD      R1,R1,#+1
   \   000000C4   0020C3E5           STRB     R2,[R3, #+0]
   \   000000C8   3F0051E3           CMP      R1,#+63
   \   000000CC   D8FFFF3A           BCC      ??parse_number_3
    317          loop_end:
    318              number_c_string[i] = '\0';
   \                     ??parse_number_4:
   \   000000D0   04208DE2           ADD      R2,SP,#+4
   \   000000D4   0200C1E7           STRB     R0,[R1, +R2]
    319          
    320              number = strtod((const char*)number_c_string, (char**)&after_end);
   \   000000D8   0020A0E3           MOV      R2,#+0
   \   000000DC   0D10A0E1           MOV      R1,SP
   \   000000E0   04008DE2           ADD      R0,SP,#+4
   \   000000E4   ........           _BLF     _Stod,??_Stod??rA
   \   000000E8   0170A0E1           MOV      R7,R1
    321              if (number_c_string == after_end)
   \   000000EC   00109DE5           LDR      R1,[SP, #+0]
   \   000000F0   0060A0E1           MOV      R6,R0
   \   000000F4   04008DE2           ADD      R0,SP,#+4
   \   000000F8   010050E1           CMP      R0,R1
   \   000000FC   C8FFFF0A           BEQ      ??parse_number_2
    322              {
    323                  return false; /* parse_error */
    324              }
    325          
    326              item->valuedouble = number;
   \   00000100   186084E5           STR      R6,[R4, #+24]
   \   00000104   1C7084E5           STR      R7,[R4, #+28]
    327          
    328              /* use saturation in case of overflow */
    329              if (number >= INT_MAX)
   \   00000108   0600A0E1           MOV      R0,R6
   \   0000010C   0710A0E1           MOV      R1,R7
   \   00000110   C024A0E3           MOV      R2,#-1073741824
   \   00000114   FF2582E3           ORR      R2,R2,#0x3FC00000
   \   00000118   B034E0E3           MVN      R3,#-1342177280
   \   0000011C   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000120   ........           _BLF     __dGreaterEqual,??__dGreaterEqual??rA
   \   00000124   000050E3           CMP      R0,#+0
    330              {
    331                  item->valueint = INT_MAX;
   \   00000128   8004E013           MVNNE    R0,#-2147483648
   \   0000012C   0B00001A           BNE      ??parse_number_8
    332              }
    333              else if (number <= (double)INT_MIN)
   \   00000130   0600A0E1           MOV      R0,R6
   \   00000134   0710A0E1           MOV      R1,R7
   \   00000138   0120E0E3           MVN      R2,#+1
   \   0000013C   C035E0E3           MVN      R3,#+805306368
   \   00000140   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000144   ........           _BLF     __dLess,??__dLess??rA
   \   00000148   000050E3           CMP      R0,#+0
    334              {
    335                  item->valueint = INT_MIN;
   \   0000014C   8004A013           MOVNE    R0,#-2147483648
   \   00000150   0200001A           BNE      ??parse_number_8
    336              }
    337              else
    338              {
    339                  item->valueint = (int)number;
   \   00000154   0600A0E1           MOV      R0,R6
   \   00000158   0710A0E1           MOV      R1,R7
   \   0000015C   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \                     ??parse_number_8:
   \   00000160   140084E5           STR      R0,[R4, #+20]
    340              }
    341          
    342              item->type = cJSON_Number;
   \   00000164   0800A0E3           MOV      R0,#+8
   \   00000168   0C0084E5           STR      R0,[R4, #+12]
    343          
    344              input_buffer->offset += (size_t)(after_end - number_c_string);
   \   0000016C   080095E5           LDR      R0,[R5, #+8]
   \   00000170   00109DE5           LDR      R1,[SP, #+0]
   \   00000174   000081E0           ADD      R0,R1,R0
   \   00000178   04108DE2           ADD      R1,SP,#+4
   \   0000017C   010040E0           SUB      R0,R0,R1
   \   00000180   080085E5           STR      R0,[R5, #+8]
    345              return true;
   \   00000184   0100A0E3           MOV      R0,#+1
   \   00000188   44D08DE2           ADD      SP,SP,#+68
   \   0000018C   F080BDE8           POP      {R4-R7,PC}       ;; return
    346          }
    347          
    348          /* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */

   \                                 In segment CODE, align 4, keep-with-next
    349          CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
    350          {
   \                     cJSON_SetNumberHelper:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0060A0E1           MOV      R6,R0
    351              if (number >= INT_MAX)
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   0510A0E1           MOV      R1,R5
   \   00000018   C024A0E3           MOV      R2,#-1073741824
   \   0000001C   FF2582E3           ORR      R2,R2,#0x3FC00000
   \   00000020   B034E0E3           MVN      R3,#-1342177280
   \   00000024   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000028   ........           _BLF     __dGreaterEqual,??__dGreaterEqual??rA
   \   0000002C   000050E3           CMP      R0,#+0
    352              {
    353                  object->valueint = INT_MAX;
   \   00000030   8004E013           MVNNE    R0,#-2147483648
   \   00000034   0B00001A           BNE      ??cJSON_SetNumberHelper_0
    354              }
    355              else if (number <= (double)INT_MIN)
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0120E0E3           MVN      R2,#+1
   \   00000044   C035E0E3           MVN      R3,#+805306368
   \   00000048   E236C3E3           BIC      R3,R3,#0xE200000
   \   0000004C   ........           _BLF     __dLess,??__dLess??rA
   \   00000050   000050E3           CMP      R0,#+0
    356              {
    357                  object->valueint = INT_MIN;
   \   00000054   8004A013           MOVNE    R0,#-2147483648
   \   00000058   0200001A           BNE      ??cJSON_SetNumberHelper_0
    358              }
    359              else
    360              {
    361                  object->valueint = (int)number;
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \                     ??cJSON_SetNumberHelper_0:
   \   00000068   140086E5           STR      R0,[R6, #+20]
    362              }
    363          
    364              return object->valuedouble = number;
   \   0000006C   184086E5           STR      R4,[R6, #+24]
   \   00000070   1C5086E5           STR      R5,[R6, #+28]
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   0510A0E1           MOV      R1,R5
   \   0000007C   7080BDE8           POP      {R4-R6,PC}       ;; return
    365          }
    366          
    367          typedef struct
    368          {
    369              unsigned char *buffer;
    370              size_t length;
    371              size_t offset;
    372              size_t depth; /* current nesting depth (for formatted printing) */
    373              cJSON_bool noalloc;
    374              cJSON_bool format; /* is this print a formatted print */
    375              internal_hooks hooks;
    376          } printbuffer;
    377          
    378          /* realloc printbuffer if necessary to have at least "needed" bytes more */

   \                                 In segment CODE, align 4, keep-with-next
    379          static unsigned char* ensure(printbuffer * const p, size_t needed)
    380          {
   \                     ensure:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    381              unsigned char *newbuffer = NULL;
    382              size_t newsize = 0;
    383          
    384              if ((p == NULL) || (p->buffer == NULL))
   \   00000008   00009415           LDRNE    R0,[R4, #+0]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   0100001A           BNE      ??ensure_0
    385              {
    386                  return NULL;
   \                     ??ensure_1:
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   7080BDE8           POP      {R4-R6,PC}
    387              }
    388          
    389              if ((p->length > 0) && (p->offset >= p->length))
   \                     ??ensure_0:
   \   0000001C   043094E5           LDR      R3,[R4, #+4]
   \   00000020   082094E5           LDR      R2,[R4, #+8]
   \   00000024   000053E3           CMP      R3,#+0
   \   00000028   0100000A           BEQ      ??ensure_2
   \   0000002C   030052E1           CMP      R2,R3
   \   00000030   F7FFFF2A           BCS      ??ensure_1
    390              {
    391                  /* make sure that offset is valid */
    392                  return NULL;
    393              }
    394          
    395              if (needed > INT_MAX)
   \                     ??ensure_2:
   \   00000034   800451E3           CMP      R1,#-2147483648
   \   00000038   F5FFFF2A           BCS      ??ensure_1
    396              {
    397                  /* sizes bigger than INT_MAX are currently not supported */
    398                  return NULL;
    399              }
    400          
    401              needed += p->offset + 1;
   \   0000003C   015082E2           ADD      R5,R2,#+1
   \   00000040   011085E0           ADD      R1,R5,R1
    402              if (needed <= p->length)
   \   00000044   010053E1           CMP      R3,R1
    403              {
    404                  return p->buffer + p->offset;
   \   00000048   00008220           ADDCS    R0,R2,R0
   \   0000004C   7080BD28           POPCS    {R4-R6,PC}
    405              }
    406          
    407              if (p->noalloc) {
   \   00000050   102094E5           LDR      R2,[R4, #+16]
   \   00000054   000052E3           CMP      R2,#+0
   \   00000058   EDFFFF1A           BNE      ??ensure_1
    408                  return NULL;
    409              }
    410          
    411              /* calculate new buffer size */
    412              if (needed > (INT_MAX / 2))
   \   0000005C   400451E3           CMP      R1,#+1073741824
   \   00000060   0300003A           BCC      ??ensure_3
    413              {
    414                  /* overflow of int, use INT_MAX if possible */
    415                  if (needed <= INT_MAX)
   \   00000064   800451E3           CMP      R1,#-2147483648
   \   00000068   E9FFFF2A           BCS      ??ensure_1
    416                  {
    417                      newsize = INT_MAX;
   \   0000006C   8054E0E3           MVN      R5,#-2147483648
   \   00000070   000000EA           B        ??ensure_4
    418                  }
    419                  else
    420                  {
    421                      return NULL;
    422                  }
    423              }
    424              else
    425              {
    426                  newsize = needed * 2;
   \                     ??ensure_3:
   \   00000074   8150A0E1           LSL      R5,R1,#+1
    427              }
    428          
    429              if (p->hooks.reallocate != NULL)
   \                     ??ensure_4:
   \   00000078   202094E5           LDR      R2,[R4, #+32]
   \   0000007C   000052E3           CMP      R2,#+0
   \   00000080   0A00000A           BEQ      ??ensure_5
    430              {
    431                  /* reallocate with realloc if available */
    432                  newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   32FF2FE1           BLX      R2
   \   0000008C   0060B0E1           MOVS     R6,R0
    433                  if (newbuffer == NULL)
   \   00000090   1300001A           BNE      ??ensure_6
    434                  {
    435                      p->hooks.deallocate(p->buffer);
   \                     ??ensure_7:
   \   00000094   000094E5           LDR      R0,[R4, #+0]
   \   00000098   1C1094E5           LDR      R1,[R4, #+28]
   \   0000009C   31FF2FE1           BLX      R1
    436                      p->length = 0;
   \   000000A0   0000A0E3           MOV      R0,#+0
   \   000000A4   040084E5           STR      R0,[R4, #+4]
    437                      p->buffer = NULL;
   \   000000A8   000084E5           STR      R0,[R4, #+0]
    438          
    439                      return NULL;
   \   000000AC   7080BDE8           POP      {R4-R6,PC}
    440                  }
    441              }
    442              else
    443              {
    444                  /* otherwise reallocate manually */
    445                  newbuffer = (unsigned char*)p->hooks.allocate(newsize);
   \                     ??ensure_5:
   \   000000B0   181094E5           LDR      R1,[R4, #+24]
   \   000000B4   0500A0E1           MOV      R0,R5
   \   000000B8   31FF2FE1           BLX      R1
   \   000000BC   0060B0E1           MOVS     R6,R0
    446                  if (!newbuffer)
   \   000000C0   F3FFFF0A           BEQ      ??ensure_7
    447                  {
    448                      p->hooks.deallocate(p->buffer);
    449                      p->length = 0;
    450                      p->buffer = NULL;
    451          
    452                      return NULL;
    453                  }
    454                  if (newbuffer)
    455                  {
    456                      memcpy(newbuffer, p->buffer, p->offset + 1);
   \   000000C4   080094E5           LDR      R0,[R4, #+8]
   \   000000C8   001094E5           LDR      R1,[R4, #+0]
   \   000000CC   012080E2           ADD      R2,R0,#+1
   \   000000D0   0600A0E1           MOV      R0,R6
   \   000000D4   1E0100EF           SWI      +286
    457                  }
    458                  p->hooks.deallocate(p->buffer);
   \   000000D8   000094E5           LDR      R0,[R4, #+0]
   \   000000DC   1C1094E5           LDR      R1,[R4, #+28]
   \   000000E0   31FF2FE1           BLX      R1
    459              }
    460              p->length = newsize;
   \                     ??ensure_6:
   \   000000E4   045084E5           STR      R5,[R4, #+4]
    461              p->buffer = newbuffer;
   \   000000E8   006084E5           STR      R6,[R4, #+0]
    462          
    463              return newbuffer + p->offset;
   \   000000EC   080094E5           LDR      R0,[R4, #+8]
   \   000000F0   060080E0           ADD      R0,R0,R6
   \   000000F4   7080BDE8           POP      {R4-R6,PC}       ;; return
    464          }
    465          
    466          /* calculate the new length of the string in a printbuffer and update the offset */

   \                                 In segment CODE, align 4, keep-with-next
    467          static void update_offset(printbuffer * const buffer)
    468          {
   \                     update_offset:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    469              const unsigned char *buffer_pointer = NULL;
    470              if ((buffer == NULL) || (buffer->buffer == NULL))
   \   00000008   00009415           LDRNE    R0,[R4, #+0]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   1080BD08           POPEQ    {R4,PC}
    471              {
    472                  return;
    473              }
    474              buffer_pointer = buffer->buffer + buffer->offset;
    475          
    476              buffer->offset += strlen((const char*)buffer_pointer);
   \   00000014   081094E5           LDR      R1,[R4, #+8]
   \   00000018   000081E0           ADD      R0,R1,R0
   \   0000001C   1B0000EF           SWI      +27
   \   00000020   081094E5           LDR      R1,[R4, #+8]
   \   00000024   010080E0           ADD      R0,R0,R1
   \   00000028   080084E5           STR      R0,[R4, #+8]
    477          }
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
    478          
    479          /* Render the number nicely from the given item into a string. */

   \                                 In segment CODE, align 4, keep-with-next
    480          static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
    481          {
   \                     print_number:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
    482              unsigned char *output_pointer = NULL;
    483              double d = item->valuedouble;
   \   00000008   184090E5           LDR      R4,[R0, #+24]
   \   0000000C   1C5090E5           LDR      R5,[R0, #+28]
   \   00000010   0180B0E1           MOVS     R8,R1
    484              int length = 0;
    485              size_t i = 0;
    486              unsigned char number_buffer[26]; /* temporary buffer to print the number into */
    487              unsigned char decimal_point = get_decimal_point();
    488              double test;
    489          
    490              if (output_buffer == NULL)
   \   00000014   0200001A           BNE      ??print_number_0
    491              {
    492                  return false;
   \                     ??print_number_1:
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   24D08DE2           ADD      SP,SP,#+36
   \   00000020   F081BDE8           POP      {R4-R8,PC}
    493              }
    494          
    495              /* This checks for NaN and Infinity */
    496              if ((d * 0) != 0)
   \                     ??print_number_0:
   \   00000024   ........           LDR      R6,??DataTable9  ;; `?<Constant "null">`
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   0420A0E1           MOV      R2,R4
   \   00000034   0530A0E1           MOV      R3,R5
   \   00000038   ........           _BLF     __dMul,??__dMul??rA
   \   0000003C   0020A0E3           MOV      R2,#+0
   \   00000040   0230A0E1           MOV      R3,R2
   \   00000044   ........           _BLF     __dNotEqual,??__dNotEqual??rA
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0300000A           BEQ      ??print_number_2
    497              {
    498                  length = sprintf((char*)number_buffer, "null");
   \   00000050   0610A0E1           MOV      R1,R6
   \   00000054   08008DE2           ADD      R0,SP,#+8
   \   00000058   160000EF           SWI      +22
   \   0000005C   170000EA           B        ??print_number_3
    499              }
    500              else
    501              {
    502                  /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
    503                  length = sprintf((char*)number_buffer, percent_1_15g, d);
   \                     ??print_number_2:
   \   00000060   0420A0E1           MOV      R2,R4
   \   00000064   0530A0E1           MOV      R3,R5
   \   00000068   181086E2           ADD      R1,R6,#+24
   \   0000006C   08008DE2           ADD      R0,SP,#+8
   \   00000070   160000EF           SWI      +22
   \   00000074   0070A0E1           MOV      R7,R0
    504          
    505                  /* Check whether the original double can be recovered */
    506                  if ((sscanf((char*)number_buffer, percent_lg, &test) != 1) || ((double)test != d))
   \   00000078   0D20A0E1           MOV      R2,SP
   \   0000007C   281086E2           ADD      R1,R6,#+40
   \   00000080   08008DE2           ADD      R0,SP,#+8
   \   00000084   F50100EF           SWI      +501
   \   00000088   010050E3           CMP      R0,#+1
   \   0000008C   0600001A           BNE      ??print_number_4
   \   00000090   0D00A0E1           MOV      R0,SP
   \   00000094   030090E8           LDM      R0,{R0,R1}
   \   00000098   0420A0E1           MOV      R2,R4
   \   0000009C   0530A0E1           MOV      R3,R5
   \   000000A0   ........           _BLF     __dNotEqual,??__dNotEqual??rA
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0500000A           BEQ      ??print_number_5
    507                  {
    508                      /* If not, print with 17 decimal places of precision */
    509                      length = sprintf((char*)number_buffer, percent_1_17g, d);
   \                     ??print_number_4:
   \   000000AC   0420A0E1           MOV      R2,R4
   \   000000B0   0530A0E1           MOV      R3,R5
   \   000000B4   201086E2           ADD      R1,R6,#+32
   \   000000B8   08008DE2           ADD      R0,SP,#+8
   \   000000BC   160000EF           SWI      +22
   \                     ??print_number_3:
   \   000000C0   0070A0E1           MOV      R7,R0
    510                  }
    511              }
    512          
    513              /* sprintf failed or buffer overrun occured */
    514              if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
   \                     ??print_number_5:
   \   000000C4   000057E3           CMP      R7,#+0
   \   000000C8   D2FFFF4A           BMI      ??print_number_1
   \   000000CC   1A0057E3           CMP      R7,#+26
   \   000000D0   D0FFFFAA           BGE      ??print_number_1
    515              {
    516                  return false;
    517              }
    518          
    519              /* reserve appropriate space in the output */
    520              output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
   \   000000D4   011087E2           ADD      R1,R7,#+1
   \   000000D8   0800A0E1           MOV      R0,R8
   \   000000DC   ........           BL       ensure
    521              if (output_pointer == NULL)
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   0800000A           BEQ      ??print_number_6
    522              {
    523                  return false;
    524              }
    525          
    526              /* copy the printed number to the output and replace locale
    527               * dependent decimal point with '.' */
    528              for (i = 0; i < ((size_t)length); i++)
   \   000000E8   0010A0E3           MOV      R1,#+0
   \   000000EC   0020A0E3           MOV      R2,#+0
   \   000000F0   000057E3           CMP      R7,#+0
   \   000000F4   0700001A           BNE      ??print_number_7
    529              {
    530                  if (number_buffer[i] == decimal_point)
    531                  {
    532                      output_pointer[i] = '.';
    533                      continue;
    534                  }
    535          
    536                  output_pointer[i] = number_buffer[i];
    537              }
    538              output_pointer[i] = '\0';
   \                     ??print_number_8:
   \   000000F8   0010C2E7           STRB     R1,[R2, +R0]
    539          
    540              output_buffer->offset += (size_t)length;
   \   000000FC   080098E5           LDR      R0,[R8, #+8]
   \   00000100   000087E0           ADD      R0,R7,R0
   \   00000104   080088E5           STR      R0,[R8, #+8]
    541          
    542              return true;
   \   00000108   0100A0E3           MOV      R0,#+1
   \                     ??print_number_6:
   \   0000010C   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   00000110   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??print_number_9:
   \   00000114   012082E2           ADD      R2,R2,#+1
   \                     ??print_number_7:
   \   00000118   070052E1           CMP      R2,R7
   \   0000011C   F5FFFF2A           BCS      ??print_number_8
   \   00000120   08308DE2           ADD      R3,SP,#+8
   \   00000124   0360D2E7           LDRB     R6,[R2, +R3]
   \   00000128   003082E0           ADD      R3,R2,R0
   \   0000012C   0060C3E5           STRB     R6,[R3, #+0]
   \   00000130   F7FFFFEA           B        ??print_number_9
    543          }
    544          
    545          /* parse 4 digit hexadecimal number */
    546          static unsigned parse_hex4(const unsigned char * const input)
    547          {
    548              unsigned int h = 0;
    549              size_t i = 0;
    550          
    551              for (i = 0; i < 4; i++)
    552              {
    553                  /* parse digit */
    554                  if ((input[i] >= '0') && (input[i] <= '9'))
    555                  {
    556                      h += (unsigned int) input[i] - '0';
    557                  }
    558                  else if ((input[i] >= 'A') && (input[i] <= 'F'))
    559                  {
    560                      h += (unsigned int) 10 + input[i] - 'A';
    561                  }
    562                  else if ((input[i] >= 'a') && (input[i] <= 'f'))
    563                  {
    564                      h += (unsigned int) 10 + input[i] - 'a';
    565                  }
    566                  else /* invalid */
    567                  {
    568                      return 0;
    569                  }
    570          
    571                  if (i < 3)
    572                  {
    573                      /* shift left to make place for the next nibble */
    574                      h = h << 4;
    575                  }
    576              }
    577          
    578              return h;
    579          }
    580          
    581          /* converts a UTF-16 literal to UTF-8
    582           * A literal can be one or two sequences of the form \uXXXX */

   \                                 In segment CODE, align 4, keep-with-next
    583          static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
    584          {
   \                     utf16_literal_to_utf8:
   \   00000000   F0002DE9           PUSH     {R4-R7}
    585              long unsigned int codepoint = 0;
    586              unsigned int first_code = 0;
    587              const unsigned char *first_sequence = input_pointer;
    588              unsigned char utf8_length = 0;
    589              unsigned char utf8_position = 0;
    590              unsigned char sequence_length = 0;
    591              unsigned char first_byte_mark = 0;
   \   00000004   0030A0E3           MOV      R3,#+0
    592          
    593              if ((input_end - first_sequence) < 6)
   \   00000008   004041E0           SUB      R4,R1,R0
   \   0000000C   060054E3           CMP      R4,#+6
   \   00000010   130000BA           BLT      ??utf16_literal_to_utf8_0
    594              {
    595                  /* input ends unexpectedly */
    596                  goto fail;
    597              }
    598          
    599              /* get the first utf16 sequence */
    600              first_code = parse_hex4(first_sequence + 2);
   \   00000014   024080E2           ADD      R4,R0,#+2
   \   00000018   00C0A0E3           MOV      R12,#+0
   \   0000001C   0350A0E1           MOV      R5,R3
   \                     ??utf16_literal_to_utf8_1:
   \   00000020   046085E0           ADD      R6,R5,R4
   \   00000024   0070D6E5           LDRB     R7,[R6, #+0]
   \   00000028   300057E3           CMP      R7,#+48
   \   0000002C   0F00003A           BCC      ??utf16_literal_to_utf8_2
   \   00000030   3A0057E3           CMP      R7,#+58
   \   00000034   0D00002A           BCS      ??utf16_literal_to_utf8_2
   \   00000038   306047E2           SUB      R6,R7,#+48
   \                     ??utf16_literal_to_utf8_3:
   \   0000003C   0CC086E0           ADD      R12,R6,R12
   \   00000040   030055E3           CMP      R5,#+3
   \   00000044   0CC2A031           LSLCC    R12,R12,#+4
   \   00000048   015085E2           ADD      R5,R5,#+1
   \   0000004C   040055E3           CMP      R5,#+4
   \   00000050   F2FFFF3A           BCC      ??utf16_literal_to_utf8_1
    601          
    602              /* check that the code is valid */
    603              if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
   \   00000054   DC0C5CE3           CMP      R12,#+56320
   \   00000058   1400003A           BCC      ??utf16_literal_to_utf8_4
   \   0000005C   E00C5CE3           CMP      R12,#+57344
   \   00000060   0D00002A           BCS      ??utf16_literal_to_utf8_5
    604              {
    605                  goto fail;
    606              }
    607          
    608              /* UTF16 surrogate pair */
    609              if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
    610              {
    611                  const unsigned char *second_sequence = first_sequence + 6;
    612                  unsigned int second_code = 0;
    613                  sequence_length = 12; /* \uXXXX\uXXXX */
    614          
    615                  if ((input_end - second_sequence) < 6)
    616                  {
    617                      /* input ends unexpectedly */
    618                      goto fail;
    619                  }
    620          
    621                  if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
    622                  {
    623                      /* missing second half of the surrogate pair */
    624                      goto fail;
    625                  }
    626          
    627                  /* get the second utf16 sequence */
    628                  second_code = parse_hex4(second_sequence + 2);
    629                  /* check that the code is valid */
    630                  if ((second_code < 0xDC00) || (second_code > 0xDFFF))
    631                  {
    632                      /* invalid second half of the surrogate pair */
    633                      goto fail;
    634                  }
    635          
    636          
    637                  /* calculate the unicode codepoint from the surrogate pair */
    638                  codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
    639              }
    640              else
    641              {
    642                  sequence_length = 6; /* \uXXXX */
    643                  codepoint = first_code;
    644              }
    645          
    646              /* encode as UTF-8
    647               * takes at maximum 4 bytes to encode:
    648               * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    649              if (codepoint < 0x80)
    650              {
    651                  /* normal ascii, encoding 0xxxxxxx */
    652                  utf8_length = 1;
    653              }
    654              else if (codepoint < 0x800)
    655              {
    656                  /* two bytes, encoding 110xxxxx 10xxxxxx */
    657                  utf8_length = 2;
    658                  first_byte_mark = 0xC0; /* 11000000 */
    659              }
    660              else if (codepoint < 0x10000)
    661              {
    662                  /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
    663                  utf8_length = 3;
    664                  first_byte_mark = 0xE0; /* 11100000 */
    665              }
    666              else if (codepoint <= 0x10FFFF)
    667              {
    668                  /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
    669                  utf8_length = 4;
    670                  first_byte_mark = 0xF0; /* 11110000 */
    671              }
    672              else
    673              {
    674                  /* invalid unicode codepoint */
    675                  goto fail;
    676              }
    677          
    678              /* encode as utf8 */
    679              for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
    680              {
    681                  /* 10xxxxxx */
    682                  (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
    683                  codepoint >>= 6;
    684              }
    685              /* encode first byte */
    686              if (utf8_length > 1)
    687              {
    688                  (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
    689              }
    690              else
    691              {
    692                  (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
    693              }
    694          
    695              *output_pointer += utf8_length;
    696          
    697              return sequence_length;
    698          
    699          fail:
    700              return 0;
   \                     ??utf16_literal_to_utf8_0:
   \   00000064   F000BDE8           POP      {R4-R7}
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   1EFF2FE1           BX       LR               ;; return
   \                     ??utf16_literal_to_utf8_2:
   \   00000070   410057E3           CMP      R7,#+65
   \   00000074   0200003A           BCC      ??utf16_literal_to_utf8_6
   \   00000078   470057E3           CMP      R7,#+71
   \   0000007C   37604732           SUBCC    R6,R7,#+55
   \   00000080   EDFFFF3A           BCC      ??utf16_literal_to_utf8_3
   \                     ??utf16_literal_to_utf8_6:
   \   00000084   610057E3           CMP      R7,#+97
   \   00000088   0200003A           BCC      ??utf16_literal_to_utf8_7
   \   0000008C   670057E3           CMP      R7,#+103
   \   00000090   57604732           SUBCC    R6,R7,#+87
   \   00000094   E8FFFF3A           BCC      ??utf16_literal_to_utf8_3
   \                     ??utf16_literal_to_utf8_7:
   \   00000098   00C0A0E3           MOV      R12,#+0
   \                     ??utf16_literal_to_utf8_5:
   \   0000009C   0600A0E3           MOV      R0,#+6
   \                     ??utf16_literal_to_utf8_8:
   \   000000A0   80005CE3           CMP      R12,#+128
   \   000000A4   3200002A           BCS      ??utf16_literal_to_utf8_9
   \   000000A8   0110A0E3           MOV      R1,#+1
   \   000000AC   3C0000EA           B        ??utf16_literal_to_utf8_10
   \                     ??utf16_literal_to_utf8_4:
   \   000000B0   D80C5CE3           CMP      R12,#+55296
   \   000000B4   F8FFFF3A           BCC      ??utf16_literal_to_utf8_5
   \   000000B8   064080E2           ADD      R4,R0,#+6
   \   000000BC   0C00A0E3           MOV      R0,#+12
   \   000000C0   041041E0           SUB      R1,R1,R4
   \   000000C4   060051E3           CMP      R1,#+6
   \   000000C8   E5FFFFBA           BLT      ??utf16_literal_to_utf8_0
   \   000000CC   0010D4E5           LDRB     R1,[R4, #+0]
   \   000000D0   5C0051E3           CMP      R1,#+92
   \   000000D4   0110D405           LDRBEQ   R1,[R4, #+1]
   \   000000D8   75005103           CMPEQ    R1,#+117
   \   000000DC   E0FFFF1A           BNE      ??utf16_literal_to_utf8_0
   \   000000E0   024084E2           ADD      R4,R4,#+2
   \   000000E4   0010A0E3           MOV      R1,#+0
   \   000000E8   0150A0E1           MOV      R5,R1
   \                     ??utf16_literal_to_utf8_11:
   \   000000EC   046085E0           ADD      R6,R5,R4
   \   000000F0   0070D6E5           LDRB     R7,[R6, #+0]
   \   000000F4   300057E3           CMP      R7,#+48
   \   000000F8   0200003A           BCC      ??utf16_literal_to_utf8_12
   \   000000FC   3A0057E3           CMP      R7,#+58
   \   00000100   30604732           SUBCC    R6,R7,#+48
   \   00000104   0900003A           BCC      ??utf16_literal_to_utf8_13
   \                     ??utf16_literal_to_utf8_12:
   \   00000108   410057E3           CMP      R7,#+65
   \   0000010C   0200003A           BCC      ??utf16_literal_to_utf8_14
   \   00000110   470057E3           CMP      R7,#+71
   \   00000114   37604732           SUBCC    R6,R7,#+55
   \   00000118   0400003A           BCC      ??utf16_literal_to_utf8_13
   \                     ??utf16_literal_to_utf8_14:
   \   0000011C   610057E3           CMP      R7,#+97
   \   00000120   CFFFFF3A           BCC      ??utf16_literal_to_utf8_0
   \   00000124   670057E3           CMP      R7,#+103
   \   00000128   CDFFFF2A           BCS      ??utf16_literal_to_utf8_0
   \   0000012C   576047E2           SUB      R6,R7,#+87
   \                     ??utf16_literal_to_utf8_13:
   \   00000130   011086E0           ADD      R1,R6,R1
   \   00000134   030055E3           CMP      R5,#+3
   \   00000138   0112A031           LSLCC    R1,R1,#+4
   \   0000013C   015085E2           ADD      R5,R5,#+1
   \   00000140   040055E3           CMP      R5,#+4
   \   00000144   E8FFFF3A           BCC      ??utf16_literal_to_utf8_11
   \   00000148   DC0C51E3           CMP      R1,#+56320
   \   0000014C   C4FFFF3A           BCC      ??utf16_literal_to_utf8_0
   \   00000150   E00C51E3           CMP      R1,#+57344
   \   00000154   C2FFFF2A           BCS      ??utf16_literal_to_utf8_0
   \   00000158   FF40A0E3           MOV      R4,#+255
   \   0000015C   C04F84E3           ORR      R4,R4,#0x300
   \   00000160   0C5004E0           AND      R5,R4,R12
   \   00000164   011004E0           AND      R1,R4,R1
   \   00000168   051581E1           ORR      R1,R1,R5, LSL #+10
   \   0000016C   40CB81E2           ADD      R12,R1,#+65536
   \   00000170   CAFFFFEA           B        ??utf16_literal_to_utf8_8
   \                     ??utf16_literal_to_utf8_9:
   \   00000174   800E5CE3           CMP      R12,#+2048
   \   00000178   0210A033           MOVCC    R1,#+2
   \   0000017C   C030A033           MOVCC    R3,#+192
   \   00000180   0700003A           BCC      ??utf16_literal_to_utf8_10
   \   00000184   400B5CE3           CMP      R12,#+65536
   \   00000188   0310A033           MOVCC    R1,#+3
   \   0000018C   E030A033           MOVCC    R3,#+224
   \   00000190   0300003A           BCC      ??utf16_literal_to_utf8_10
   \   00000194   44095CE3           CMP      R12,#+1114112
   \   00000198   B1FFFF2A           BCS      ??utf16_literal_to_utf8_0
   \   0000019C   0410A0E3           MOV      R1,#+4
   \   000001A0   F030A0E3           MOV      R3,#+240
   \                     ??utf16_literal_to_utf8_10:
   \   000001A4   014041E2           SUB      R4,R1,#+1
   \   000001A8   FF4014E2           ANDS     R4,R4,#0xFF
   \   000001AC   0700000A           BEQ      ??utf16_literal_to_utf8_15
   \                     ??utf16_literal_to_utf8_16:
   \   000001B0   006092E5           LDR      R6,[R2, #+0]
   \   000001B4   BF700CE2           AND      R7,R12,#0xBF
   \   000001B8   807087E3           ORR      R7,R7,#0x80
   \   000001BC   0670C4E7           STRB     R7,[R4, +R6]
   \   000001C0   2CC3A0E1           LSR      R12,R12,#+6
   \   000001C4   014044E2           SUB      R4,R4,#+1
   \   000001C8   FF4014E2           ANDS     R4,R4,#0xFF
   \   000001CC   F7FFFF1A           BNE      ??utf16_literal_to_utf8_16
   \                     ??utf16_literal_to_utf8_15:
   \   000001D0   004092E5           LDR      R4,[R2, #+0]
   \   000001D4   020051E3           CMP      R1,#+2
   \   000001D8   0C308321           ORRCS    R3,R3,R12
   \   000001DC   7F300C32           ANDCC    R3,R12,#0x7F
   \   000001E0   0030C4E5           STRB     R3,[R4, #+0]
   \   000001E4   003092E5           LDR      R3,[R2, #+0]
   \   000001E8   031081E0           ADD      R1,R1,R3
   \   000001EC   001082E5           STR      R1,[R2, #+0]
   \   000001F0   F000BDE8           POP      {R4-R7}
   \   000001F4   1EFF2FE1           BX       LR
    701          }
    702          
    703          /* Parse the input text into an unescaped cinput, and populate item. */

   \                                 In segment CODE, align 4, keep-with-next
    704          static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
    705          {
   \                     parse_string:
   \   00000000   F0452DE9           PUSH     {R4-R8,R10,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   000095E5           LDR      R0,[R5, #+0]
   \   00000014   081095E5           LDR      R1,[R5, #+8]
    706              const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
    707              const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
    708              unsigned char *output_pointer = NULL;
   \   00000018   0080A0E3           MOV      R8,#+0
   \   0000001C   001081E0           ADD      R1,R1,R0
   \   00000020   00808DE5           STR      R8,[SP, #+0]
    709              unsigned char *output = NULL;
    710          
    711              /* not a string */
    712              if (buffer_at_offset(input_buffer)[0] != '\"')
   \   00000024   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000028   016081E2           ADD      R6,R1,#+1
   \   0000002C   017081E2           ADD      R7,R1,#+1
   \   00000030   220052E3           CMP      R2,#+34
   \   00000034   7400001A           BNE      ??parse_string_1
    713              {
    714                  goto fail;
    715              }
    716          
    717              {
    718                  /* calculate approximate size of the output (overestimate) */
    719                  size_t allocation_length = 0;
    720                  size_t skipped_bytes = 0;
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   080000EA           B        ??parse_string_2
    721                  while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
    722                  {
    723                      /* is escape sequence */
    724                      if (input_end[0] == '\\')
   \                     ??parse_string_3:
   \   00000040   5C0053E3           CMP      R3,#+92
   \   00000044   0500001A           BNE      ??parse_string_4
    725                      {
    726                          if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
   \   00000048   013087E2           ADD      R3,R7,#+1
   \   0000004C   003043E0           SUB      R3,R3,R0
   \   00000050   0A0053E1           CMP      R3,R10
   \   00000054   6C00002A           BCS      ??parse_string_1
    727                          {
    728                              /* prevent buffer overflow when last input character is a backslash */
    729                              goto fail;
    730                          }
    731                          skipped_bytes++;
   \   00000058   012082E2           ADD      R2,R2,#+1
    732                          input_end++;
   \   0000005C   017087E2           ADD      R7,R7,#+1
    733                      }
    734                      input_end++;
   \                     ??parse_string_4:
   \   00000060   017087E2           ADD      R7,R7,#+1
    735                  }
   \                     ??parse_string_2:
   \   00000064   04A095E5           LDR      R10,[R5, #+4]
   \   00000068   003047E0           SUB      R3,R7,R0
   \   0000006C   0A0053E1           CMP      R3,R10
   \   00000070   6500002A           BCS      ??parse_string_1
   \   00000074   0030D7E5           LDRB     R3,[R7, #+0]
   \   00000078   220053E3           CMP      R3,#+34
   \   0000007C   EFFFFF1A           BNE      ??parse_string_3
   \   00000080   6100001A           BNE      ??parse_string_1
    736                  if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
    737                  {
    738                      goto fail; /* string ended unexpectedly */
    739                  }
    740          
    741                  /* This is at most how much we need for the output */
    742                  allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
    743                  output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
   \   00000084   010047E0           SUB      R0,R7,R1
   \   00000088   101095E5           LDR      R1,[R5, #+16]
   \   0000008C   020040E0           SUB      R0,R0,R2
   \   00000090   010080E2           ADD      R0,R0,#+1
   \   00000094   31FF2FE1           BLX      R1
   \   00000098   00A0B0E1           MOVS     R10,R0
    744                  if (output == NULL)
   \   0000009C   5500000A           BEQ      ??parse_string_5
    745                  {
    746                      goto fail; /* allocation failure */
    747                  }
    748              }
    749          
    750              output_pointer = output;
   \   000000A0   00A08DE5           STR      R10,[SP, #+0]
   \   000000A4   050000EA           B        ??parse_string_6
    751              /* loop through the string literal */
    752              while (input_pointer < input_end)
    753              {
    754                  if (*input_pointer != '\\')
    755                  {
    756                      *output_pointer++ = *input_pointer++;
   \                     ??parse_string_7:
   \   000000A8   ........           LDRB     R1,[R6], #+1
   \   000000AC   00009DE5           LDR      R0,[SP, #+0]
   \   000000B0   0010C0E5           STRB     R1,[R0, #+0]
   \   000000B4   00109DE5           LDR      R1,[SP, #+0]
   \   000000B8   011081E2           ADD      R1,R1,#+1
   \   000000BC   00108DE5           STR      R1,[SP, #+0]
    757                  }
   \                     ??parse_string_6:
   \   000000C0   070056E1           CMP      R6,R7
   \   000000C4   4000002A           BCS      ??parse_string_8
   \   000000C8   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000CC   5C0050E3           CMP      R0,#+92
   \   000000D0   F4FFFF1A           BNE      ??parse_string_7
    758                  /* escape sequence */
    759                  else
    760                  {
    761                      unsigned char sequence_length = 2;
   \   000000D4   0200A0E3           MOV      R0,#+2
    762                      if ((input_end - input_pointer) < 1)
   \   000000D8   061047E0           SUB      R1,R7,R6
   \   000000DC   010051E3           CMP      R1,#+1
   \   000000E0   460000BA           BLT      ??parse_string_9
    763                      {
    764                          goto fail;
    765                      }
    766          
    767                      switch (input_pointer[1])
   \   000000E4   0110D6E5           LDRB     R1,[R6, #+1]
   \   000000E8   221041E2           SUB      R1,R1,#+34
   \   000000EC   530051E3           CMP      R1,#+83
   \   000000F0   4000008A           BHI      ??parse_string_5
   \   000000F4   012F8FE2           ADR      R2,??parse_string_0
   \   000000F8   0120D2E7           LDRB     R2,[R2, R1]
   \   000000FC   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??parse_string_0:
   \   00000100   273D3D3D           DC8      +39,+61,+61,+61
   \   00000104   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000108   3D3D3D3D           DC8      +61,+61,+61,+61
   \   0000010C   3D273D3D           DC8      +61,+39,+61,+61
   \   00000110   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000114   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000118   3D3D3D3D           DC8      +61,+61,+61,+61
   \   0000011C   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000120   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000124   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000128   3D3D3D3D           DC8      +61,+61,+61,+61
   \   0000012C   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000130   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000134   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000138   3D3D273D           DC8      +61,+61,+39,+61
   \   0000013C   3D3D3D3D           DC8      +61,+61,+61,+61
   \   00000140   143D3D3D           DC8      +20,+61,+61,+61
   \   00000144   1B3D3D3D           DC8      +27,+61,+61,+61
   \   00000148   3D3D3D3D           DC8      +61,+61,+61,+61
   \   0000014C   1E3D3D3D           DC8      +30,+61,+61,+61
   \   00000150   213D242A           DC8      +33,+61,+36,+42
    768                      {
    769                          case 'b':
    770                              *output_pointer++ = '\b';
   \                     ??parse_string_10:
   \   00000154   00109DE5           LDR      R1,[SP, #+0]
   \   00000158   0820A0E3           MOV      R2,#+8
   \                     ??parse_string_11:
   \   0000015C   0020C1E5           STRB     R2,[R1, #+0]
   \   00000160   00209DE5           LDR      R2,[SP, #+0]
   \   00000164   012082E2           ADD      R2,R2,#+1
   \   00000168   00208DE5           STR      R2,[SP, #+0]
   \   0000016C   140000EA           B        ??parse_string_12
    771                              break;
    772                          case 'f':
    773                              *output_pointer++ = '\f';
   \                     ??parse_string_13:
   \   00000170   00109DE5           LDR      R1,[SP, #+0]
   \   00000174   0C20A0E3           MOV      R2,#+12
   \   00000178   F7FFFFEA           B        ??parse_string_11
    774                              break;
    775                          case 'n':
    776                              *output_pointer++ = '\n';
   \                     ??parse_string_14:
   \   0000017C   00109DE5           LDR      R1,[SP, #+0]
   \   00000180   0A20A0E3           MOV      R2,#+10
   \                     ??parse_string_15:
   \   00000184   F4FFFFEA           B        ??parse_string_11
    777                              break;
    778                          case 'r':
    779                              *output_pointer++ = '\r';
   \                     ??parse_string_16:
   \   00000188   00109DE5           LDR      R1,[SP, #+0]
   \   0000018C   0D20A0E3           MOV      R2,#+13
   \   00000190   F1FFFFEA           B        ??parse_string_11
    780                              break;
    781                          case 't':
    782                              *output_pointer++ = '\t';
   \                     ??parse_string_17:
   \   00000194   00109DE5           LDR      R1,[SP, #+0]
   \   00000198   0920A0E3           MOV      R2,#+9
   \   0000019C   EEFFFFEA           B        ??parse_string_11
    783                              break;
    784                          case '\"':
    785                          case '\\':
    786                          case '/':
    787                              *output_pointer++ = input_pointer[1];
   \                     ??parse_string_18:
   \   000001A0   00109DE5           LDR      R1,[SP, #+0]
   \   000001A4   0120D6E5           LDRB     R2,[R6, #+1]
   \   000001A8   EBFFFFEA           B        ??parse_string_11
    788                              break;
    789          
    790                          /* UTF-16 literal */
    791                          case 'u':
    792                              sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
   \                     ??parse_string_19:
   \   000001AC   0D20A0E1           MOV      R2,SP
   \   000001B0   0710A0E1           MOV      R1,R7
   \   000001B4   0600A0E1           MOV      R0,R6
   \   000001B8   ........           BL       utf16_literal_to_utf8
    793                              if (sequence_length == 0)
   \   000001BC   0010B0E1           MOVS     R1,R0
   \   000001C0   0E00000A           BEQ      ??parse_string_9
    794                              {
    795                                  /* failed to convert UTF16-literal to UTF-8 */
    796                                  goto fail;
    797                              }
    798                              break;
    799          
    800                          default:
    801                              goto fail;
    802                      }
    803                      input_pointer += sequence_length;
   \                     ??parse_string_12:
   \   000001C4   066080E0           ADD      R6,R0,R6
   \   000001C8   BCFFFFEA           B        ??parse_string_6
    804                  }
    805              }
    806          
    807              /* zero terminate the output */
    808              *output_pointer = '\0';
   \                     ??parse_string_8:
   \   000001CC   00009DE5           LDR      R0,[SP, #+0]
   \   000001D0   0080C0E5           STRB     R8,[R0, #+0]
    809          
    810              item->type = cJSON_String;
   \   000001D4   1000A0E3           MOV      R0,#+16
   \   000001D8   0C0084E5           STR      R0,[R4, #+12]
    811              item->valuestring = (char*)output;
   \   000001DC   10A084E5           STR      R10,[R4, #+16]
    812          
    813              input_buffer->offset = (size_t) (input_end - input_buffer->content);
    814              input_buffer->offset++;
   \   000001E0   000095E5           LDR      R0,[R5, #+0]
   \   000001E4   000047E0           SUB      R0,R7,R0
   \   000001E8   010080E2           ADD      R0,R0,#+1
   \   000001EC   080085E5           STR      R0,[R5, #+8]
    815          
    816              return true;
   \   000001F0   0100A0E3           MOV      R0,#+1
   \   000001F4   F685BDE8           POP      {R1,R2,R4-R8,R10,PC}
    817          
    818          fail:
    819              if (output != NULL)
   \                     ??parse_string_5:
   \   000001F8   00005AE3           CMP      R10,#+0
   \   000001FC   0200000A           BEQ      ??parse_string_1
    820              {
    821                  input_buffer->hooks.deallocate(output);
   \                     ??parse_string_9:
   \   00000200   141095E5           LDR      R1,[R5, #+20]
   \   00000204   0A00A0E1           MOV      R0,R10
   \   00000208   31FF2FE1           BLX      R1
    822              }
    823          
    824              if (input_pointer != NULL)
   \                     ??parse_string_1:
   \   0000020C   000056E3           CMP      R6,#+0
    825              {
    826                  input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
   \   00000210   00009515           LDRNE    R0,[R5, #+0]
   \   00000214   00004610           SUBNE    R0,R6,R0
   \   00000218   08008515           STRNE    R0,[R5, #+8]
    827              }
    828          
    829              return false;
   \   0000021C   0000A0E3           MOV      R0,#+0
   \   00000220   F685BDE8           POP      {R1,R2,R4-R8,R10,PC}
    830          }
    831          
    832          /* Render the cstring provided to an escaped version that can be printed. */

   \                                 In segment CODE, align 4, keep-with-next
    833          static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
    834          {
   \                     print_string_ptr:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0100A0E1           MOV      R0,R1
    835              const unsigned char *input_pointer = NULL;
    836              unsigned char *output = NULL;
    837              unsigned char *output_pointer = NULL;
    838              size_t output_length = 0;
    839              /* numbers of additional characters needed for escaping */
    840              size_t escape_characters = 0;
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   0060A0E3           MOV      R6,#+0
    841          
    842              if (output_buffer == NULL)
   \   00000014   000050E3           CMP      R0,#+0
    843              {
    844                  return false;
   \   00000018   F083BD08           POPEQ    {R4-R9,PC}
    845              }
    846          
    847              /* empty string */
    848              if (input == NULL)
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   0700001A           BNE      ??print_string_ptr_2
    849              {
    850                  output = ensure(output_buffer, sizeof("\"\""));
   \   00000024   0310A0E3           MOV      R1,#+3
   \   00000028   ........           BL       ensure
    851                  if (output == NULL)
   \   0000002C   000050E3           CMP      R0,#+0
    852                  {
    853                      return false;
   \   00000030   F083BD08           POPEQ    {R4-R9,PC}
    854                  }
    855                  strcpy((char*)output, "\"\"");
   \   00000034   7F1F8FE2           ADR      R1,??print_string_ptr_3  ;; "\"\""
   \   00000038   1A0000EF           SWI      +26
    856          
    857                  return true;
   \   0000003C   0100A0E3           MOV      R0,#+1
   \   00000040   F083BDE8           POP      {R4-R9,PC}
    858              }
    859          
    860              /* set "flag" to 1 if something needs to be escaped */
    861              for (input_pointer = input; *input_pointer; input_pointer++)
   \                     ??print_string_ptr_2:
   \   00000044   0490A0E1           MOV      R9,R4
   \   00000048   0010D9E5           LDRB     R1,[R9, #+0]
   \   0000004C   000051E3           CMP      R1,#+0
   \   00000050   2300000A           BEQ      ??print_string_ptr_4
    862              {
    863                  switch (*input_pointer)
   \                     ??print_string_ptr_5:
   \   00000054   0010D9E5           LDRB     R1,[R9, #+0]
   \   00000058   082041E2           SUB      R2,R1,#+8
   \   0000005C   540052E3           CMP      R2,#+84
   \   00000060   1A00008A           BHI      ??print_string_ptr_6
   \   00000064   013F8FE2           ADR      R3,??print_string_ptr_0
   \   00000068   0230D3E7           LDRB     R3,[R3, R2]
   \   0000006C   03F18FE0           ADD      PC,PC,R3, LSL #+2
   \                     ??print_string_ptr_0:
   \   00000070   15151517           DC8      +21,+21,+21,+23
   \   00000074   15151717           DC8      +21,+21,+23,+23
   \   00000078   17171717           DC8      +23,+23,+23,+23
   \   0000007C   17171717           DC8      +23,+23,+23,+23
   \   00000080   17171717           DC8      +23,+23,+23,+23
   \   00000084   17171717           DC8      +23,+23,+23,+23
   \   00000088   17171517           DC8      +23,+23,+21,+23
   \   0000008C   17171717           DC8      +23,+23,+23,+23
   \   00000090   17171717           DC8      +23,+23,+23,+23
   \   00000094   17171717           DC8      +23,+23,+23,+23
   \   00000098   17171717           DC8      +23,+23,+23,+23
   \   0000009C   17171717           DC8      +23,+23,+23,+23
   \   000000A0   17171717           DC8      +23,+23,+23,+23
   \   000000A4   17171717           DC8      +23,+23,+23,+23
   \   000000A8   17171717           DC8      +23,+23,+23,+23
   \   000000AC   17171717           DC8      +23,+23,+23,+23
   \   000000B0   17171717           DC8      +23,+23,+23,+23
   \   000000B4   17171717           DC8      +23,+23,+23,+23
   \   000000B8   17171717           DC8      +23,+23,+23,+23
   \   000000BC   17171717           DC8      +23,+23,+23,+23
   \   000000C0   17171717           DC8      +23,+23,+23,+23
   \   000000C4   15000000           DC8      +21,+0,+0,+0
    864                  {
    865                      case '\"':
    866                      case '\\':
    867                      case '\b':
    868                      case '\f':
    869                      case '\n':
    870                      case '\r':
    871                      case '\t':
    872                          /* one character escape sequence */
    873                          escape_characters++;
   \                     ??print_string_ptr_7:
   \   000000C8   016086E2           ADD      R6,R6,#+1
   \   000000CC   010000EA           B        ??print_string_ptr_8
    874                          break;
    875                      default:
    876                          if (*input_pointer < 32)
   \                     ??print_string_ptr_6:
   \   000000D0   200051E3           CMP      R1,#+32
    877                          {
    878                              /* UTF-16 escape sequence uXXXX */
    879                              escape_characters += 5;
   \   000000D4   05608632           ADDCC    R6,R6,#+5
    880                          }
    881                          break;
    882                  }
    883              }
   \                     ??print_string_ptr_8:
   \   000000D8   0110F9E5           LDRB     R1,[R9, #+1]!
   \   000000DC   000051E3           CMP      R1,#+0
   \   000000E0   DBFFFF1A           BNE      ??print_string_ptr_5
    884              output_length = (size_t)(input_pointer - input) + escape_characters;
   \                     ??print_string_ptr_4:
   \   000000E4   041049E0           SUB      R1,R9,R4
   \   000000E8   019086E0           ADD      R9,R6,R1
    885          
    886              output = ensure(output_buffer, output_length + sizeof("\"\""));
   \   000000EC   031089E2           ADD      R1,R9,#+3
   \   000000F0   ........           BL       ensure
    887              if (output == NULL)
   \   000000F4   000050E3           CMP      R0,#+0
    888              {
    889                  return false;
   \   000000F8   F083BD08           POPEQ    {R4-R9,PC}
    890              }
    891          
    892              /* no characters have to be escaped */
    893              if (escape_characters == 0)
   \   000000FC   007089E0           ADD      R7,R9,R0
   \   00000100   2280A0E3           MOV      R8,#+34
   \   00000104   000056E3           CMP      R6,#+0
   \   00000108   0080C0E5           STRB     R8,[R0, #+0]
   \   0000010C   0400001A           BNE      ??print_string_ptr_9
    894              {
    895                  output[0] = '\"';
    896                  memcpy(output + 1, input, output_length);
   \   00000110   0920A0E1           MOV      R2,R9
   \   00000114   0410A0E1           MOV      R1,R4
   \   00000118   010080E2           ADD      R0,R0,#+1
   \   0000011C   1E0100EF           SWI      +286
    897                  output[output_length + 1] = '\"';
   \   00000120   400000EA           B        ??print_string_ptr_10
    898                  output[output_length + 2] = '\0';
    899          
    900                  return true;
    901              }
    902          
    903              output[0] = '\"';
    904              output_pointer = output + 1;
   \                     ??print_string_ptr_9:
   \   00000124   016080E2           ADD      R6,R0,#+1
    905              /* copy the string */
    906              for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
   \   00000128   0490A0E1           MOV      R9,R4
   \   0000012C   0000D9E5           LDRB     R0,[R9, #+0]
   \   00000130   000050E3           CMP      R0,#+0
   \   00000134   3B00000A           BEQ      ??print_string_ptr_10
    907              {
    908                  if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
   \                     ??print_string_ptr_11:
   \   00000138   0000D9E5           LDRB     R0,[R9, #+0]
   \   0000013C   200050E3           CMP      R0,#+32
   \   00000140   0500003A           BCC      ??print_string_ptr_12
   \   00000144   220050E3           CMP      R0,#+34
   \   00000148   0300000A           BEQ      ??print_string_ptr_12
   \   0000014C   5C0050E3           CMP      R0,#+92
   \   00000150   0200000A           BEQ      ??print_string_ptr_13
    909                  {
    910                      /* normal character, copy */
    911                      *output_pointer = *input_pointer;
   \                     ??print_string_ptr_14:
   \   00000154   0000C6E5           STRB     R0,[R6, #+0]
   \   00000158   2E0000EA           B        ??print_string_ptr_15
    912                  }
    913                  else
    914                  {
    915                      /* character needs to be escaped */
    916                      *output_pointer++ = '\\';
   \                     ??print_string_ptr_12:
   \   0000015C   5C00A0E3           MOV      R0,#+92
   \                     ??print_string_ptr_13:
   \   00000160   ........           STRB     R0,[R6], #+1
    917                      switch (*input_pointer)
   \   00000164   0020D9E5           LDRB     R2,[R9, #+0]
   \   00000168   081042E2           SUB      R1,R2,#+8
   \   0000016C   540051E3           CMP      R1,#+84
   \   00000170   2400008A           BHI      ??print_string_ptr_16
   \   00000174   013F8FE2           ADR      R3,??print_string_ptr_1
   \   00000178   D13093E1           LDRSB    R3,[R3, R1]
   \   0000017C   03F18FE0           ADD      PC,PC,R3, LSL #+2
   \                     ??print_string_ptr_1:
   \   00000180   171F1B21           DC8      +23,+31,+27,+33
   \   00000184   191D2121           DC8      +25,+29,+33,+33
   \   00000188   21212121           DC8      +33,+33,+33,+33
   \   0000018C   21212121           DC8      +33,+33,+33,+33
   \   00000190   21212121           DC8      +33,+33,+33,+33
   \   00000194   21212121           DC8      +33,+33,+33,+33
   \   00000198   21211521           DC8      +33,+33,+21,+33
   \   0000019C   21212121           DC8      +33,+33,+33,+33
   \   000001A0   21212121           DC8      +33,+33,+33,+33
   \   000001A4   21212121           DC8      +33,+33,+33,+33
   \   000001A8   21212121           DC8      +33,+33,+33,+33
   \   000001AC   21212121           DC8      +33,+33,+33,+33
   \   000001B0   21212121           DC8      +33,+33,+33,+33
   \   000001B4   21212121           DC8      +33,+33,+33,+33
   \   000001B8   21212121           DC8      +33,+33,+33,+33
   \   000001BC   21212121           DC8      +33,+33,+33,+33
   \   000001C0   21212121           DC8      +33,+33,+33,+33
   \   000001C4   21212121           DC8      +33,+33,+33,+33
   \   000001C8   21212121           DC8      +33,+33,+33,+33
   \   000001CC   21212121           DC8      +33,+33,+33,+33
   \   000001D0   21212121           DC8      +33,+33,+33,+33
   \   000001D4   F4000000           DC8      +244,+0,+0,+0
    918                      {
    919                          case '\\':
    920                              *output_pointer = '\\';
    921                              break;
    922                          case '\"':
    923                              *output_pointer = '\"';
   \                     ??print_string_ptr_17:
   \   000001D8   0080C6E5           STRB     R8,[R6, #+0]
   \   000001DC   0D0000EA           B        ??print_string_ptr_15
    924                              break;
    925                          case '\b':
    926                              *output_pointer = 'b';
   \                     ??print_string_ptr_18:
   \   000001E0   6200A0E3           MOV      R0,#+98
   \   000001E4   DAFFFFEA           B        ??print_string_ptr_14
    927                              break;
    928                          case '\f':
    929                              *output_pointer = 'f';
   \                     ??print_string_ptr_19:
   \   000001E8   6600A0E3           MOV      R0,#+102
   \                     ??print_string_ptr_20:
   \   000001EC   D8FFFFEA           B        ??print_string_ptr_14
    930                              break;
    931                          case '\n':
    932                              *output_pointer = 'n';
   \                     ??print_string_ptr_21:
   \   000001F0   6E00A0E3           MOV      R0,#+110
   \   000001F4   D6FFFFEA           B        ??print_string_ptr_14
    933                              break;
    934                          case '\r':
    935                              *output_pointer = 'r';
   \                     ??print_string_ptr_22:
   \   000001F8   7200A0E3           MOV      R0,#+114
   \   000001FC   D4FFFFEA           B        ??print_string_ptr_14
    936                              break;
    937                          case '\t':
    938                              *output_pointer = 't';
   \                     ??print_string_ptr_23:
   \   00000200   7400A0E3           MOV      R0,#+116
   \   00000204   D2FFFFEA           B        ??print_string_ptr_14
    939                              break;
    940                          default:
    941                              /* escape and print as unicode codepoint */
    942                              sprintf((char*)output_pointer, "u%04x", *input_pointer);
   \                     ??print_string_ptr_16:
   \   00000208   2C109FE5           LDR      R1,??print_string_ptr_3+0x4  ;; `?<Constant "u%04x">`
   \   0000020C   0600A0E1           MOV      R0,R6
   \   00000210   160000EF           SWI      +22
    943                              output_pointer += 4;
   \   00000214   046086E2           ADD      R6,R6,#+4
    944                              break;
    945                      }
    946                  }
    947              }
   \                     ??print_string_ptr_15:
   \   00000218   0100F9E5           LDRB     R0,[R9, #+1]!
   \   0000021C   016086E2           ADD      R6,R6,#+1
   \   00000220   000050E3           CMP      R0,#+0
   \   00000224   C3FFFF1A           BNE      ??print_string_ptr_11
    948              output[output_length + 1] = '\"';
   \                     ??print_string_ptr_10:
   \   00000228   0180C7E5           STRB     R8,[R7, #+1]
    949              output[output_length + 2] = '\0';
   \   0000022C   0250C7E5           STRB     R5,[R7, #+2]
    950          
    951              return true;
   \   00000230   0100A0E3           MOV      R0,#+1
   \   00000234   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??print_string_ptr_3:
   \   00000238   22220000           DC8      "\"\"",+0
   \   0000023C   ........           DC32     `?<Constant "u%04x">`
    952          }
    953          
    954          /* Invoke print_string_ptr (which is useful) on an item. */
    955          static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
    956          {
    957              return print_string_ptr((unsigned char*)item->valuestring, p);
    958          }
    959          
    960          /* Predeclare these prototypes. */
    961          static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
    962          static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
    963          static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
    964          static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
    965          static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
    966          static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
    967          
    968          /* Utility to jump whitespace and cr/lf */

   \                                 In segment CODE, align 4, keep-with-next
    969          static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
    970          {
    971              if ((buffer == NULL) || (buffer->content == NULL))
   \                     buffer_skip_whitespace:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1EFF2F01           BXEQ     LR
   \   00000008   001090E5           LDR      R1,[R0, #+0]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0600001A           BNE      ??buffer_skip_whitespace_0
    972              {
    973                  return NULL;
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   1EFF2FE1           BX       LR
    974              }
   \                     ??buffer_skip_whitespace_1:
   \   0000001C   0130D2E7           LDRB     R3,[R2, +R1]
   \   00000020   210053E3           CMP      R3,#+33
   \   00000024   1EFF2F21           BXCS     LR
    975          
    976              while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
    977              {
    978                 buffer->offset++;
   \   00000028   012082E2           ADD      R2,R2,#+1
   \   0000002C   082080E5           STR      R2,[R0, #+8]
   \                     ??buffer_skip_whitespace_0:
   \   00000030   043090E5           LDR      R3,[R0, #+4]
   \   00000034   082090E5           LDR      R2,[R0, #+8]
   \   00000038   030052E1           CMP      R2,R3
   \   0000003C   F6FFFF3A           BCC      ??buffer_skip_whitespace_1
    979              }
    980          
    981              if (buffer->offset == buffer->length)
    982              {
    983                  buffer->offset--;
   \   00000040   01104202           SUBEQ    R1,R2,#+1
   \   00000044   08108005           STREQ    R1,[R0, #+8]
    984              }
    985          
    986              return buffer;
   \   00000048   1EFF2FE1           BX       LR               ;; return
    987          }
    988          
    989          /* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
    990          static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
    991          {
    992              if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
    993              {
    994                  return NULL;
    995              }
    996          
    997              if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
    998              {
    999                  buffer->offset += 3;
   1000              }
   1001          
   1002              return buffer;
   1003          }
   1004          
   1005          /* Parse an object - create a new root, and populate. */

   \                                 In segment CODE, align 4, keep-with-next
   1006          CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
   1007          {
   \                     cJSON_ParseWithOpts:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0280A0E1           MOV      R8,R2
   1008              parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0130A0E1           MOV      R3,R1
   \   00000024   0160A0E1           MOV      R6,R1
   \   00000028   4E00A0E8           STM      R0!,{R1-R3,R6}
   1009              cJSON *item = NULL;
   1010          
   1011              /* reset error position */
   1012              global_error.json = NULL;
   \   0000002C   ........           LDR      R6,??DataTable8  ;; global_hooks
   \   00000030   0E0080E8           STM      R0,{R1-R3}
   \   00000034   0170A0E1           MOV      R7,R1
   \   00000038   0C7086E5           STR      R7,[R6, #+12]
   1013              global_error.position = 0;
   \   0000003C   107086E5           STR      R7,[R6, #+16]
   1014          
   1015              if (value == NULL)
   \   00000040   000054E3           CMP      R4,#+0
   \   00000044   4900000A           BEQ      ??cJSON_ParseWithOpts_0
   1016              {
   1017                  goto fail;
   1018              }
   1019          
   1020              buffer.content = (const unsigned char*)value;
   \   00000048   00408DE5           STR      R4,[SP, #+0]
   1021              buffer.length = strlen((const char*)value) + sizeof("");
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   1B0000EF           SWI      +27
   \   00000054   010080E2           ADD      R0,R0,#+1
   \   00000058   04008DE5           STR      R0,[SP, #+4]
   1022              buffer.offset = 0;
   \   0000005C   08708DE5           STR      R7,[SP, #+8]
   1023              buffer.hooks = global_hooks;
   \   00000060   0C0296E8           LDM      R6,{R2,R3,R9}
   \   00000064   10008DE2           ADD      R0,SP,#+16
   \   00000068   0C0280E8           STM      R0,{R2,R3,R9}
   1024          
   1025              item = cJSON_New_Item(&global_hooks);
   \   0000006C   0600A0E1           MOV      R0,R6
   \   00000070   ........           BL       cJSON_New_Item
   \   00000074   0090B0E1           MOVS     R9,R0
   1026              if (item == NULL) /* memory fail */
   \   00000078   3000000A           BEQ      ??cJSON_ParseWithOpts_1
   1027              {
   1028                  goto fail;
   1029              }
   1030          
   1031              if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
   \   0000007C   00009DE5           LDR      R0,[SP, #+0]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0200000A           BEQ      ??cJSON_ParseWithOpts_2
   \   00000088   08009DE5           LDR      R0,[SP, #+8]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0100000A           BEQ      ??cJSON_ParseWithOpts_3
   \                     ??cJSON_ParseWithOpts_2:
   \   00000094   0000A0E3           MOV      R0,#+0
   \   00000098   0B0000EA           B        ??cJSON_ParseWithOpts_4
   \                     ??cJSON_ParseWithOpts_3:
   \   0000009C   04009DE5           LDR      R0,[SP, #+4]
   \   000000A0   050050E3           CMP      R0,#+5
   \   000000A4   0700003A           BCC      ??cJSON_ParseWithOpts_5
   \   000000A8   00009DE5           LDR      R0,[SP, #+0]
   \   000000AC   0320A0E3           MOV      R2,#+3
   \   000000B0   311F8FE2           ADR      R1,??cJSON_ParseWithOpts_6  ;; ""
   \   000000B4   150100EF           SWI      +277
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   08109D05           LDREQ    R1,[SP, #+8]
   \   000000C0   03108102           ADDEQ    R1,R1,#+3
   \   000000C4   08108D05           STREQ    R1,[SP, #+8]
   \                     ??cJSON_ParseWithOpts_5:
   \   000000C8   0D00A0E1           MOV      R0,SP
   \                     ??cJSON_ParseWithOpts_4:
   \   000000CC   ........           BL       buffer_skip_whitespace
   \   000000D0   0010A0E1           MOV      R1,R0
   \   000000D4   0900A0E1           MOV      R0,R9
   \   000000D8   ........           BL       parse_value
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   1400000A           BEQ      ??cJSON_ParseWithOpts_7
   1032              {
   1033                  /* parse failure. ep is set. */
   1034                  goto fail;
   1035              }
   1036          
   1037              /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
   1038              if (require_null_terminated)
   \   000000E4   000058E3           CMP      R8,#+0
   \   000000E8   0900000A           BEQ      ??cJSON_ParseWithOpts_8
   1039              {
   1040                  buffer_skip_whitespace(&buffer);
   \   000000EC   0D00A0E1           MOV      R0,SP
   \   000000F0   ........           BL       buffer_skip_whitespace
   1041                  if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
   \   000000F4   08009DE5           LDR      R0,[SP, #+8]
   \   000000F8   04109DE5           LDR      R1,[SP, #+4]
   \   000000FC   010050E1           CMP      R0,R1
   \   00000100   0C00002A           BCS      ??cJSON_ParseWithOpts_7
   \   00000104   00109DE5           LDR      R1,[SP, #+0]
   \   00000108   0100D0E7           LDRB     R0,[R0, +R1]
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0800001A           BNE      ??cJSON_ParseWithOpts_7
   1042                  {
   1043                      goto fail;
   1044                  }
   1045              }
   1046              if (return_parse_end)
   \                     ??cJSON_ParseWithOpts_8:
   \   00000114   000055E3           CMP      R5,#+0
   \   00000118   0300000A           BEQ      ??cJSON_ParseWithOpts_9
   1047              {
   1048                  *return_parse_end = (const char*)buffer_at_offset(&buffer);
   \   0000011C   08009DE5           LDR      R0,[SP, #+8]
   \   00000120   00109DE5           LDR      R1,[SP, #+0]
   \   00000124   010080E0           ADD      R0,R0,R1
   \   00000128   000085E5           STR      R0,[R5, #+0]
   1049              }
   1050          
   1051              return item;
   \                     ??cJSON_ParseWithOpts_9:
   \   0000012C   0900A0E1           MOV      R0,R9
   \   00000130   1CD08DE2           ADD      SP,SP,#+28
   \   00000134   F083BDE8           POP      {R4-R9,PC}
   1052          
   1053          fail:
   1054              if (item != NULL)
   1055              {
   1056                  cJSON_Delete(item);
   \                     ??cJSON_ParseWithOpts_7:
   \   00000138   0900A0E1           MOV      R0,R9
   \   0000013C   ........           BL       cJSON_Delete
   1057              }
   1058          
   1059              if (value != NULL)
   1060              {
   1061                  error local_error;
   1062                  local_error.json = (const unsigned char*)value;
   1063                  local_error.position = 0;
   1064          
   1065                  if (buffer.offset < buffer.length)
   \                     ??cJSON_ParseWithOpts_1:
   \   00000140   04009DE5           LDR      R0,[SP, #+4]
   \   00000144   08109DE5           LDR      R1,[SP, #+8]
   \   00000148   000051E1           CMP      R1,R0
   1066                  {
   1067                      local_error.position = buffer.offset;
   \   0000014C   0170A031           MOVCC    R7,R1
   \   00000150   0100003A           BCC      ??cJSON_ParseWithOpts_10
   1068                  }
   1069                  else if (buffer.length > 0)
   \   00000154   000050E3           CMP      R0,#+0
   1070                  {
   1071                      local_error.position = buffer.length - 1;
   \   00000158   01704012           SUBNE    R7,R0,#+1
   1072                  }
   1073          
   1074                  if (return_parse_end != NULL)
   \                     ??cJSON_ParseWithOpts_10:
   \   0000015C   000055E3           CMP      R5,#+0
   1075                  {
   1076                      *return_parse_end = (const char*)local_error.json + local_error.position;
   \   00000160   04008710           ADDNE    R0,R7,R4
   \   00000164   00008515           STRNE    R0,[R5, #+0]
   1077                  }
   1078          
   1079                  global_error = local_error;
   \   00000168   0C4086E5           STR      R4,[R6, #+12]
   \   0000016C   107086E5           STR      R7,[R6, #+16]
   1080              }
   1081          
   1082              return NULL;
   \                     ??cJSON_ParseWithOpts_0:
   \   00000170   0000A0E3           MOV      R0,#+0
   \   00000174   1CD08DE2           ADD      SP,SP,#+28
   \   00000178   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??cJSON_ParseWithOpts_6:
   \   0000017C   EFBBBF00           DC8      ""
   1083          }
   1084          
   1085          /* Default options for cJSON_Parse */

   \                                 In segment CODE, align 4, keep-with-next
   1086          CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
   1087          {
   1088              return cJSON_ParseWithOpts(value, 0, 0);
   \                     cJSON_Parse:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   ........           B        cJSON_ParseWithOpts  ;; tailcall
   1089          }
   1090          
   1091          #define cjson_min(a, b) ((a < b) ? a : b)
   1092          

   \                                 In segment CODE, align 4, keep-with-next
   1093          static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
   1094          {
   \                     print:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0180A0E1           MOV      R8,R1
   \   00000010   0240A0E1           MOV      R4,R2
   1095              static const size_t default_buffer_size = 256;
   1096              printbuffer buffer[1];
   1097              unsigned char *printed = NULL;
   \   00000014   0050A0E3           MOV      R5,#+0
   1098          
   1099              memset(buffer, 0, sizeof(buffer));
   \   00000018   2420A0E3           MOV      R2,#+36
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   BB0000EF           SWI      +187
   1100          
   1101              /* create buffer */
   1102              buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
   \   00000028   001094E5           LDR      R1,[R4, #+0]
   \   0000002C   400FA0E3           MOV      R0,#+256
   \   00000030   31FF2FE1           BLX      R1
   \   00000034   00008DE5           STR      R0,[SP, #+0]
   1103              buffer->length = default_buffer_size;
   \   00000038   401FA0E3           MOV      R1,#+256
   \   0000003C   04108DE5           STR      R1,[SP, #+4]
   1104              buffer->format = format;
   \   00000040   14808DE5           STR      R8,[SP, #+20]
   1105              buffer->hooks = *hooks;
   \   00000044   0C0194E8           LDM      R4,{R2,R3,R8}
   \   00000048   18008DE2           ADD      R0,SP,#+24
   \   0000004C   0C0180E8           STM      R0,{R2,R3,R8}
   1106              if (buffer->buffer == NULL)
   \   00000050   00009DE5           LDR      R0,[SP, #+0]
   \   00000054   0060A0E3           MOV      R6,#+0
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0F00000A           BEQ      ??print_0
   1107              {
   1108                  goto fail;
   1109              }
   1110          
   1111              /* print the value */
   1112              if (!print_value(item, buffer))
   \   00000060   0D10A0E1           MOV      R1,SP
   \   00000064   0700A0E1           MOV      R0,R7
   \   00000068   ........           BL       print_value
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0A00000A           BEQ      ??print_0
   1113              {
   1114                  goto fail;
   1115              }
   1116              update_offset(buffer);
   \   00000074   0D00A0E1           MOV      R0,SP
   \   00000078   ........           BL       update_offset
   1117          
   1118              /* check if reallocate is available */
   1119              if (hooks->reallocate != NULL)
   \   0000007C   082094E5           LDR      R2,[R4, #+8]
   \   00000080   08009DE5           LDR      R0,[SP, #+8]
   \   00000084   000052E3           CMP      R2,#+0
   \   00000088   1100000A           BEQ      ??print_1
   1120              {
   1121                  printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
   \   0000008C   011080E2           ADD      R1,R0,#+1
   \   00000090   00009DE5           LDR      R0,[SP, #+0]
   \   00000094   32FF2FE1           BLX      R2
   \   00000098   0060B0E1           MOVS     R6,R0
   1122                  if (printed == NULL) {
   \   0000009C   1E00001A           BNE      ??print_2
   1123                      goto fail;
   1124                  }
   1125                  buffer->buffer = NULL;
   1126              }
   1127              else /* otherwise copy the JSON over to a new buffer */
   1128              {
   1129                  printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
   1130                  if (printed == NULL)
   1131                  {
   1132                      goto fail;
   1133                  }
   1134                  memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
   1135                  printed[buffer->offset] = '\0'; /* just to be sure */
   1136          
   1137                  /* free the buffer */
   1138                  hooks->deallocate(buffer->buffer);
   1139              }
   1140          
   1141              return printed;
   1142          
   1143          fail:
   1144              if (buffer->buffer != NULL)
   \                     ??print_0:
   \   000000A0   00009DE5           LDR      R0,[SP, #+0]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0100000A           BEQ      ??print_3
   1145              {
   1146                  hooks->deallocate(buffer->buffer);
   \   000000AC   041094E5           LDR      R1,[R4, #+4]
   \   000000B0   31FF2FE1           BLX      R1
   1147              }
   1148          
   1149              if (printed != NULL)
   \                     ??print_3:
   \   000000B4   000056E3           CMP      R6,#+0
   \   000000B8   0200000A           BEQ      ??print_4
   1150              {
   1151                  hooks->deallocate(printed);
   \   000000BC   041094E5           LDR      R1,[R4, #+4]
   \   000000C0   0600A0E1           MOV      R0,R6
   \   000000C4   31FF2FE1           BLX      R1
   1152              }
   1153          
   1154              return NULL;
   \                     ??print_4:
   \   000000C8   0000A0E3           MOV      R0,#+0
   \   000000CC   24D08DE2           ADD      SP,SP,#+36
   \   000000D0   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??print_1:
   \   000000D4   001094E5           LDR      R1,[R4, #+0]
   \   000000D8   010080E2           ADD      R0,R0,#+1
   \   000000DC   31FF2FE1           BLX      R1
   \   000000E0   0060B0E1           MOVS     R6,R0
   \   000000E4   EDFFFF0A           BEQ      ??print_0
   \   000000E8   08009DE5           LDR      R0,[SP, #+8]
   \   000000EC   00109DE5           LDR      R1,[SP, #+0]
   \   000000F0   012080E2           ADD      R2,R0,#+1
   \   000000F4   04009DE5           LDR      R0,[SP, #+4]
   \   000000F8   020050E1           CMP      R0,R2
   \   000000FC   0020A031           MOVCC    R2,R0
   \   00000100   0600A0E1           MOV      R0,R6
   \   00000104   1E0100EF           SWI      +286
   \   00000108   08009DE5           LDR      R0,[SP, #+8]
   \   0000010C   0650C0E7           STRB     R5,[R0, +R6]
   \   00000110   00009DE5           LDR      R0,[SP, #+0]
   \   00000114   041094E5           LDR      R1,[R4, #+4]
   \   00000118   31FF2FE1           BLX      R1
   \                     ??print_2:
   \   0000011C   0600A0E1           MOV      R0,R6
   \   00000120   24D08DE2           ADD      SP,SP,#+36
   \   00000124   F081BDE8           POP      {R4-R8,PC}
   1155          }
   1156          
   1157          /* Render a cJSON item/entity/structure to text. */

   \                                 In segment CODE, align 4, keep-with-next
   1158          CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
   1159          {
   1160              return (char*)print(item, true, &global_hooks);
   \                     cJSON_Print:
   \   00000000   ........           LDR      R2,??DataTable8  ;; global_hooks
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   ........           B        print            ;; tailcall
   1161          }
   1162          

   \                                 In segment CODE, align 4, keep-with-next
   1163          CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
   1164          {
   1165              return (char*)print(item, false, &global_hooks);
   \                     cJSON_PrintUnformatted:
   \   00000000   ........           LDR      R2,??DataTable8  ;; global_hooks
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   ........           B        print            ;; tailcall
   1166          }
   1167          

   \                                 In segment CODE, align 4, keep-with-next
   1168          CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
   1169          {
   \                     cJSON_PrintBuffered:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0250A0E1           MOV      R5,R2
   1170              printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0130A0E1           MOV      R3,R1
   \   00000024   0E00A0E8           STM      R0!,{R1-R3}
   \   00000028   0E00A0E8           STM      R0!,{R1-R3}
   \   0000002C   0E0080E8           STM      R0,{R1-R3}
   1171          
   1172              if (prebuffer < 0)
   \   00000030   000056E3           CMP      R6,#+0
   1173              {
   1174                  return NULL;
   \   00000034   0000A043           MOVMI    R0,#+0
   \   00000038   1700004A           BMI      ??cJSON_PrintBuffered_0
   1175              }
   1176          
   1177              p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
   \   0000003C   ........           LDR      R7,??DataTable8  ;; global_hooks
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   001097E5           LDR      R1,[R7, #+0]
   \   00000048   31FF2FE1           BLX      R1
   \   0000004C   00008DE5           STR      R0,[SP, #+0]
   1178              if (!p.buffer)
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   1000000A           BEQ      ??cJSON_PrintBuffered_0
   1179              {
   1180                  return NULL;
   1181              }
   1182          
   1183              p.length = (size_t)prebuffer;
   \   00000058   04608DE5           STR      R6,[SP, #+4]
   1184              p.offset = 0;
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   08008DE5           STR      R0,[SP, #+8]
   1185              p.noalloc = false;
   \   00000064   10008DE5           STR      R0,[SP, #+16]
   1186              p.format = fmt;
   \   00000068   14508DE5           STR      R5,[SP, #+20]
   1187              p.hooks = global_hooks;
   \   0000006C   2C0097E8           LDM      R7,{R2,R3,R5}
   \   00000070   18008DE2           ADD      R0,SP,#+24
   \   00000074   2C0080E8           STM      R0,{R2,R3,R5}
   1188          
   1189              if (!print_value(item, &p))
   \   00000078   0D10A0E1           MOV      R1,SP
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   ........           BL       print_value
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   00009DE5           LDR      R0,[SP, #+0]
   \   0000008C   0200001A           BNE      ??cJSON_PrintBuffered_0
   1190              {
   1191                  global_hooks.deallocate(p.buffer);
   \   00000090   041097E5           LDR      R1,[R7, #+4]
   \   00000094   31FF2FE1           BLX      R1
   1192                  return NULL;
   \   00000098   0000A0E3           MOV      R0,#+0
   1193              }
   1194          
   1195              return (char*)p.buffer;
   \                     ??cJSON_PrintBuffered_0:
   \   0000009C   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   000000A0   F080BDE8           POP      {R4-R7,PC}       ;; return
   1196          }
   1197          

   \                                 In segment CODE, align 4, keep-with-next
   1198          CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)
   1199          {
   \                     cJSON_PrintPreallocated:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   1200              printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
   \   00000008   0DC0A0E1           MOV      R12,SP
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0050A0E3           MOV      R5,#+0
   \   00000014   0460A0E1           MOV      R6,R4
   \   00000018   7000ACE8           STM      R12!,{R4-R6}
   \   0000001C   7000ACE8           STM      R12!,{R4-R6}
   \   00000020   70008CE8           STM      R12,{R4-R6}
   1201          
   1202              if ((len < 0) || (buf == NULL))
   \   00000024   000052E3           CMP      R2,#+0
   \   00000028   0100004A           BMI      ??cJSON_PrintPreallocated_0
   \   0000002C   000051E3           CMP      R1,#+0
   \   00000030   0200001A           BNE      ??cJSON_PrintPreallocated_1
   1203              {
   1204                  return false;
   \                     ??cJSON_PrintPreallocated_0:
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   24D08DE2           ADD      SP,SP,#+36
   \   0000003C   7080BDE8           POP      {R4-R6,PC}
   1205              }
   1206          
   1207              p.buffer = (unsigned char*)buf;
   1208              p.length = (size_t)len;
   \                     ??cJSON_PrintPreallocated_1:
   \   00000040   04208DE5           STR      R2,[SP, #+4]
   1209              p.offset = 0;
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   08208DE5           STR      R2,[SP, #+8]
   1210              p.noalloc = true;
   \   0000004C   0120A0E3           MOV      R2,#+1
   \   00000050   10208DE5           STR      R2,[SP, #+16]
   1211              p.format = fmt;
   1212              p.hooks = global_hooks;
   \   00000054   ........           LDR      R2,??DataTable8  ;; global_hooks
   \   00000058   00108DE5           STR      R1,[SP, #+0]
   \   0000005C   14308DE5           STR      R3,[SP, #+20]
   \   00000060   380092E8           LDM      R2,{R3-R5}
   \   00000064   18108DE2           ADD      R1,SP,#+24
   \   00000068   380081E8           STM      R1,{R3-R5}
   1213          
   1214              return print_value(item, &p);
   \   0000006C   0D10A0E1           MOV      R1,SP
   \   00000070   ........           BL       print_value
   \   00000074   24D08DE2           ADD      SP,SP,#+36
   \   00000078   7080BDE8           POP      {R4-R6,PC}       ;; return
   1215          }
   1216          
   1217          /* Parser core - when encountering text, process appropriately. */

   \                                 In segment CODE, align 4, keep-with-next
   1218          static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
   1219          {
   \                     parse_value:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   1220              if ((input_buffer == NULL) || (input_buffer->content == NULL))
   \   0000000C   00009515           LDRNE    R0,[R5, #+0]
   \   00000010   00005013           CMPNE    R0,#+0
   \   00000014   0100001A           BNE      ??parse_value_0
   1221              {
   1222                  return false; /* no input */
   \                     ??parse_value_1:
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   F080BDE8           POP      {R4-R7,PC}
   1223              }
   \                     ??parse_value_0:
   \   00000020   083095E5           LDR      R3,[R5, #+8]
   \   00000024   041095E5           LDR      R1,[R5, #+4]
   \   00000028   ........           LDR      R6,??DataTable9  ;; `?<Constant "null">`
   \   0000002C   042083E2           ADD      R2,R3,#+4
   \   00000030   020051E1           CMP      R1,R2
   \   00000034   0800003A           BCC      ??parse_value_2
   \   00000038   0420A0E3           MOV      R2,#+4
   \   0000003C   0610A0E1           MOV      R1,R6
   \   00000040   000083E0           ADD      R0,R3,R0
   \   00000044   150100EF           SWI      +277
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0200001A           BNE      ??parse_value_2
   1224          
   1225              /* parse the different types of values */
   1226              /* null */
   1227              if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
   1228              {
   1229                  item->type = cJSON_NULL;
   \   00000050   0400A0E3           MOV      R0,#+4
   \   00000054   0C0084E5           STR      R0,[R4, #+12]
   1230                  input_buffer->offset += 4;
   \   00000058   210000EA           B        ??parse_value_3
   1231                  return true;
   1232              }
   \                     ??parse_value_2:
   \   0000005C   080095E5           LDR      R0,[R5, #+8]
   \   00000060   041095E5           LDR      R1,[R5, #+4]
   \   00000064   0170A0E3           MOV      R7,#+1
   \   00000068   052080E2           ADD      R2,R0,#+5
   \   0000006C   020051E1           CMP      R1,R2
   \   00000070   0C00003A           BCC      ??parse_value_4
   \   00000074   003095E5           LDR      R3,[R5, #+0]
   \   00000078   0520A0E3           MOV      R2,#+5
   \   0000007C   081086E2           ADD      R1,R6,#+8
   \   00000080   030080E0           ADD      R0,R0,R3
   \   00000084   150100EF           SWI      +277
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   0500001A           BNE      ??parse_value_4
   1233              /* false */
   1234              if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
   1235              {
   1236                  item->type = cJSON_False;
   \   00000090   0C7084E5           STR      R7,[R4, #+12]
   1237                  input_buffer->offset += 5;
   \   00000094   080095E5           LDR      R0,[R5, #+8]
   \   00000098   050080E2           ADD      R0,R0,#+5
   \   0000009C   080085E5           STR      R0,[R5, #+8]
   \   000000A0   0100A0E3           MOV      R0,#+1
   \   000000A4   F080BDE8           POP      {R4-R7,PC}
   1238                  return true;
   1239              }
   \                     ??parse_value_4:
   \   000000A8   080095E5           LDR      R0,[R5, #+8]
   \   000000AC   041095E5           LDR      R1,[R5, #+4]
   \   000000B0   042080E2           ADD      R2,R0,#+4
   \   000000B4   020051E1           CMP      R1,R2
   \   000000B8   0E00003A           BCC      ??parse_value_5
   \   000000BC   003095E5           LDR      R3,[R5, #+0]
   \   000000C0   0420A0E3           MOV      R2,#+4
   \   000000C4   101086E2           ADD      R1,R6,#+16
   \   000000C8   030080E0           ADD      R0,R0,R3
   \   000000CC   150100EF           SWI      +277
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   0700001A           BNE      ??parse_value_5
   1240              /* true */
   1241              if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
   1242              {
   1243                  item->type = cJSON_True;
   \   000000D8   0200A0E3           MOV      R0,#+2
   \   000000DC   0C0084E5           STR      R0,[R4, #+12]
   1244                  item->valueint = 1;
   \   000000E0   147084E5           STR      R7,[R4, #+20]
   1245                  input_buffer->offset += 4;
   \                     ??parse_value_3:
   \   000000E4   080095E5           LDR      R0,[R5, #+8]
   \   000000E8   040080E2           ADD      R0,R0,#+4
   \   000000EC   080085E5           STR      R0,[R5, #+8]
   1246                  return true;
   \   000000F0   0100A0E3           MOV      R0,#+1
   \   000000F4   F080BDE8           POP      {R4-R7,PC}
   1247              }
   \                     ??parse_value_5:
   \   000000F8   080095E5           LDR      R0,[R5, #+8]
   \   000000FC   041095E5           LDR      R1,[R5, #+4]
   \   00000100   010050E1           CMP      R0,R1
   \   00000104   C3FFFF2A           BCS      ??parse_value_1
   \   00000108   001095E5           LDR      R1,[R5, #+0]
   \   0000010C   010080E0           ADD      R0,R0,R1
   \   00000110   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000114   220051E3           CMP      R1,#+34
   \   00000118   0300001A           BNE      ??parse_value_6
   1248              /* string */
   1249              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
   1250              {
   1251                  return parse_string(item, input_buffer);
   \   0000011C   0510A0E1           MOV      R1,R5
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       parse_string
   \   00000128   F080BDE8           POP      {R4-R7,PC}
   1252              }
   \                     ??parse_value_6:
   \   0000012C   2D0051E3           CMP      R1,#+45
   \   00000130   0300000A           BEQ      ??parse_value_7
   \   00000134   300051E3           CMP      R1,#+48
   \   00000138   0500003A           BCC      ??parse_value_8
   \   0000013C   3A0051E3           CMP      R1,#+58
   \   00000140   0300002A           BCS      ??parse_value_8
   1253              /* number */
   1254              if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
   1255              {
   1256                  return parse_number(item, input_buffer);
   \                     ??parse_value_7:
   \   00000144   0510A0E1           MOV      R1,R5
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       parse_number
   \   00000150   F080BDE8           POP      {R4-R7,PC}
   1257              }
   \                     ??parse_value_8:
   \   00000154   5B0051E3           CMP      R1,#+91
   \   00000158   0300001A           BNE      ??parse_value_9
   1258              /* array */
   1259              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
   1260              {
   1261                  return parse_array(item, input_buffer);
   \   0000015C   0510A0E1           MOV      R1,R5
   \   00000160   0400A0E1           MOV      R0,R4
   \   00000164   ........           BL       parse_array
   \   00000168   F080BDE8           POP      {R4-R7,PC}
   1262              }
   \                     ??parse_value_9:
   \   0000016C   7B0051E3           CMP      R1,#+123
   \   00000170   A8FFFF1A           BNE      ??parse_value_1
   1263              /* object */
   1264              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
   1265              {
   1266                  return parse_object(item, input_buffer);
   \   00000174   0510A0E1           MOV      R1,R5
   \   00000178   0400A0E1           MOV      R0,R4
   \   0000017C   ........           BL       parse_object
   \   00000180   F080BDE8           POP      {R4-R7,PC}       ;; return
   1267              }
   1268          
   1269              return false;
   1270          }
   1271          
   1272          /* Render a value to text. */

   \                                 In segment CODE, align 4, keep-with-next
   1273          static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
   1274          {
   \                     print_value:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1275              unsigned char *output = NULL;
   1276          
   1277              if ((item == NULL) || (output_buffer == NULL))
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00005513           CMPNE    R5,#+0
   \   00000014   5E00000A           BEQ      ??print_value_1
   1278              {
   1279                  return false;
   1280              }
   1281          
   1282              switch ((item->type) & 0xFF)
   \   00000018   0C1094E5           LDR      R1,[R4, #+12]
   \   0000001C   100094E5           LDR      R0,[R4, #+16]
   \   00000020   ........           LDR      R6,??DataTable10  ;; `?<Constant "null">`
   \   00000024   FF1001E2           AND      R1,R1,#0xFF
   \   00000028   011041E2           SUB      R1,R1,#+1
   \   0000002C   7F0051E3           CMP      R1,#+127
   \   00000030   5700008A           BHI      ??print_value_1
   \   00000034   012F8FE2           ADR      R2,??print_value_0
   \   00000038   0120D2E7           LDRB     R2,[R2, R1]
   \   0000003C   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??print_value_0:
   \   00000040   262F541F           DC8      +38,+47,+84,+31
   \   00000044   54545438           DC8      +84,+84,+84,+56
   \   00000048   54545454           DC8      +84,+84,+84,+84
   \   0000004C   54545449           DC8      +84,+84,+84,+73
   \   00000050   54545454           DC8      +84,+84,+84,+84
   \   00000054   54545454           DC8      +84,+84,+84,+84
   \   00000058   54545454           DC8      +84,+84,+84,+84
   \   0000005C   5454544C           DC8      +84,+84,+84,+76
   \   00000060   54545454           DC8      +84,+84,+84,+84
   \   00000064   54545454           DC8      +84,+84,+84,+84
   \   00000068   54545454           DC8      +84,+84,+84,+84
   \   0000006C   54545454           DC8      +84,+84,+84,+84
   \   00000070   54545454           DC8      +84,+84,+84,+84
   \   00000074   54545454           DC8      +84,+84,+84,+84
   \   00000078   54545454           DC8      +84,+84,+84,+84
   \   0000007C   54545450           DC8      +84,+84,+84,+80
   \   00000080   54545454           DC8      +84,+84,+84,+84
   \   00000084   54545454           DC8      +84,+84,+84,+84
   \   00000088   54545454           DC8      +84,+84,+84,+84
   \   0000008C   54545454           DC8      +84,+84,+84,+84
   \   00000090   54545454           DC8      +84,+84,+84,+84
   \   00000094   54545454           DC8      +84,+84,+84,+84
   \   00000098   54545454           DC8      +84,+84,+84,+84
   \   0000009C   54545454           DC8      +84,+84,+84,+84
   \   000000A0   54545454           DC8      +84,+84,+84,+84
   \   000000A4   54545454           DC8      +84,+84,+84,+84
   \   000000A8   54545454           DC8      +84,+84,+84,+84
   \   000000AC   54545454           DC8      +84,+84,+84,+84
   \   000000B0   54545454           DC8      +84,+84,+84,+84
   \   000000B4   54545454           DC8      +84,+84,+84,+84
   \   000000B8   54545454           DC8      +84,+84,+84,+84
   \   000000BC   5454543C           DC8      +84,+84,+84,+60
   1283              {
   1284                  case cJSON_NULL:
   1285                      output = ensure(output_buffer, 5);
   \                     ??print_value_2:
   \   000000C0   0510A0E3           MOV      R1,#+5
   \   000000C4   0500A0E1           MOV      R0,R5
   \   000000C8   ........           BL       ensure
   1286                      if (output == NULL)
   \   000000CC   000050E3           CMP      R0,#+0
   1287                      {
   1288                          return false;
   \   000000D0   7080BD08           POPEQ    {R4-R6,PC}
   1289                      }
   1290                      strcpy((char*)output, "null");
   \   000000D4   0610A0E1           MOV      R1,R6
   \   000000D8   0E0000EA           B        ??print_value_3
   1291                      return true;
   1292          
   1293                  case cJSON_False:
   1294                      output = ensure(output_buffer, 6);
   \                     ??print_value_4:
   \   000000DC   0610A0E3           MOV      R1,#+6
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   ........           BL       ensure
   1295                      if (output == NULL)
   \   000000E8   000050E3           CMP      R0,#+0
   1296                      {
   1297                          return false;
   \   000000EC   7080BD08           POPEQ    {R4-R6,PC}
   1298                      }
   1299                      strcpy((char*)output, "false");
   \   000000F0   081086E2           ADD      R1,R6,#+8
   \   000000F4   1A0000EF           SWI      +26
   1300                      return true;
   \   000000F8   0100A0E3           MOV      R0,#+1
   \   000000FC   7080BDE8           POP      {R4-R6,PC}
   1301          
   1302                  case cJSON_True:
   1303                      output = ensure(output_buffer, 5);
   \                     ??print_value_5:
   \   00000100   0510A0E3           MOV      R1,#+5
   \   00000104   0500A0E1           MOV      R0,R5
   \   00000108   ........           BL       ensure
   1304                      if (output == NULL)
   \   0000010C   000050E3           CMP      R0,#+0
   1305                      {
   1306                          return false;
   \   00000110   7080BD08           POPEQ    {R4-R6,PC}
   1307                      }
   1308                      strcpy((char*)output, "true");
   \   00000114   101086E2           ADD      R1,R6,#+16
   \                     ??print_value_3:
   \   00000118   1A0000EF           SWI      +26
   \                     ??print_value_6:
   \   0000011C   0100A0E3           MOV      R0,#+1
   \   00000120   7080BDE8           POP      {R4-R6,PC}
   1309                      return true;
   1310          
   1311                  case cJSON_Number:
   1312                      return print_number(item, output_buffer);
   \                     ??print_value_7:
   \   00000124   0510A0E1           MOV      R1,R5
   \   00000128   0400A0E1           MOV      R0,R4
   \   0000012C   ........           BL       print_number
   \   00000130   7080BDE8           POP      {R4-R6,PC}
   1313          
   1314                  case cJSON_Raw:
   1315                  {
   1316                      size_t raw_length = 0;
   1317                      if (item->valuestring == NULL)
   \                     ??print_value_8:
   \   00000134   000050E3           CMP      R0,#+0
   1318                      {
   1319                          return false;
   \   00000138   7080BD08           POPEQ    {R4-R6,PC}
   1320                      }
   1321          
   1322                      raw_length = strlen(item->valuestring) + sizeof("");
   \   0000013C   1B0000EF           SWI      +27
   \   00000140   016080E2           ADD      R6,R0,#+1
   1323                      output = ensure(output_buffer, raw_length);
   \   00000144   0610A0E1           MOV      R1,R6
   \   00000148   0500A0E1           MOV      R0,R5
   \   0000014C   ........           BL       ensure
   1324                      if (output == NULL)
   \   00000150   000050E3           CMP      R0,#+0
   1325                      {
   1326                          return false;
   \   00000154   7080BD08           POPEQ    {R4-R6,PC}
   1327                      }
   1328                      memcpy(output, item->valuestring, raw_length);
   \   00000158   101094E5           LDR      R1,[R4, #+16]
   \   0000015C   0620A0E1           MOV      R2,R6
   \   00000160   1E0100EF           SWI      +286
   1329                      return true;
   \   00000164   ECFFFFEA           B        ??print_value_6
   1330                  }
   1331          
   1332                  case cJSON_String:
   1333                      return print_string(item, output_buffer);
   \                     ??print_value_9:
   \   00000168   0510A0E1           MOV      R1,R5
   \   0000016C   ........           BL       print_string_ptr
   \   00000170   7080BDE8           POP      {R4-R6,PC}
   1334          
   1335                  case cJSON_Array:
   1336                      return print_array(item, output_buffer);
   \                     ??print_value_10:
   \   00000174   0510A0E1           MOV      R1,R5
   \   00000178   0400A0E1           MOV      R0,R4
   \   0000017C   ........           BL       print_array
   \   00000180   7080BDE8           POP      {R4-R6,PC}
   1337          
   1338                  case cJSON_Object:
   1339                      return print_object(item, output_buffer);
   \                     ??print_value_11:
   \   00000184   0510A0E1           MOV      R1,R5
   \   00000188   0400A0E1           MOV      R0,R4
   \   0000018C   ........           BL       print_object
   \   00000190   7080BDE8           POP      {R4-R6,PC}
   1340          
   1341                  default:
   1342                      return false;
   \                     ??print_value_1:
   \   00000194   0000A0E3           MOV      R0,#+0
   \   00000198   7080BDE8           POP      {R4-R6,PC}       ;; return
   1343              }
   1344          }
   1345          
   1346          /* Build an array from input text. */

   \                                 In segment CODE, align 4, keep-with-next
   1347          static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
   1348          {
   \                     parse_array:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1349              cJSON *head = NULL; /* head of the linked list */
   1350              cJSON *current_item = NULL;
   1351          
   1352              if (input_buffer->depth >= CJSON_NESTING_LIMIT)
   \   0000000C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000010   0070A0E3           MOV      R7,#+0
   \   00000014   0060A0E3           MOV      R6,#+0
   \   00000018   FA0F50E3           CMP      R0,#+1000
   \   0000001C   0100003A           BCC      ??parse_array_0
   1353              {
   1354                  return false; /* to deeply nested */
   \                     ??parse_array_1:
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   F080BDE8           POP      {R4-R7,PC}       ;; return
   1355              }
   1356              input_buffer->depth++;
   \                     ??parse_array_0:
   \   00000028   010080E2           ADD      R0,R0,#+1
   \   0000002C   0C0085E5           STR      R0,[R5, #+12]
   1357          
   1358              if (buffer_at_offset(input_buffer)[0] != '[')
   \   00000030   080095E5           LDR      R0,[R5, #+8]
   \   00000034   001095E5           LDR      R1,[R5, #+0]
   \   00000038   0110D0E7           LDRB     R1,[R0, +R1]
   \   0000003C   5B0051E3           CMP      R1,#+91
   \   00000040   F6FFFF1A           BNE      ??parse_array_1
   1359              {
   1360                  /* not an array */
   1361                  goto fail;
   1362              }
   1363          
   1364              input_buffer->offset++;
   \   00000044   010080E2           ADD      R0,R0,#+1
   \   00000048   080085E5           STR      R0,[R5, #+8]
   1365              buffer_skip_whitespace(input_buffer);
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   ........           BL       buffer_skip_whitespace
   1366              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
   \   00000054   000055E3           CMP      R5,#+0
   \   00000058   1400000A           BEQ      ??parse_array_2
   \   0000005C   080095E5           LDR      R0,[R5, #+8]
   \   00000060   041095E5           LDR      R1,[R5, #+4]
   \   00000064   010050E1           CMP      R0,R1
   \   00000068   1000002A           BCS      ??parse_array_2
   \   0000006C   001095E5           LDR      R1,[R5, #+0]
   \   00000070   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000074   5D0051E3           CMP      R1,#+93
   \   00000078   2700000A           BEQ      ??parse_array_3
   1367              {
   1368                  /* empty array */
   1369                  goto success;
   1370              }
   1371          
   1372              /* check if we skipped to the end of the buffer */
   1373              if (cannot_access_at_index(input_buffer, 0))
   1374              {
   1375                  input_buffer->offset--;
   1376                  goto fail;
   1377              }
   1378          
   1379              /* step back to character in front of the first element */
   1380              input_buffer->offset--;
   \   0000007C   010040E2           SUB      R0,R0,#+1
   \   00000080   080085E5           STR      R0,[R5, #+8]
   1381              /* loop through the comma separated array elements */
   1382              do
   1383              {
   1384                  /* allocate next item */
   1385                  cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
   \                     ??parse_array_4:
   \   00000084   100085E2           ADD      R0,R5,#+16
   \   00000088   ........           BL       cJSON_New_Item
   1386                  if (new_item == NULL)
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   2C00000A           BEQ      ??parse_array_5
   1387                  {
   1388                      goto fail; /* allocation failure */
   1389                  }
   1390          
   1391                  /* attach next item to list */
   1392                  if (head == NULL)
   \   00000094   000056E3           CMP      R6,#+0
   \   00000098   00008715           STRNE    R0,[R7, #+0]
   \   0000009C   04708015           STRNE    R7,[R0, #+4]
   \   000000A0   0070A011           MOVNE    R7,R0
   1393                  {
   1394                      /* start the linked list */
   1395                      current_item = head = new_item;
   \   000000A4   0060A001           MOVEQ    R6,R0
   \   000000A8   0670A001           MOVEQ    R7,R6
   \   000000AC   030000EA           B        ??parse_array_6
   1396                  }
   \                     ??parse_array_2:
   \   000000B0   080095E5           LDR      R0,[R5, #+8]
   \   000000B4   010040E2           SUB      R0,R0,#+1
   \   000000B8   080085E5           STR      R0,[R5, #+8]
   \   000000BC   250000EA           B        ??parse_array_7
   1397                  else
   1398                  {
   1399                      /* add to the end and advance */
   1400                      current_item->next = new_item;
   1401                      new_item->prev = current_item;
   1402                      current_item = new_item;
   1403                  }
   1404          
   1405                  /* parse next value */
   1406                  input_buffer->offset++;
   \                     ??parse_array_6:
   \   000000C0   080095E5           LDR      R0,[R5, #+8]
   \   000000C4   010080E2           ADD      R0,R0,#+1
   \   000000C8   080085E5           STR      R0,[R5, #+8]
   1407                  buffer_skip_whitespace(input_buffer);
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   ........           BL       buffer_skip_whitespace
   1408                  if (!parse_value(current_item, input_buffer))
   \   000000D4   0510A0E1           MOV      R1,R5
   \   000000D8   0700A0E1           MOV      R0,R7
   \   000000DC   ........           BL       parse_value
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   1700000A           BEQ      ??parse_array_5
   1409                  {
   1410                      goto fail; /* failed to parse value */
   1411                  }
   1412                  buffer_skip_whitespace(input_buffer);
   \   000000E8   0500A0E1           MOV      R0,R5
   \   000000EC   ........           BL       buffer_skip_whitespace
   1413              }
   1414              while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
   \   000000F0   080095E5           LDR      R0,[R5, #+8]
   \   000000F4   041095E5           LDR      R1,[R5, #+4]
   \   000000F8   010050E1           CMP      R0,R1
   \   000000FC   1100002A           BCS      ??parse_array_5
   \   00000100   001095E5           LDR      R1,[R5, #+0]
   \   00000104   010080E0           ADD      R0,R0,R1
   \   00000108   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000010C   2C0051E3           CMP      R1,#+44
   \   00000110   DBFFFF0A           BEQ      ??parse_array_4
   \   00000114   5D0051E3           CMP      R1,#+93
   \   00000118   0A00001A           BNE      ??parse_array_5
   1415          
   1416              if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
   1417              {
   1418                  goto fail; /* expected end of array */
   1419              }
   1420          
   1421          success:
   1422              input_buffer->depth--;
   \                     ??parse_array_3:
   \   0000011C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000120   010040E2           SUB      R0,R0,#+1
   \   00000124   0C0085E5           STR      R0,[R5, #+12]
   1423          
   1424              item->type = cJSON_Array;
   \   00000128   2000A0E3           MOV      R0,#+32
   \   0000012C   0C0084E5           STR      R0,[R4, #+12]
   1425              item->child = head;
   \   00000130   086084E5           STR      R6,[R4, #+8]
   1426          
   1427              input_buffer->offset++;
   \   00000134   080095E5           LDR      R0,[R5, #+8]
   \   00000138   010080E2           ADD      R0,R0,#+1
   \   0000013C   080085E5           STR      R0,[R5, #+8]
   1428          
   1429              return true;
   \   00000140   0100A0E3           MOV      R0,#+1
   \   00000144   F080BDE8           POP      {R4-R7,PC}
   1430          
   1431          fail:
   1432              if (head != NULL)
   \                     ??parse_array_5:
   \   00000148   000056E3           CMP      R6,#+0
   \   0000014C   B3FFFF0A           BEQ      ??parse_array_1
   1433              {
   1434                  cJSON_Delete(head);
   \   00000150   0600A0E1           MOV      R0,R6
   \   00000154   ........           BL       cJSON_Delete
   \                     ??parse_array_7:
   \   00000158   0000A0E3           MOV      R0,#+0
   \   0000015C   F080BDE8           POP      {R4-R7,PC}
   1435              }
   1436          
   1437              return false;
   1438          }
   1439          
   1440          /* Render an array to text */

   \                                 In segment CODE, align 4, keep-with-next
   1441          static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
   1442          {
   \                     print_array:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   1443              unsigned char *output_pointer = NULL;
   1444              size_t length = 0;
   1445              cJSON *current_element = item->child;
   \   00000004   085090E5           LDR      R5,[R0, #+8]
   \   00000008   0140B0E1           MOVS     R4,R1
   1446          
   1447              if (output_buffer == NULL)
   1448              {
   1449                  return false;
   \   0000000C   0000A003           MOVEQ    R0,#+0
   \   00000010   F080BD08           POPEQ    {R4-R7,PC}
   1450              }
   1451          
   1452              /* Compose the output array. */
   1453              /* opening square bracket */
   1454              output_pointer = ensure(output_buffer, 1);
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       ensure
   1455              if (output_pointer == NULL)
   \   00000020   000050E3           CMP      R0,#+0
   1456              {
   1457                  return false;
   \   00000024   F080BD08           POPEQ    {R4-R7,PC}
   1458              }
   1459          
   1460              *output_pointer = '[';
   \   00000028   5B10A0E3           MOV      R1,#+91
   \   0000002C   0010C0E5           STRB     R1,[R0, #+0]
   1461              output_buffer->offset++;
   \   00000030   080094E5           LDR      R0,[R4, #+8]
   1462              output_buffer->depth++;
   \   00000034   0060A0E3           MOV      R6,#+0
   \   00000038   010080E2           ADD      R0,R0,#+1
   \   0000003C   080084E5           STR      R0,[R4, #+8]
   \   00000040   0C0094E5           LDR      R0,[R4, #+12]
   \   00000044   010080E2           ADD      R0,R0,#+1
   \   00000048   0C0084E5           STR      R0,[R4, #+12]
   \   0000004C   0A0000EA           B        ??print_array_0
   1463          
   1464              while (current_element != NULL)
   1465              {
   1466                  if (!print_value(current_element, output_buffer))
   1467                  {
   1468                      return false;
   1469                  }
   1470                  update_offset(output_buffer);
   1471                  if (current_element->next)
   1472                  {
   1473                      length = (size_t) (output_buffer->format ? 2 : 1);
   1474                      output_pointer = ensure(output_buffer, length + 1);
   1475                      if (output_pointer == NULL)
   1476                      {
   1477                          return false;
   1478                      }
   1479                      *output_pointer++ = ',';
   \                     ??print_array_1:
   \   00000050   2C10A0E3           MOV      R1,#+44
   \   00000054   ........           STRB     R1,[R0], #+1
   1480                      if(output_buffer->format)
   \   00000058   141094E5           LDR      R1,[R4, #+20]
   \   0000005C   000051E3           CMP      R1,#+0
   1481                      {
   1482                          *output_pointer++ = ' ';
   \   00000060   2010A013           MOVNE    R1,#+32
   \   00000064   ........           STRBNE   R1,[R0], #+1
   1483                      }
   1484                      *output_pointer = '\0';
   \   00000068   0060C0E5           STRB     R6,[R0, #+0]
   1485                      output_buffer->offset += length;
   \   0000006C   080094E5           LDR      R0,[R4, #+8]
   \   00000070   000087E0           ADD      R0,R7,R0
   \   00000074   080084E5           STR      R0,[R4, #+8]
   1486                  }
   1487                  current_element = current_element->next;
   \                     ??print_array_2:
   \   00000078   005095E5           LDR      R5,[R5, #+0]
   \                     ??print_array_0:
   \   0000007C   000055E3           CMP      R5,#+0
   \   00000080   1300000A           BEQ      ??print_array_3
   \   00000084   0410A0E1           MOV      R1,R4
   \   00000088   0500A0E1           MOV      R0,R5
   \   0000008C   ........           BL       print_value
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   F080BD08           POPEQ    {R4-R7,PC}
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       update_offset
   \   000000A0   000095E5           LDR      R0,[R5, #+0]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   F2FFFF0A           BEQ      ??print_array_2
   \   000000AC   140094E5           LDR      R0,[R4, #+20]
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   0270A013           MOVNE    R7,#+2
   \   000000B8   0170A003           MOVEQ    R7,#+1
   \   000000BC   011087E2           ADD      R1,R7,#+1
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       ensure
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   DFFFFF1A           BNE      ??print_array_1
   \   000000D0   F080BDE8           POP      {R4-R7,PC}
   1488              }
   1489          
   1490              output_pointer = ensure(output_buffer, 2);
   \                     ??print_array_3:
   \   000000D4   0210A0E3           MOV      R1,#+2
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       ensure
   1491              if (output_pointer == NULL)
   \   000000E0   000050E3           CMP      R0,#+0
   1492              {
   1493                  return false;
   \   000000E4   F080BD08           POPEQ    {R4-R7,PC}
   1494              }
   1495              *output_pointer++ = ']';
   \   000000E8   5D10A0E3           MOV      R1,#+93
   \   000000EC   ........           STRB     R1,[R0], #+1
   1496              *output_pointer = '\0';
   \   000000F0   0060C0E5           STRB     R6,[R0, #+0]
   1497              output_buffer->depth--;
   \   000000F4   0C0094E5           LDR      R0,[R4, #+12]
   \   000000F8   010040E2           SUB      R0,R0,#+1
   \   000000FC   0C0084E5           STR      R0,[R4, #+12]
   1498          
   1499              return true;
   \   00000100   0100A0E3           MOV      R0,#+1
   \   00000104   F080BDE8           POP      {R4-R7,PC}       ;; return
   1500          }
   1501          
   1502          /* Build an object from the text. */

   \                                 In segment CODE, align 4, keep-with-next
   1503          static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
   1504          {
   \                     parse_object:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1505              cJSON *head = NULL; /* linked list head */
   1506              cJSON *current_item = NULL;
   1507          
   1508              if (input_buffer->depth >= CJSON_NESTING_LIMIT)
   \   0000000C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000010   0060A0E3           MOV      R6,#+0
   \   00000014   0070A0E3           MOV      R7,#+0
   \   00000018   0680A0E1           MOV      R8,R6
   \   0000001C   FA0F50E3           CMP      R0,#+1000
   \   00000020   0100003A           BCC      ??parse_object_0
   1509              {
   1510                  return false; /* to deeply nested */
   \                     ??parse_object_1:
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   F081BDE8           POP      {R4-R8,PC}       ;; return
   1511              }
   1512              input_buffer->depth++;
   \                     ??parse_object_0:
   \   0000002C   010080E2           ADD      R0,R0,#+1
   \   00000030   0C0085E5           STR      R0,[R5, #+12]
   1513          
   1514              if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   F9FFFF0A           BEQ      ??parse_object_1
   \   0000003C   080095E5           LDR      R0,[R5, #+8]
   \   00000040   041095E5           LDR      R1,[R5, #+4]
   \   00000044   010050E1           CMP      R0,R1
   \   00000048   F5FFFF2A           BCS      ??parse_object_1
   \   0000004C   001095E5           LDR      R1,[R5, #+0]
   \   00000050   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000054   7B0051E3           CMP      R1,#+123
   \   00000058   F1FFFF1A           BNE      ??parse_object_1
   1515              {
   1516                  goto fail; /* not an object */
   1517              }
   1518          
   1519              input_buffer->offset++;
   \   0000005C   010080E2           ADD      R0,R0,#+1
   \   00000060   080085E5           STR      R0,[R5, #+8]
   1520              buffer_skip_whitespace(input_buffer);
   \   00000064   0500A0E1           MOV      R0,R5
   \   00000068   ........           BL       buffer_skip_whitespace
   1521              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
   \   0000006C   080095E5           LDR      R0,[R5, #+8]
   \   00000070   041095E5           LDR      R1,[R5, #+4]
   \   00000074   010050E1           CMP      R0,R1
   \   00000078   1000002A           BCS      ??parse_object_2
   \   0000007C   001095E5           LDR      R1,[R5, #+0]
   \   00000080   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000084   7D0051E3           CMP      R1,#+125
   \   00000088   3D00000A           BEQ      ??parse_object_3
   1522              {
   1523                  goto success; /* empty object */
   1524              }
   1525          
   1526              /* check if we skipped to the end of the buffer */
   1527              if (cannot_access_at_index(input_buffer, 0))
   1528              {
   1529                  input_buffer->offset--;
   1530                  goto fail;
   1531              }
   1532          
   1533              /* step back to character in front of the first element */
   1534              input_buffer->offset--;
   \   0000008C   010040E2           SUB      R0,R0,#+1
   \   00000090   080085E5           STR      R0,[R5, #+8]
   1535              /* loop through the comma separated array elements */
   1536              do
   1537              {
   1538                  /* allocate next item */
   1539                  cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
   \                     ??parse_object_4:
   \   00000094   100085E2           ADD      R0,R5,#+16
   \   00000098   ........           BL       cJSON_New_Item
   1540                  if (new_item == NULL)
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   4200000A           BEQ      ??parse_object_5
   1541                  {
   1542                      goto fail; /* allocation failure */
   1543                  }
   1544          
   1545                  /* attach next item to list */
   1546                  if (head == NULL)
   \   000000A4   000057E3           CMP      R7,#+0
   \   000000A8   00008815           STRNE    R0,[R8, #+0]
   \   000000AC   04808015           STRNE    R8,[R0, #+4]
   \   000000B0   0080A011           MOVNE    R8,R0
   1547                  {
   1548                      /* start the linked list */
   1549                      current_item = head = new_item;
   \   000000B4   0070A001           MOVEQ    R7,R0
   \   000000B8   0780A001           MOVEQ    R8,R7
   \   000000BC   020000EA           B        ??parse_object_6
   1550                  }
   \                     ??parse_object_2:
   \   000000C0   010040E2           SUB      R0,R0,#+1
   \   000000C4   080085E5           STR      R0,[R5, #+8]
   \   000000C8   3C0000EA           B        ??parse_object_7
   1551                  else
   1552                  {
   1553                      /* add to the end and advance */
   1554                      current_item->next = new_item;
   1555                      new_item->prev = current_item;
   1556                      current_item = new_item;
   1557                  }
   1558          
   1559                  /* parse the name of the child */
   1560                  input_buffer->offset++;
   \                     ??parse_object_6:
   \   000000CC   080095E5           LDR      R0,[R5, #+8]
   \   000000D0   010080E2           ADD      R0,R0,#+1
   \   000000D4   080085E5           STR      R0,[R5, #+8]
   1561                  buffer_skip_whitespace(input_buffer);
   \   000000D8   0500A0E1           MOV      R0,R5
   \   000000DC   ........           BL       buffer_skip_whitespace
   1562                  if (!parse_string(current_item, input_buffer))
   \   000000E0   0510A0E1           MOV      R1,R5
   \   000000E4   0800A0E1           MOV      R0,R8
   \   000000E8   ........           BL       parse_string
   \   000000EC   000050E3           CMP      R0,#+0
   \   000000F0   2E00000A           BEQ      ??parse_object_5
   1563                  {
   1564                      goto fail; /* faile to parse name */
   1565                  }
   1566                  buffer_skip_whitespace(input_buffer);
   \   000000F4   0500A0E1           MOV      R0,R5
   \   000000F8   ........           BL       buffer_skip_whitespace
   1567          
   1568                  /* swap valuestring and string, because we parsed the name */
   1569                  current_item->string = current_item->valuestring;
   \   000000FC   100088E2           ADD      R0,R8,#+16
   \   00000100   001090E5           LDR      R1,[R0, #+0]
   \   00000104   101080E5           STR      R1,[R0, #+16]
   1570                  current_item->valuestring = NULL;
   \   00000108   006080E5           STR      R6,[R0, #+0]
   1571          
   1572                  if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
   \   0000010C   080095E5           LDR      R0,[R5, #+8]
   \   00000110   041095E5           LDR      R1,[R5, #+4]
   \   00000114   010050E1           CMP      R0,R1
   \   00000118   2400002A           BCS      ??parse_object_5
   \   0000011C   001095E5           LDR      R1,[R5, #+0]
   \   00000120   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000124   3A0051E3           CMP      R1,#+58
   \   00000128   2000001A           BNE      ??parse_object_5
   1573                  {
   1574                      goto fail; /* invalid object */
   1575                  }
   1576          
   1577                  /* parse the value */
   1578                  input_buffer->offset++;
   \   0000012C   010080E2           ADD      R0,R0,#+1
   \   00000130   080085E5           STR      R0,[R5, #+8]
   1579                  buffer_skip_whitespace(input_buffer);
   \   00000134   0500A0E1           MOV      R0,R5
   \   00000138   ........           BL       buffer_skip_whitespace
   1580                  if (!parse_value(current_item, input_buffer))
   \   0000013C   0510A0E1           MOV      R1,R5
   \   00000140   0800A0E1           MOV      R0,R8
   \   00000144   ........           BL       parse_value
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   1700000A           BEQ      ??parse_object_5
   1581                  {
   1582                      goto fail; /* failed to parse value */
   1583                  }
   1584                  buffer_skip_whitespace(input_buffer);
   \   00000150   0500A0E1           MOV      R0,R5
   \   00000154   ........           BL       buffer_skip_whitespace
   1585              }
   1586              while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
   \   00000158   080095E5           LDR      R0,[R5, #+8]
   \   0000015C   041095E5           LDR      R1,[R5, #+4]
   \   00000160   010050E1           CMP      R0,R1
   \   00000164   1100002A           BCS      ??parse_object_5
   \   00000168   001095E5           LDR      R1,[R5, #+0]
   \   0000016C   010080E0           ADD      R0,R0,R1
   \   00000170   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000174   2C0051E3           CMP      R1,#+44
   \   00000178   C5FFFF0A           BEQ      ??parse_object_4
   \   0000017C   7D0051E3           CMP      R1,#+125
   \   00000180   0A00001A           BNE      ??parse_object_5
   1587          
   1588              if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
   1589              {
   1590                  goto fail; /* expected end of object */
   1591              }
   1592          
   1593          success:
   1594              input_buffer->depth--;
   \                     ??parse_object_3:
   \   00000184   0C0095E5           LDR      R0,[R5, #+12]
   \   00000188   010040E2           SUB      R0,R0,#+1
   \   0000018C   0C0085E5           STR      R0,[R5, #+12]
   1595          
   1596              item->type = cJSON_Object;
   \   00000190   4000A0E3           MOV      R0,#+64
   \   00000194   0C0084E5           STR      R0,[R4, #+12]
   1597              item->child = head;
   \   00000198   087084E5           STR      R7,[R4, #+8]
   1598          
   1599              input_buffer->offset++;
   \   0000019C   080095E5           LDR      R0,[R5, #+8]
   \   000001A0   010080E2           ADD      R0,R0,#+1
   \   000001A4   080085E5           STR      R0,[R5, #+8]
   1600              return true;
   \   000001A8   0100A0E3           MOV      R0,#+1
   \   000001AC   F081BDE8           POP      {R4-R8,PC}
   1601          
   1602          fail:
   1603              if (head != NULL)
   \                     ??parse_object_5:
   \   000001B0   000057E3           CMP      R7,#+0
   \   000001B4   9AFFFF0A           BEQ      ??parse_object_1
   1604              {
   1605                  cJSON_Delete(head);
   \   000001B8   0700A0E1           MOV      R0,R7
   \   000001BC   ........           BL       cJSON_Delete
   \                     ??parse_object_7:
   \   000001C0   0000A0E3           MOV      R0,#+0
   \   000001C4   F081BDE8           POP      {R4-R8,PC}
   1606              }
   1607          
   1608              return false;
   1609          }
   1610          
   1611          /* Render an object to text. */

   \                                 In segment CODE, align 4, keep-with-next
   1612          static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
   1613          {
   \                     print_object:
   \   00000000   70472DE9           PUSH     {R4-R6,R8-R10,LR}
   1614              unsigned char *output_pointer = NULL;
   1615              size_t length = 0;
   1616              cJSON *current_item = item->child;
   \   00000004   086090E5           LDR      R6,[R0, #+8]
   \   00000008   0140B0E1           MOVS     R4,R1
   1617          
   1618              if (output_buffer == NULL)
   1619              {
   1620                  return false;
   \   0000000C   0000A003           MOVEQ    R0,#+0
   \   00000010   7087BD08           POPEQ    {R4-R6,R8-R10,PC}
   1621              }
   1622          
   1623              /* Compose the output: */
   1624              length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
   \   00000014   140094E5           LDR      R0,[R4, #+20]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   02A0A013           MOVNE    R10,#+2
   \   00000020   01A0A003           MOVEQ    R10,#+1
   1625              output_pointer = ensure(output_buffer, length + 1);
   \   00000024   01108AE2           ADD      R1,R10,#+1
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       ensure
   1626              if (output_pointer == NULL)
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   7087BD08           POPEQ    {R4-R6,R8-R10,PC}
   1627              {
   1628                  return false;
   1629              }
   1630          
   1631              *output_pointer++ = '{';
   \   00000038   7B10A0E3           MOV      R1,#+123
   \   0000003C   ........           STRB     R1,[R0], #+1
   1632              output_buffer->depth++;
   \   00000040   0C1094E5           LDR      R1,[R4, #+12]
   1633              if (output_buffer->format)
   \   00000044   0A80A0E3           MOV      R8,#+10
   \   00000048   011081E2           ADD      R1,R1,#+1
   \   0000004C   0C1084E5           STR      R1,[R4, #+12]
   \   00000050   141094E5           LDR      R1,[R4, #+20]
   1634              {
   1635                  *output_pointer++ = '\n';
   1636              }
   1637              output_buffer->offset += length;
   \   00000054   0050A0E3           MOV      R5,#+0
   \   00000058   000051E3           CMP      R1,#+0
   \   0000005C   0080C015           STRBNE   R8,[R0, #+0]
   \   00000060   080094E5           LDR      R0,[R4, #+8]
   \   00000064   0990A0E3           MOV      R9,#+9
   \   00000068   00008AE0           ADD      R0,R10,R0
   \   0000006C   080084E5           STR      R0,[R4, #+8]
   \   00000070   110000EA           B        ??print_object_0
   1638          
   1639              while (current_item)
   1640              {
   1641                  if (output_buffer->format)
   1642                  {
   1643                      size_t i;
   1644                      output_pointer = ensure(output_buffer, output_buffer->depth);
   1645                      if (output_pointer == NULL)
   1646                      {
   1647                          return false;
   1648                      }
   1649                      for (i = 0; i < output_buffer->depth; i++)
   1650                      {
   1651                          *output_pointer++ = '\t';
   1652                      }
   1653                      output_buffer->offset += output_buffer->depth;
   1654                  }
   1655          
   1656                  /* print key */
   1657                  if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
   1658                  {
   1659                      return false;
   1660                  }
   1661                  update_offset(output_buffer);
   1662          
   1663                  length = (size_t) (output_buffer->format ? 2 : 1);
   1664                  output_pointer = ensure(output_buffer, length);
   1665                  if (output_pointer == NULL)
   1666                  {
   1667                      return false;
   1668                  }
   1669                  *output_pointer++ = ':';
   1670                  if (output_buffer->format)
   1671                  {
   1672                      *output_pointer++ = '\t';
   1673                  }
   1674                  output_buffer->offset += length;
   1675          
   1676                  /* print value */
   1677                  if (!print_value(current_item, output_buffer))
   1678                  {
   1679                      return false;
   1680                  }
   1681                  update_offset(output_buffer);
   1682          
   1683                  /* print comma if not last */
   1684                  length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
   \                     ??print_object_1:
   \   00000074   01A080E0           ADD      R10,R0,R1
   1685                  output_pointer = ensure(output_buffer, length + 1);
   \   00000078   01108AE2           ADD      R1,R10,#+1
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   ........           BL       ensure
   1686                  if (output_pointer == NULL)
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   7087BD08           POPEQ    {R4-R6,R8-R10,PC}
   1687                  {
   1688                      return false;
   1689                  }
   1690                  if (current_item->next)
   \   0000008C   001096E5           LDR      R1,[R6, #+0]
   \   00000090   000051E3           CMP      R1,#+0
   1691                  {
   1692                      *output_pointer++ = ',';
   \   00000094   2C10A013           MOVNE    R1,#+44
   \   00000098   ........           STRBNE   R1,[R0], #+1
   1693                  }
   1694          
   1695                  if (output_buffer->format)
   \   0000009C   141094E5           LDR      R1,[R4, #+20]
   \   000000A0   000051E3           CMP      R1,#+0
   1696                  {
   1697                      *output_pointer++ = '\n';
   \   000000A4   ........           STRBNE   R8,[R0], #+1
   1698                  }
   1699                  *output_pointer = '\0';
   \   000000A8   0050C0E5           STRB     R5,[R0, #+0]
   1700                  output_buffer->offset += length;
   \   000000AC   080094E5           LDR      R0,[R4, #+8]
   \   000000B0   00008AE0           ADD      R0,R10,R0
   \   000000B4   080084E5           STR      R0,[R4, #+8]
   1701          
   1702                  current_item = current_item->next;
   \   000000B8   006096E5           LDR      R6,[R6, #+0]
   \                     ??print_object_0:
   \   000000BC   0C1094E5           LDR      R1,[R4, #+12]
   \   000000C0   140094E5           LDR      R0,[R4, #+20]
   \   000000C4   000056E3           CMP      R6,#+0
   \   000000C8   3B00000A           BEQ      ??print_object_2
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   1100000A           BEQ      ??print_object_3
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   ........           BL       ensure
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   7087BD08           POPEQ    {R4-R6,R8-R10,PC}
   \   000000E4   0C2094E5           LDR      R2,[R4, #+12]
   \   000000E8   0010A0E3           MOV      R1,#+0
   \   000000EC   000052E3           CMP      R2,#+0
   \   000000F0   0200001A           BNE      ??print_object_4
   \   000000F4   040000EA           B        ??print_object_5
   \                     ??print_object_6:
   \   000000F8   ........           STRB     R9,[R0], #+1
   \   000000FC   011081E2           ADD      R1,R1,#+1
   \                     ??print_object_4:
   \   00000100   0C2094E5           LDR      R2,[R4, #+12]
   \   00000104   020051E1           CMP      R1,R2
   \   00000108   FAFFFF3A           BCC      ??print_object_6
   \                     ??print_object_5:
   \   0000010C   080094E5           LDR      R0,[R4, #+8]
   \   00000110   0C1094E5           LDR      R1,[R4, #+12]
   \   00000114   000081E0           ADD      R0,R1,R0
   \   00000118   080084E5           STR      R0,[R4, #+8]
   \                     ??print_object_3:
   \   0000011C   200096E5           LDR      R0,[R6, #+32]
   \   00000120   0410A0E1           MOV      R1,R4
   \   00000124   ........           BL       print_string_ptr
   \   00000128   000050E3           CMP      R0,#+0
   \   0000012C   7087BD08           POPEQ    {R4-R6,R8-R10,PC}
   \   00000130   0400A0E1           MOV      R0,R4
   \   00000134   ........           BL       update_offset
   \   00000138   140094E5           LDR      R0,[R4, #+20]
   \   0000013C   000050E3           CMP      R0,#+0
   \   00000140   02A0A013           MOVNE    R10,#+2
   \   00000144   01A0A003           MOVEQ    R10,#+1
   \   00000148   0A10A0E1           MOV      R1,R10
   \   0000014C   0400A0E1           MOV      R0,R4
   \   00000150   ........           BL       ensure
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   7087BD08           POPEQ    {R4-R6,R8-R10,PC}
   \   0000015C   3A10A0E3           MOV      R1,#+58
   \   00000160   ........           STRB     R1,[R0], #+1
   \   00000164   141094E5           LDR      R1,[R4, #+20]
   \   00000168   000051E3           CMP      R1,#+0
   \   0000016C   0090C015           STRBNE   R9,[R0, #+0]
   \   00000170   080094E5           LDR      R0,[R4, #+8]
   \   00000174   0410A0E1           MOV      R1,R4
   \   00000178   00008AE0           ADD      R0,R10,R0
   \   0000017C   080084E5           STR      R0,[R4, #+8]
   \   00000180   0600A0E1           MOV      R0,R6
   \   00000184   ........           BL       print_value
   \   00000188   000050E3           CMP      R0,#+0
   \   0000018C   7087BD08           POPEQ    {R4-R6,R8-R10,PC}
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   ........           BL       update_offset
   \   00000198   140094E5           LDR      R0,[R4, #+20]
   \   0000019C   000050E3           CMP      R0,#+0
   \   000001A0   000096E5           LDR      R0,[R6, #+0]
   \   000001A4   0110A013           MOVNE    R1,#+1
   \   000001A8   0010A003           MOVEQ    R1,#+0
   \   000001AC   000050E3           CMP      R0,#+0
   \   000001B0   AFFFFF0A           BEQ      ??print_object_1
   \   000001B4   0100A0E3           MOV      R0,#+1
   \   000001B8   ADFFFFEA           B        ??print_object_1
   1703              }
   1704          
   1705              output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
   \                     ??print_object_2:
   \   000001BC   000050E3           CMP      R0,#+0
   \   000001C0   01108112           ADDNE    R1,R1,#+1
   \   000001C4   0210A003           MOVEQ    R1,#+2
   \   000001C8   0400A0E1           MOV      R0,R4
   \   000001CC   ........           BL       ensure
   1706              if (output_pointer == NULL)
   \   000001D0   000050E3           CMP      R0,#+0
   \   000001D4   7087BD08           POPEQ    {R4-R6,R8-R10,PC}
   1707              {
   1708                  return false;
   1709              }
   1710              if (output_buffer->format)
   \   000001D8   141094E5           LDR      R1,[R4, #+20]
   \   000001DC   000051E3           CMP      R1,#+0
   \   000001E0   0A00000A           BEQ      ??print_object_7
   1711              {
   1712                  size_t i;
   1713                  for (i = 0; i < (output_buffer->depth - 1); i++)
   \   000001E4   0C2094E5           LDR      R2,[R4, #+12]
   \   000001E8   0010A0E3           MOV      R1,#+0
   \   000001EC   012052E2           SUBS     R2,R2,#+1
   \   000001F0   0200001A           BNE      ??print_object_8
   \   000001F4   050000EA           B        ??print_object_7
   1714                  {
   1715                      *output_pointer++ = '\t';
   \                     ??print_object_9:
   \   000001F8   ........           STRB     R9,[R0], #+1
   1716                  }
   \   000001FC   011081E2           ADD      R1,R1,#+1
   \                     ??print_object_8:
   \   00000200   0C2094E5           LDR      R2,[R4, #+12]
   \   00000204   012042E2           SUB      R2,R2,#+1
   \   00000208   020051E1           CMP      R1,R2
   \   0000020C   F9FFFF3A           BCC      ??print_object_9
   1717              }
   1718              *output_pointer++ = '}';
   \                     ??print_object_7:
   \   00000210   7D10A0E3           MOV      R1,#+125
   \   00000214   ........           STRB     R1,[R0], #+1
   1719              *output_pointer = '\0';
   \   00000218   0050C0E5           STRB     R5,[R0, #+0]
   1720              output_buffer->depth--;
   \   0000021C   0C0094E5           LDR      R0,[R4, #+12]
   \   00000220   010040E2           SUB      R0,R0,#+1
   \   00000224   0C0084E5           STR      R0,[R4, #+12]
   1721          
   1722              return true;
   \   00000228   0100A0E3           MOV      R0,#+1
   \   0000022C   7087BDE8           POP      {R4-R6,R8-R10,PC}
   1723          }
   1724          
   1725          /* Get Array size/item / object item. */

   \                                 In segment CODE, align 4, keep-with-next
   1726          CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
   1727          {
   1728              cJSON *child = NULL;
   1729              size_t size = 0;
   \                     cJSON_GetArraySize:
   \   00000000   0010A0E3           MOV      R1,#+0
   1730          
   1731              if (array == NULL)
   \   00000004   000050E3           CMP      R0,#+0
   1732              {
   1733                  return 0;
   \   00000008   1EFF2F01           BXEQ     LR
   1734              }
   1735          
   1736              child = array->child;
   \   0000000C   080090E5           LDR      R0,[R0, #+8]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0300000A           BEQ      ??cJSON_GetArraySize_0
   1737          
   1738              while(child != NULL)
   1739              {
   1740                  size++;
   1741                  child = child->next;
   \                     ??cJSON_GetArraySize_1:
   \   00000018   000090E5           LDR      R0,[R0, #+0]
   \   0000001C   011081E2           ADD      R1,R1,#+1
   1742              }
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   FBFFFF1A           BNE      ??cJSON_GetArraySize_1
   1743          
   1744              /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
   1745          
   1746              return (int)size;
   \                     ??cJSON_GetArraySize_0:
   \   00000028   0100A0E1           MOV      R0,R1
   \   0000002C   1EFF2FE1           BX       LR               ;; return
   1747          }
   1748          
   1749          static cJSON* get_array_item(const cJSON *array, size_t index)
   1750          {
   1751              cJSON *current_child = NULL;
   1752          
   1753              if (array == NULL)
   1754              {
   1755                  return NULL;
   1756              }
   1757          
   1758              current_child = array->child;
   1759              while ((current_child != NULL) && (index > 0))
   1760              {
   1761                  index--;
   1762                  current_child = current_child->next;
   1763              }
   1764          
   1765              return current_child;
   1766          }
   1767          

   \                                 In segment CODE, align 4, keep-with-next
   1768          CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
   1769          {
   1770              if (index < 0)
   \                     cJSON_GetArrayItem:
   \   00000000   000051E3           CMP      R1,#+0
   1771              {
   1772                  return NULL;
   \   00000004   0000A043           MOVMI    R0,#+0
   \   00000008   1EFF2F41           BXMI     LR
   1773              }
   1774          
   1775              return get_array_item(array, (size_t)index);
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   1EFF2F01           BXEQ     LR
   \   00000014   080090E5           LDR      R0,[R0, #+8]
   \   00000018   010000EA           B        ??cJSON_GetArrayItem_0
   \                     ??cJSON_GetArrayItem_1:
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   011041E2           SUB      R1,R1,#+1
   \                     ??cJSON_GetArrayItem_0:
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   00005113           CMPNE    R1,#+0
   \   0000002C   FAFFFF1A           BNE      ??cJSON_GetArrayItem_1
   \   00000030   1EFF2FE1           BX       LR               ;; return
   1776          }
   1777          

   \                                 In segment CODE, align 4, keep-with-next
   1778          static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
   1779          {
   \                     get_object_item:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   1780              cJSON *current_element = NULL;
   1781          
   1782              if ((object == NULL) || (name == NULL))
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   F081BD08           POPEQ    {R4-R8,PC}
   \   00000010   000054E3           CMP      R4,#+0
   1783              {
   1784                  return NULL;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   F081BD08           POPEQ    {R4-R8,PC}
   1785              }
   1786          
   1787              current_element = object->child;
   \   0000001C   085090E5           LDR      R5,[R0, #+8]
   1788              if (case_sensitive)
   \   00000020   000052E3           CMP      R2,#+0
   \   00000024   0900000A           BEQ      ??get_object_item_0
   1789              {
   1790                  while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
   \                     ??get_object_item_1:
   \   00000028   000055E3           CMP      R5,#+0
   \   0000002C   2300000A           BEQ      ??get_object_item_2
   \   00000030   201095E5           LDR      R1,[R5, #+32]
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   190000EF           SWI      +25
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   1E00000A           BEQ      ??get_object_item_2
   1791                  {
   1792                      current_element = current_element->next;
   \   00000044   005095E5           LDR      R5,[R5, #+0]
   \   00000048   F6FFFFEA           B        ??get_object_item_1
   1793                  }
   1794              }
   1795              else
   1796              {
   1797                  while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
   1798                  {
   1799                      current_element = current_element->next;
   \                     ??get_object_item_3:
   \   0000004C   005095E5           LDR      R5,[R5, #+0]
   1800                  }
   \                     ??get_object_item_0:
   \   00000050   000055E3           CMP      R5,#+0
   \   00000054   1900000A           BEQ      ??get_object_item_2
   \   00000058   206095E5           LDR      R6,[R5, #+32]
   \   0000005C   0470B0E1           MOVS     R7,R4
   \   00000060   00005613           CMPNE    R6,#+0
   \   00000064   F8FFFF0A           BEQ      ??get_object_item_3
   \   00000068   060057E1           CMP      R7,R6
   \   0000006C   0500001A           BNE      ??get_object_item_4
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   F081BDE8           POP      {R4-R8,PC}
   \                     ??get_object_item_5:
   \   00000078   ........           LDRB     R0,[R7], #+1
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   0E00000A           BEQ      ??get_object_item_2
   \   00000084   016086E2           ADD      R6,R6,#+1
   \                     ??get_object_item_4:
   \   00000088   0000D7E5           LDRB     R0,[R7, #+0]
   \   0000008C   ........           _BLF     tolower,??tolower??rA
   \   00000090   0080A0E1           MOV      R8,R0
   \   00000094   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000098   ........           _BLF     tolower,??tolower??rA
   \   0000009C   000058E1           CMP      R8,R0
   \   000000A0   F4FFFF0A           BEQ      ??get_object_item_5
   \   000000A4   0000D7E5           LDRB     R0,[R7, #+0]
   \   000000A8   ........           _BLF     tolower,??tolower??rA
   \   000000AC   0070A0E1           MOV      R7,R0
   \   000000B0   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000B4   ........           _BLF     tolower,??tolower??rA
   \   000000B8   000057E0           SUBS     R0,R7,R0
   \   000000BC   E2FFFF1A           BNE      ??get_object_item_3
   1801              }
   1802          
   1803              return current_element;
   \                     ??get_object_item_2:
   \   000000C0   0500A0E1           MOV      R0,R5
   \   000000C4   F081BDE8           POP      {R4-R8,PC}       ;; return
   1804          }
   1805          

   \                                 In segment CODE, align 4, keep-with-next
   1806          CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
   1807          {
   1808              return get_object_item(object, string, false);
   \                     cJSON_GetObjectItem:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        get_object_item  ;; tailcall
   1809          }
   1810          

   \                                 In segment CODE, align 4, keep-with-next
   1811          CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
   1812          {
   1813              return get_object_item(object, string, true);
   \                     cJSON_GetObjectItemCaseSensitive:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        get_object_item  ;; tailcall
   1814          }
   1815          

   \                                 In segment CODE, align 4, keep-with-next
   1816          CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
   1817          {
   \                     cJSON_HasObjectItem:
   \   00000000   00402DE9           PUSH     {LR}
   1818              return cJSON_GetObjectItem(object, string) ? 1 : 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   ........           BL       get_object_item
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0100A013           MOVNE    R0,#+1
   \   00000014   0080BDE8           POP      {PC}             ;; return
   1819          }
   1820          
   1821          /* Utility for array list handling. */
   1822          static void suffix_object(cJSON *prev, cJSON *item)
   1823          {
   1824              prev->next = item;
   1825              item->prev = prev;
   1826          }
   1827          
   1828          /* Utility for handling references. */
   1829          static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
   1830          {
   1831              cJSON *reference = NULL;
   1832              if (item == NULL)
   1833              {
   1834                  return NULL;
   1835              }
   1836          
   1837              reference = cJSON_New_Item(hooks);
   1838              if (reference == NULL)
   1839              {
   1840                  return NULL;
   1841              }
   1842          
   1843              memcpy(reference, item, sizeof(cJSON));
   1844              reference->string = NULL;
   1845              reference->type |= cJSON_IsReference;
   1846              reference->next = reference->prev = NULL;
   1847              return reference;
   1848          }
   1849          

   \                                 In segment CODE, align 4, keep-with-next
   1850          static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
   1851          {
   1852              cJSON *child = NULL;
   1853          
   1854              if ((item == NULL) || (array == NULL))
   \                     add_item_to_array:
   \   00000000   000051E3           CMP      R1,#+0
   \   00000004   00005013           CMPNE    R0,#+0
   1855              {
   1856                  return false;
   \   00000008   0000A003           MOVEQ    R0,#+0
   \   0000000C   1EFF2F01           BXEQ     LR
   1857              }
   1858          
   1859              child = array->child;
   \   00000010   082090E5           LDR      R2,[R0, #+8]
   1860          
   1861              if (child == NULL)
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   0200001A           BNE      ??add_item_to_array_0
   1862              {
   1863                  /* list is empty, start new one */
   1864                  array->child = item;
   \   0000001C   081080E5           STR      R1,[R0, #+8]
   \   00000020   050000EA           B        ??add_item_to_array_1
   1865              }
   1866              else
   1867              {
   1868                  /* append to the end */
   1869                  while (child->next)
   1870                  {
   1871                      child = child->next;
   \                     ??add_item_to_array_2:
   \   00000024   0020A0E1           MOV      R2,R0
   1872                  }
   \                     ??add_item_to_array_0:
   \   00000028   000092E5           LDR      R0,[R2, #+0]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   FBFFFF1A           BNE      ??add_item_to_array_2
   1873                  suffix_object(child, item);
   \   00000034   001082E5           STR      R1,[R2, #+0]
   \   00000038   042081E5           STR      R2,[R1, #+4]
   1874              }
   1875          
   1876              return true;
   \                     ??add_item_to_array_1:
   \   0000003C   0100A0E3           MOV      R0,#+1
   \   00000040   1EFF2FE1           BX       LR               ;; return
   1877          }
   1878          
   1879          /* Add item to array/object. */

   \                                 In segment CODE, align 4, keep-with-next
   1880          CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
   1881          {
   1882              add_item_to_array(array, item);
   \                     cJSON_AddItemToArray:
   \   00000000   ........           B        add_item_to_array  ;; tailcall
   1883          }
   1884          
   1885          #if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
   1886              #pragma GCC diagnostic push
   1887          #endif
   1888          #ifdef __GNUC__
   1889          #pragma GCC diagnostic ignored "-Wcast-qual"
   1890          #endif
   1891          /* helper function to cast away const */
   1892          static void* cast_away_const(const void* string)
   1893          {
   1894              return (void*)string;
   1895          }
   1896          #if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
   1897              #pragma GCC diagnostic pop
   1898          #endif
   1899          
   1900          

   \                                 In segment CODE, align 4, keep-with-next
   1901          static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
   1902          {
   \                     add_item_to_object:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   18009DE5           LDR      R0,[SP, #+24]
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0360A0E1           MOV      R6,R3
   1903              char *new_key = NULL;
   1904              int new_type = cJSON_Invalid;
   1905          
   1906              if ((object == NULL) || (string == NULL) || (item == NULL))
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   00005713           CMPNE    R7,#+0
   \   00000020   00005513           CMPNE    R5,#+0
   \   00000024   0100001A           BNE      ??add_item_to_object_0
   1907              {
   1908                  return false;
   \                     ??add_item_to_object_1:
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   F081BDE8           POP      {R4-R8,PC}
   1909              }
   1910          
   1911              if (constant_key)
   \                     ??add_item_to_object_0:
   \   00000030   000050E3           CMP      R0,#+0
   1912              {
   1913                  new_key = (char*)cast_away_const(string);
   1914                  new_type = item->type | cJSON_StringIsConst;
   \   00000034   0C009515           LDRNE    R0,[R5, #+12]
   \   00000038   808F8013           ORRNE    R8,R0,#0x200
   \   0000003C   0600001A           BNE      ??add_item_to_object_2
   1915              }
   1916              else
   1917              {
   1918                  new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
   \   00000040   0610A0E1           MOV      R1,R6
   \   00000044   0700A0E1           MOV      R0,R7
   \   00000048   ........           BL       cJSON_strdup
   \   0000004C   0070B0E1           MOVS     R7,R0
   1919                  if (new_key == NULL)
   \   00000050   F4FFFF0A           BEQ      ??add_item_to_object_1
   1920                  {
   1921                      return false;
   1922                  }
   1923          
   1924                  new_type = item->type & ~cJSON_StringIsConst;
   \   00000054   0C0095E5           LDR      R0,[R5, #+12]
   \   00000058   808FC0E3           BIC      R8,R0,#0x200
   1925              }
   1926          
   1927              if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
   \                     ??add_item_to_object_2:
   \   0000005C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000060   800F10E3           TST      R0,#0x200
   \   00000064   0400001A           BNE      ??add_item_to_object_3
   \   00000068   200095E5           LDR      R0,[R5, #+32]
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0100000A           BEQ      ??add_item_to_object_3
   1928              {
   1929                  hooks->deallocate(item->string);
   \   00000074   041096E5           LDR      R1,[R6, #+4]
   \   00000078   31FF2FE1           BLX      R1
   1930              }
   1931          
   1932              item->string = new_key;
   \                     ??add_item_to_object_3:
   \   0000007C   207085E5           STR      R7,[R5, #+32]
   1933              item->type = new_type;
   \   00000080   0C8085E5           STR      R8,[R5, #+12]
   1934          
   1935              return add_item_to_array(object, item);
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       add_item_to_array
   \   00000090   F081BDE8           POP      {R4-R8,PC}       ;; return
   1936          }
   1937          

   \                                 In segment CODE, align 4, keep-with-next
   1938          CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
   1939          {
   \                     cJSON_AddItemToObject:
   \   00000000   00402DE9           PUSH     {LR}
   1940              add_item_to_object(object, string, item, &global_hooks, false);
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   08002DE9           PUSH     {R3}
   \   0000000C   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000010   ........           BL       add_item_to_object
   1941          }
   \   00000014   0180BDE8           POP      {R0,PC}          ;; return
   1942          
   1943          /* Add an item to an object with constant string as key */

   \                                 In segment CODE, align 4, keep-with-next
   1944          CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
   1945          {
   \                     cJSON_AddItemToObjectCS:
   \   00000000   00402DE9           PUSH     {LR}
   1946              add_item_to_object(object, string, item, &global_hooks, true);
   \   00000004   0130A0E3           MOV      R3,#+1
   \   00000008   08002DE9           PUSH     {R3}
   \   0000000C   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000010   ........           BL       add_item_to_object
   1947          }
   \   00000014   0180BDE8           POP      {R0,PC}          ;; return
   1948          

   \                                 In segment CODE, align 4, keep-with-next
   1949          CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
   1950          {
   \                     cJSON_AddItemReferenceToArray:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1951              if (array == NULL)
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   7080BD08           POPEQ    {R4-R6,PC}
   1952              {
   1953                  return;
   1954              }
   1955          
   1956              add_item_to_array(array, create_reference(item, &global_hooks));
   \   00000014   000055E3           CMP      R5,#+0
   \   00000018   0100001A           BNE      ??cJSON_AddItemReferenceToArray_0
   \                     ??cJSON_AddItemReferenceToArray_1:
   \   0000001C   0060A0E3           MOV      R6,#+0
   \   00000020   0D0000EA           B        ??cJSON_AddItemReferenceToArray_2
   \                     ??cJSON_AddItemReferenceToArray_0:
   \   00000024   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   00000028   ........           BL       cJSON_New_Item
   \   0000002C   0060B0E1           MOVS     R6,R0
   \   00000030   F9FFFF0A           BEQ      ??cJSON_AddItemReferenceToArray_1
   \   00000034   2420A0E3           MOV      R2,#+36
   \   00000038   0510A0E1           MOV      R1,R5
   \   0000003C   1E0100EF           SWI      +286
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   200086E5           STR      R0,[R6, #+32]
   \   00000048   0C1096E5           LDR      R1,[R6, #+12]
   \   0000004C   401F81E3           ORR      R1,R1,#0x100
   \   00000050   0C1086E5           STR      R1,[R6, #+12]
   \   00000054   040086E5           STR      R0,[R6, #+4]
   \   00000058   000086E5           STR      R0,[R6, #+0]
   \                     ??cJSON_AddItemReferenceToArray_2:
   \   0000005C   0610A0E1           MOV      R1,R6
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       add_item_to_array
   1957          }
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
   1958          

   \                                 In segment CODE, align 4, keep-with-next
   1959          CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
   1960          {
   \                     cJSON_AddItemReferenceToObject:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0280A0E1           MOV      R8,R2
   1961              if ((object == NULL) || (string == NULL))
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   00005513           CMPNE    R5,#+0
   \   00000018   F083BD08           POPEQ    {R4-R9,PC}
   1962              {
   1963                  return;
   1964              }
   1965          
   1966              add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
   \   0000001C   ........           LDR      R6,??DataTable38  ;; global_hooks
   \   00000020   0070A0E3           MOV      R7,#+0
   \   00000024   000058E3           CMP      R8,#+0
   \   00000028   0D00000A           BEQ      ??cJSON_AddItemReferenceToObject_0
   \   0000002C   0600A0E1           MOV      R0,R6
   \   00000030   ........           BL       cJSON_New_Item
   \   00000034   0090B0E1           MOVS     R9,R0
   \   00000038   0900000A           BEQ      ??cJSON_AddItemReferenceToObject_0
   \   0000003C   2420A0E3           MOV      R2,#+36
   \   00000040   0810A0E1           MOV      R1,R8
   \   00000044   1E0100EF           SWI      +286
   \   00000048   207089E5           STR      R7,[R9, #+32]
   \   0000004C   0C0099E5           LDR      R0,[R9, #+12]
   \   00000050   400F80E3           ORR      R0,R0,#0x100
   \   00000054   0C0089E5           STR      R0,[R9, #+12]
   \   00000058   047089E5           STR      R7,[R9, #+4]
   \   0000005C   007089E5           STR      R7,[R9, #+0]
   \   00000060   0970A0E1           MOV      R7,R9
   \                     ??cJSON_AddItemReferenceToObject_0:
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   01002DE9           PUSH     {R0}
   \   0000006C   0630A0E1           MOV      R3,R6
   \   00000070   0720A0E1           MOV      R2,R7
   \   00000074   0510A0E1           MOV      R1,R5
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   ........           BL       add_item_to_object
   1967          }
   \   00000080   04D08DE2           ADD      SP,SP,#+4
   \   00000084   F083BDE8           POP      {R4-R9,PC}       ;; return
   1968          

   \                                 In segment CODE, align 4, keep-with-next
   1969          CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
   1970          {
   \                     cJSON_AddNullToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1971              cJSON *null = cJSON_CreateNull();
   \   0000000C   ........           BL       cJSON_CreateNull
   1972              if (add_item_to_object(object, name, null, &global_hooks, false))
   \   00000010   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000014   0060A0E1           MOV      R6,R0
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   01002DE9           PUSH     {R0}
   \   00000020   0620A0E1           MOV      R2,R6
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       add_item_to_object
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   04D08DE2           ADD      SP,SP,#+4
   \   00000038   0600A0E1           MOV      R0,R6
   1973              {
   1974                  return null;
   \   0000003C   7080BD18           POPNE    {R4-R6,PC}
   1975              }
   1976          
   1977              cJSON_Delete(null);
   \   00000040   ........           BL       cJSON_Delete
   1978              return NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1979          }
   1980          

   \                                 In segment CODE, align 4, keep-with-next
   1981          CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
   1982          {
   \                     cJSON_AddTrueToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1983              cJSON *true_item = cJSON_CreateTrue();
   \   0000000C   ........           BL       cJSON_CreateTrue
   1984              if (add_item_to_object(object, name, true_item, &global_hooks, false))
   \   00000010   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000014   0060A0E1           MOV      R6,R0
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   01002DE9           PUSH     {R0}
   \   00000020   0620A0E1           MOV      R2,R6
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       add_item_to_object
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   04D08DE2           ADD      SP,SP,#+4
   \   00000038   0600A0E1           MOV      R0,R6
   1985              {
   1986                  return true_item;
   \   0000003C   7080BD18           POPNE    {R4-R6,PC}
   1987              }
   1988          
   1989              cJSON_Delete(true_item);
   \   00000040   ........           BL       cJSON_Delete
   1990              return NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1991          }
   1992          

   \                                 In segment CODE, align 4, keep-with-next
   1993          CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
   1994          {
   \                     cJSON_AddFalseToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1995              cJSON *false_item = cJSON_CreateFalse();
   \   0000000C   ........           BL       cJSON_CreateFalse
   1996              if (add_item_to_object(object, name, false_item, &global_hooks, false))
   \   00000010   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000014   0060A0E1           MOV      R6,R0
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   01002DE9           PUSH     {R0}
   \   00000020   0620A0E1           MOV      R2,R6
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       add_item_to_object
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   04D08DE2           ADD      SP,SP,#+4
   \   00000038   0600A0E1           MOV      R0,R6
   1997              {
   1998                  return false_item;
   \   0000003C   7080BD18           POPNE    {R4-R6,PC}
   1999              }
   2000          
   2001              cJSON_Delete(false_item);
   \   00000040   ........           BL       cJSON_Delete
   2002              return NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   2003          }
   2004          

   \                                 In segment CODE, align 4, keep-with-next
   2005          CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
   2006          {
   \                     cJSON_AddBoolToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0200A0E1           MOV      R0,R2
   2007              cJSON *bool_item = cJSON_CreateBool(boolean);
   \   00000010   ........           BL       cJSON_CreateBool
   2008              if (add_item_to_object(object, name, bool_item, &global_hooks, false))
   \   00000014   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000018   0060A0E1           MOV      R6,R0
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   01002DE9           PUSH     {R0}
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       add_item_to_object
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   04D08DE2           ADD      SP,SP,#+4
   \   0000003C   0600A0E1           MOV      R0,R6
   2009              {
   2010                  return bool_item;
   \   00000040   7080BD18           POPNE    {R4-R6,PC}
   2011              }
   2012          
   2013              cJSON_Delete(bool_item);
   \   00000044   ........           BL       cJSON_Delete
   2014              return NULL;
   \   00000048   0000A0E3           MOV      R0,#+0
   \   0000004C   7080BDE8           POP      {R4-R6,PC}       ;; return
   2015          }
   2016          

   \                                 In segment CODE, align 4, keep-with-next
   2017          CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
   2018          {
   \                     cJSON_AddNumberToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   2019              cJSON *number_item = cJSON_CreateNumber(number);
   \   0000000C   0200A0E1           MOV      R0,R2
   \   00000010   0310A0E1           MOV      R1,R3
   \   00000014   ........           BL       cJSON_CreateNumber
   2020              if (add_item_to_object(object, name, number_item, &global_hooks, false))
   \   00000018   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   0000001C   0060A0E1           MOV      R6,R0
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   01002DE9           PUSH     {R0}
   \   00000028   0620A0E1           MOV      R2,R6
   \   0000002C   0510A0E1           MOV      R1,R5
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       add_item_to_object
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   04D08DE2           ADD      SP,SP,#+4
   \   00000040   0600A0E1           MOV      R0,R6
   2021              {
   2022                  return number_item;
   \   00000044   7080BD18           POPNE    {R4-R6,PC}
   2023              }
   2024          
   2025              cJSON_Delete(number_item);
   \   00000048   ........           BL       cJSON_Delete
   2026              return NULL;
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
   2027          }
   2028          

   \                                 In segment CODE, align 4, keep-with-next
   2029          CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
   2030          {
   \                     cJSON_AddStringToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0200A0E1           MOV      R0,R2
   2031              cJSON *string_item = cJSON_CreateString(string);
   \   00000010   ........           BL       cJSON_CreateString
   2032              if (add_item_to_object(object, name, string_item, &global_hooks, false))
   \   00000014   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000018   0060A0E1           MOV      R6,R0
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   01002DE9           PUSH     {R0}
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       add_item_to_object
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   04D08DE2           ADD      SP,SP,#+4
   \   0000003C   0600A0E1           MOV      R0,R6
   2033              {
   2034                  return string_item;
   \   00000040   7080BD18           POPNE    {R4-R6,PC}
   2035              }
   2036          
   2037              cJSON_Delete(string_item);
   \   00000044   ........           BL       cJSON_Delete
   2038              return NULL;
   \   00000048   0000A0E3           MOV      R0,#+0
   \   0000004C   7080BDE8           POP      {R4-R6,PC}       ;; return
   2039          }
   2040          

   \                                 In segment CODE, align 4, keep-with-next
   2041          CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
   2042          {
   \                     cJSON_AddRawToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0200A0E1           MOV      R0,R2
   2043              cJSON *raw_item = cJSON_CreateRaw(raw);
   \   00000010   ........           BL       cJSON_CreateRaw
   2044              if (add_item_to_object(object, name, raw_item, &global_hooks, false))
   \   00000014   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000018   0060A0E1           MOV      R6,R0
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   01002DE9           PUSH     {R0}
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       add_item_to_object
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   04D08DE2           ADD      SP,SP,#+4
   \   0000003C   0600A0E1           MOV      R0,R6
   2045              {
   2046                  return raw_item;
   \   00000040   7080BD18           POPNE    {R4-R6,PC}
   2047              }
   2048          
   2049              cJSON_Delete(raw_item);
   \   00000044   ........           BL       cJSON_Delete
   2050              return NULL;
   \   00000048   0000A0E3           MOV      R0,#+0
   \   0000004C   7080BDE8           POP      {R4-R6,PC}       ;; return
   2051          }
   2052          

   \                                 In segment CODE, align 4, keep-with-next
   2053          CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
   2054          {
   \                     cJSON_AddObjectToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   2055              cJSON *object_item = cJSON_CreateObject();
   \   0000000C   ........           BL       cJSON_CreateObject
   2056              if (add_item_to_object(object, name, object_item, &global_hooks, false))
   \   00000010   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000014   0060A0E1           MOV      R6,R0
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   01002DE9           PUSH     {R0}
   \   00000020   0620A0E1           MOV      R2,R6
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       add_item_to_object
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   04D08DE2           ADD      SP,SP,#+4
   \   00000038   0600A0E1           MOV      R0,R6
   2057              {
   2058                  return object_item;
   \   0000003C   7080BD18           POPNE    {R4-R6,PC}
   2059              }
   2060          
   2061              cJSON_Delete(object_item);
   \   00000040   ........           BL       cJSON_Delete
   2062              return NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   2063          }
   2064          

   \                                 In segment CODE, align 4, keep-with-next
   2065          CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
   2066          {
   \                     cJSON_AddArrayToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   2067              cJSON *array = cJSON_CreateArray();
   \   0000000C   ........           BL       cJSON_CreateArray
   2068              if (add_item_to_object(object, name, array, &global_hooks, false))
   \   00000010   ........           LDR      R3,??DataTable38  ;; global_hooks
   \   00000014   0060A0E1           MOV      R6,R0
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   01002DE9           PUSH     {R0}
   \   00000020   0620A0E1           MOV      R2,R6
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       add_item_to_object
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   04D08DE2           ADD      SP,SP,#+4
   \   00000038   0600A0E1           MOV      R0,R6
   2069              {
   2070                  return array;
   \   0000003C   7080BD18           POPNE    {R4-R6,PC}
   2071              }
   2072          
   2073              cJSON_Delete(array);
   \   00000040   ........           BL       cJSON_Delete
   2074              return NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   2075          }
   2076          

   \                                 In segment CODE, align 4, keep-with-next
   2077          CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
   2078          {
   2079              if ((parent == NULL) || (item == NULL))
   \                     cJSON_DetachItemViaPointer:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1EFF2F01           BXEQ     LR
   \   00000008   000051E3           CMP      R1,#+0
   2080              {
   2081                  return NULL;
   \   0000000C   0000A003           MOVEQ    R0,#+0
   \   00000010   1EFF2F01           BXEQ     LR
   2082              }
   2083          
   2084              if (item->prev != NULL)
   \   00000014   042091E5           LDR      R2,[R1, #+4]
   \   00000018   000052E3           CMP      R2,#+0
   2085              {
   2086                  /* not the first element */
   2087                  item->prev->next = item->next;
   \   0000001C   00309115           LDRNE    R3,[R1, #+0]
   \   00000020   00308215           STRNE    R3,[R2, #+0]
   2088              }
   2089              if (item->next != NULL)
   \   00000024   002091E5           LDR      R2,[R1, #+0]
   \   00000028   000052E3           CMP      R2,#+0
   2090              {
   2091                  /* not the last element */
   2092                  item->next->prev = item->prev;
   \   0000002C   04309115           LDRNE    R3,[R1, #+4]
   \   00000030   04308215           STRNE    R3,[R2, #+4]
   2093              }
   2094          
   2095              if (item == parent->child)
   \   00000034   082090E5           LDR      R2,[R0, #+8]
   \   00000038   020051E1           CMP      R1,R2
   2096              {
   2097                  /* first element */
   2098                  parent->child = item->next;
   \   0000003C   00209105           LDREQ    R2,[R1, #+0]
   \   00000040   08208005           STREQ    R2,[R0, #+8]
   2099              }
   2100              /* make sure the detached item doesn't point anywhere anymore */
   2101              item->prev = NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   040081E5           STR      R0,[R1, #+4]
   2102              item->next = NULL;
   \   0000004C   000081E5           STR      R0,[R1, #+0]
   2103          
   2104              return item;
   \   00000050   0100A0E1           MOV      R0,R1
   \   00000054   1EFF2FE1           BX       LR               ;; return
   2105          }
   2106          

   \                                 In segment CODE, align 4, keep-with-next
   2107          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
   2108          {
   2109              if (which < 0)
   \                     cJSON_DetachItemFromArray:
   \   00000000   000051E3           CMP      R1,#+0
   2110              {
   2111                  return NULL;
   \   00000004   0000A043           MOVMI    R0,#+0
   \   00000008   1EFF2F41           BXMI     LR
   2112              }
   2113          
   2114              return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0020A003           MOVEQ    R2,#+0
   \   00000014   0600000A           BEQ      ??cJSON_DetachItemFromArray_0
   \   00000018   082090E5           LDR      R2,[R0, #+8]
   \   0000001C   010000EA           B        ??cJSON_DetachItemFromArray_1
   \                     ??cJSON_DetachItemFromArray_2:
   \   00000020   002092E5           LDR      R2,[R2, #+0]
   \   00000024   011041E2           SUB      R1,R1,#+1
   \                     ??cJSON_DetachItemFromArray_1:
   \   00000028   000052E3           CMP      R2,#+0
   \   0000002C   00005113           CMPNE    R1,#+0
   \   00000030   FAFFFF1A           BNE      ??cJSON_DetachItemFromArray_2
   \                     ??cJSON_DetachItemFromArray_0:
   \   00000034   0210A0E1           MOV      R1,R2
   \   00000038   ........           B        cJSON_DetachItemViaPointer  ;; tailcall
   2115          }
   2116          

   \                                 In segment CODE, align 4, keep-with-next
   2117          CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
   2118          {
   \                     cJSON_DeleteItemFromArray:
   \   00000000   00402DE9           PUSH     {LR}
   2119              cJSON_Delete(cJSON_DetachItemFromArray(array, which));
   \   00000004   ........           BL       cJSON_DetachItemFromArray
   \   00000008   0040BDE8           POP      {LR}             ;; Pop
   \   0000000C   ........           B        cJSON_Delete     ;; tailcall
   2120          }
   2121          

   \                                 In segment CODE, align 4, keep-with-next
   2122          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
   2123          {
   \                     cJSON_DetachItemFromObject:
   \   00000000   10402DE9           PUSH     {R4,LR}
   2124              cJSON *to_detach = cJSON_GetObjectItem(object, string);
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   ........           BL       get_object_item
   2125          
   2126              return cJSON_DetachItemViaPointer(object, to_detach);
   \   00000010   0010A0E1           MOV      R1,R0
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   1040BDE8           POP      {R4,LR}          ;; Pop
   \   0000001C   ........           B        cJSON_DetachItemViaPointer  ;; tailcall
   2127          }
   2128          

   \                                 In segment CODE, align 4, keep-with-next
   2129          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
   2130          {
   \                     cJSON_DetachItemFromObjectCaseSensitive:
   \   00000000   10402DE9           PUSH     {R4,LR}
   2131              cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
   \   00000004   0120A0E3           MOV      R2,#+1
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   ........           BL       get_object_item
   2132          
   2133              return cJSON_DetachItemViaPointer(object, to_detach);
   \   00000010   0010A0E1           MOV      R1,R0
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   1040BDE8           POP      {R4,LR}          ;; Pop
   \   0000001C   ........           B        cJSON_DetachItemViaPointer  ;; tailcall
   2134          }
   2135          

   \                                 In segment CODE, align 4, keep-with-next
   2136          CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
   2137          {
   \                     cJSON_DeleteItemFromObject:
   \   00000000   00402DE9           PUSH     {LR}
   2138              cJSON_Delete(cJSON_DetachItemFromObject(object, string));
   \   00000004   ........           BL       cJSON_DetachItemFromObject
   \   00000008   0040BDE8           POP      {LR}             ;; Pop
   \   0000000C   ........           B        cJSON_Delete     ;; tailcall
   2139          }
   2140          

   \                                 In segment CODE, align 4, keep-with-next
   2141          CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
   2142          {
   \                     cJSON_DeleteItemFromObjectCaseSensitive:
   \   00000000   00402DE9           PUSH     {LR}
   2143              cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
   \   00000004   ........           BL       cJSON_DetachItemFromObjectCaseSensitive
   \   00000008   0040BDE8           POP      {LR}             ;; Pop
   \   0000000C   ........           B        cJSON_Delete     ;; tailcall
   2144          }
   2145          
   2146          /* Replace array/object items with new ones. */

   \                                 In segment CODE, align 4, keep-with-next
   2147          CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
   2148          {
   \                     cJSON_InsertItemInArray:
   \   00000000   00402DE9           PUSH     {LR}
   2149              cJSON *after_inserted = NULL;
   2150          
   2151              if (which < 0)
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0080BD48           POPMI    {PC}
   2152              {
   2153                  return;
   2154              }
   2155          
   2156              after_inserted = get_array_item(array, (size_t)which);
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0030A003           MOVEQ    R3,#+0
   \   00000014   0600000A           BEQ      ??cJSON_InsertItemInArray_0
   \   00000018   083090E5           LDR      R3,[R0, #+8]
   \   0000001C   010000EA           B        ??cJSON_InsertItemInArray_1
   \                     ??cJSON_InsertItemInArray_2:
   \   00000020   003093E5           LDR      R3,[R3, #+0]
   \   00000024   011041E2           SUB      R1,R1,#+1
   \                     ??cJSON_InsertItemInArray_1:
   \   00000028   000053E3           CMP      R3,#+0
   \   0000002C   00005113           CMPNE    R1,#+0
   \   00000030   FAFFFF1A           BNE      ??cJSON_InsertItemInArray_2
   2157              if (after_inserted == NULL)
   \                     ??cJSON_InsertItemInArray_0:
   \   00000034   000053E3           CMP      R3,#+0
   \   00000038   0200001A           BNE      ??cJSON_InsertItemInArray_3
   2158              {
   2159                  add_item_to_array(array, newitem);
   \   0000003C   0210A0E1           MOV      R1,R2
   \   00000040   ........           BL       add_item_to_array
   2160                  return;
   \   00000044   0080BDE8           POP      {PC}
   2161              }
   2162          
   2163              newitem->next = after_inserted;
   \                     ??cJSON_InsertItemInArray_3:
   \   00000048   003082E5           STR      R3,[R2, #+0]
   2164              newitem->prev = after_inserted->prev;
   \   0000004C   041093E5           LDR      R1,[R3, #+4]
   \   00000050   041082E5           STR      R1,[R2, #+4]
   2165              after_inserted->prev = newitem;
   \   00000054   042083E5           STR      R2,[R3, #+4]
   2166              if (after_inserted == array->child)
   \   00000058   081090E5           LDR      R1,[R0, #+8]
   \   0000005C   010053E1           CMP      R3,R1
   2167              {
   2168                  array->child = newitem;
   \   00000060   08208005           STREQ    R2,[R0, #+8]
   \   00000064   0080BD08           POPEQ    {PC}
   2169              }
   2170              else
   2171              {
   2172                  newitem->prev->next = newitem;
   \   00000068   040092E5           LDR      R0,[R2, #+4]
   \   0000006C   002080E5           STR      R2,[R0, #+0]
   \   00000070   0080BDE8           POP      {PC}             ;; return
   2173              }
   2174          }
   2175          

   \                                 In segment CODE, align 4, keep-with-next
   2176          CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
   2177          {
   \                     cJSON_ReplaceItemViaPointer:
   \   00000000   00402DE9           PUSH     {LR}
   2178              if ((parent == NULL) || (replacement == NULL) || (item == NULL))
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0080BD08           POPEQ    {PC}
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   00005113           CMPNE    R1,#+0
   2179              {
   2180                  return false;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   0080BD08           POPEQ    {PC}
   2181              }
   2182          
   2183              if (replacement == item)
   \   0000001C   010052E1           CMP      R2,R1
   \   00000020   1000000A           BEQ      ??cJSON_ReplaceItemViaPointer_0
   2184              {
   2185                  return true;
   2186              }
   2187          
   2188              replacement->next = item->next;
   \   00000024   003091E5           LDR      R3,[R1, #+0]
   \   00000028   003082E5           STR      R3,[R2, #+0]
   2189              replacement->prev = item->prev;
   \   0000002C   04C091E5           LDR      R12,[R1, #+4]
   2190          
   2191              if (replacement->next != NULL)
   \   00000030   000053E3           CMP      R3,#+0
   \   00000034   04C082E5           STR      R12,[R2, #+4]
   2192              {
   2193                  replacement->next->prev = replacement;
   \   00000038   04208315           STRNE    R2,[R3, #+4]
   2194              }
   2195              if (replacement->prev != NULL)
   \   0000003C   043092E5           LDR      R3,[R2, #+4]
   \   00000040   000053E3           CMP      R3,#+0
   2196              {
   2197                  replacement->prev->next = replacement;
   \   00000044   00208315           STRNE    R2,[R3, #+0]
   2198              }
   2199              if (parent->child == item)
   \   00000048   083090E5           LDR      R3,[R0, #+8]
   \   0000004C   010053E1           CMP      R3,R1
   2200              {
   2201                  parent->child = replacement;
   \   00000050   08208005           STREQ    R2,[R0, #+8]
   2202              }
   2203          
   2204              item->next = NULL;
   \   00000054   0000A0E3           MOV      R0,#+0
   \   00000058   000081E5           STR      R0,[R1, #+0]
   2205              item->prev = NULL;
   \   0000005C   040081E5           STR      R0,[R1, #+4]
   2206              cJSON_Delete(item);
   \   00000060   0100A0E1           MOV      R0,R1
   \   00000064   ........           BL       cJSON_Delete
   2207          
   2208              return true;
   \                     ??cJSON_ReplaceItemViaPointer_0:
   \   00000068   0100A0E3           MOV      R0,#+1
   \   0000006C   0080BDE8           POP      {PC}             ;; return
   2209          }
   2210          

   \                                 In segment CODE, align 4, keep-with-next
   2211          CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
   2212          {
   \                     cJSON_ReplaceItemInArray:
   \   00000000   00402DE9           PUSH     {LR}
   2213              if (which < 0)
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0080BD48           POPMI    {PC}
   2214              {
   2215                  return;
   2216              }
   2217          
   2218              cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0030A003           MOVEQ    R3,#+0
   \   00000014   0600000A           BEQ      ??cJSON_ReplaceItemInArray_0
   \   00000018   083090E5           LDR      R3,[R0, #+8]
   \   0000001C   010000EA           B        ??cJSON_ReplaceItemInArray_1
   \                     ??cJSON_ReplaceItemInArray_2:
   \   00000020   003093E5           LDR      R3,[R3, #+0]
   \   00000024   011041E2           SUB      R1,R1,#+1
   \                     ??cJSON_ReplaceItemInArray_1:
   \   00000028   000053E3           CMP      R3,#+0
   \   0000002C   00005113           CMPNE    R1,#+0
   \   00000030   FAFFFF1A           BNE      ??cJSON_ReplaceItemInArray_2
   \                     ??cJSON_ReplaceItemInArray_0:
   \   00000034   0310A0E1           MOV      R1,R3
   \   00000038   ........           BL       cJSON_ReplaceItemViaPointer
   2219          }
   \   0000003C   0080BDE8           POP      {PC}             ;; return
   2220          
   2221          static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
   2222          {
   2223              if ((replacement == NULL) || (string == NULL))
   2224              {
   2225                  return false;
   2226              }
   2227          
   2228              /* replace the name in the replacement */
   2229              if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
   2230              {
   2231                  cJSON_free(replacement->string);
   2232              }
   2233              replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
   2234              replacement->type &= ~cJSON_StringIsConst;
   2235          
   2236              cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
   2237          
   2238              return true;
   2239          }
   2240          

   \                                 In segment CODE, align 4, keep-with-next
   2241          CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
   2242          {
   \                     cJSON_ReplaceItemInObject:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
   2243              replace_item_in_object(object, string, newitem, false);
   \   00000010   00005513           CMPNE    R5,#+0
   \   00000014   F080BD08           POPEQ    {R4-R7,PC}
   \   00000018   0C0096E5           LDR      R0,[R6, #+12]
   \   0000001C   ........           LDR      R7,??DataTable38  ;; global_hooks
   \   00000020   800F10E3           TST      R0,#0x200
   \   00000024   0400001A           BNE      ??cJSON_ReplaceItemInObject_0
   \   00000028   200096E5           LDR      R0,[R6, #+32]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0100000A           BEQ      ??cJSON_ReplaceItemInObject_0
   \   00000034   041097E5           LDR      R1,[R7, #+4]
   \   00000038   31FF2FE1           BLX      R1
   \                     ??cJSON_ReplaceItemInObject_0:
   \   0000003C   0710A0E1           MOV      R1,R7
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   ........           BL       cJSON_strdup
   \   00000048   200086E5           STR      R0,[R6, #+32]
   \   0000004C   0C0096E5           LDR      R0,[R6, #+12]
   \   00000050   0020A0E3           MOV      R2,#+0
   \   00000054   800FC0E3           BIC      R0,R0,#0x200
   \   00000058   0C0086E5           STR      R0,[R6, #+12]
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       get_object_item
   \   00000068   0010A0E1           MOV      R1,R0
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       cJSON_ReplaceItemViaPointer
   2244          }
   \   00000078   F080BDE8           POP      {R4-R7,PC}       ;; return
   2245          

   \                                 In segment CODE, align 4, keep-with-next
   2246          CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
   2247          {
   \                     cJSON_ReplaceItemInObjectCaseSensitive:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
   2248              replace_item_in_object(object, string, newitem, true);
   \   00000010   00005513           CMPNE    R5,#+0
   \   00000014   F080BD08           POPEQ    {R4-R7,PC}
   \   00000018   0C0096E5           LDR      R0,[R6, #+12]
   \   0000001C   ........           LDR      R7,??DataTable38  ;; global_hooks
   \   00000020   800F10E3           TST      R0,#0x200
   \   00000024   0400001A           BNE      ??cJSON_ReplaceItemInObjectCaseSensitive_0
   \   00000028   200096E5           LDR      R0,[R6, #+32]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0100000A           BEQ      ??cJSON_ReplaceItemInObjectCaseSensitive_0
   \   00000034   041097E5           LDR      R1,[R7, #+4]
   \   00000038   31FF2FE1           BLX      R1
   \                     ??cJSON_ReplaceItemInObjectCaseSensitive_0:
   \   0000003C   0710A0E1           MOV      R1,R7
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   ........           BL       cJSON_strdup
   \   00000048   200086E5           STR      R0,[R6, #+32]
   \   0000004C   0C0096E5           LDR      R0,[R6, #+12]
   \   00000050   0120A0E3           MOV      R2,#+1
   \   00000054   800FC0E3           BIC      R0,R0,#0x200
   \   00000058   0C0086E5           STR      R0,[R6, #+12]
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       get_object_item
   \   00000068   0010A0E1           MOV      R1,R0
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       cJSON_ReplaceItemViaPointer
   2249          }
   \   00000078   F080BDE8           POP      {R4-R7,PC}       ;; return
   2250          
   2251          /* Create basic types: */

   \                                 In segment CODE, align 4, keep-with-next
   2252          CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
   2253          {
   2254              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateNull:
   \   00000000   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2255              if(item)
   \   0000000C   000050E3           CMP      R0,#+0
   2256              {
   2257                  item->type = cJSON_NULL;
   \   00000010   0410A013           MOVNE    R1,#+4
   \   00000014   0C108015           STRNE    R1,[R0, #+12]
   2258              }
   2259          
   2260              return item;
   \   00000018   0080BDE8           POP      {PC}             ;; return
   2261          }
   2262          

   \                                 In segment CODE, align 4, keep-with-next
   2263          CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
   2264          {
   2265              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateTrue:
   \   00000000   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2266              if(item)
   \   0000000C   000050E3           CMP      R0,#+0
   2267              {
   2268                  item->type = cJSON_True;
   \   00000010   0210A013           MOVNE    R1,#+2
   \   00000014   0C108015           STRNE    R1,[R0, #+12]
   2269              }
   2270          
   2271              return item;
   \   00000018   0080BDE8           POP      {PC}             ;; return
   2272          }
   2273          

   \                                 In segment CODE, align 4, keep-with-next
   2274          CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
   2275          {
   2276              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateFalse:
   \   00000000   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2277              if(item)
   \   0000000C   000050E3           CMP      R0,#+0
   2278              {
   2279                  item->type = cJSON_False;
   \   00000010   0110A013           MOVNE    R1,#+1
   \   00000014   0C108015           STRNE    R1,[R0, #+12]
   2280              }
   2281          
   2282              return item;
   \   00000018   0080BDE8           POP      {PC}             ;; return
   2283          }
   2284          

   \                                 In segment CODE, align 4, keep-with-next
   2285          CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool b)
   2286          {
   \                     cJSON_CreateBool:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2287              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   0000000C   ........           BL       cJSON_New_Item
   2288              if(item)
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1080BD08           POPEQ    {R4,PC}
   2289              {
   2290                  item->type = b ? cJSON_True : cJSON_False;
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   0210A013           MOVNE    R1,#+2
   \   00000020   0110A003           MOVEQ    R1,#+1
   \   00000024   0C1080E5           STR      R1,[R0, #+12]
   2291              }
   2292          
   2293              return item;
   \   00000028   1080BDE8           POP      {R4,PC}          ;; return
   2294          }
   2295          

   \                                 In segment CODE, align 4, keep-with-next
   2296          CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
   2297          {
   \                     cJSON_CreateNumber:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2298              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   ........           BL       cJSON_New_Item
   \   00000014   0060B0E1           MOVS     R6,R0
   2299              if(item)
   \   00000018   1A00000A           BEQ      ??cJSON_CreateNumber_0
   2300              {
   2301                  item->type = cJSON_Number;
   \   0000001C   0800A0E3           MOV      R0,#+8
   \   00000020   0C0086E5           STR      R0,[R6, #+12]
   2302                  item->valuedouble = num;
   \   00000024   184086E5           STR      R4,[R6, #+24]
   \   00000028   1C5086E5           STR      R5,[R6, #+28]
   2303          
   2304                  /* use saturation in case of overflow */
   2305                  if (num >= INT_MAX)
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   C024A0E3           MOV      R2,#-1073741824
   \   00000038   FF2582E3           ORR      R2,R2,#0x3FC00000
   \   0000003C   B034E0E3           MVN      R3,#-1342177280
   \   00000040   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000044   ........           _BLF     __dGreaterEqual,??__dGreaterEqual??rA
   \   00000048   000050E3           CMP      R0,#+0
   2306                  {
   2307                      item->valueint = INT_MAX;
   \   0000004C   8004E013           MVNNE    R0,#-2147483648
   \   00000050   0B00001A           BNE      ??cJSON_CreateNumber_1
   2308                  }
   2309                  else if (num <= (double)INT_MIN)
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   0510A0E1           MOV      R1,R5
   \   0000005C   0120E0E3           MVN      R2,#+1
   \   00000060   C035E0E3           MVN      R3,#+805306368
   \   00000064   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000068   ........           _BLF     __dLess,??__dLess??rA
   \   0000006C   000050E3           CMP      R0,#+0
   2310                  {
   2311                      item->valueint = INT_MIN;
   \   00000070   8004A013           MOVNE    R0,#-2147483648
   \   00000074   0200001A           BNE      ??cJSON_CreateNumber_1
   2312                  }
   2313                  else
   2314                  {
   2315                      item->valueint = (int)num;
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   0510A0E1           MOV      R1,R5
   \   00000080   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \                     ??cJSON_CreateNumber_1:
   \   00000084   140086E5           STR      R0,[R6, #+20]
   2316                  }
   2317              }
   2318          
   2319              return item;
   \                     ??cJSON_CreateNumber_0:
   \   00000088   0600A0E1           MOV      R0,R6
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
   2320          }
   2321          

   \                                 In segment CODE, align 4, keep-with-next
   2322          CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
   2323          {
   \                     cJSON_CreateString:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   2324              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000004   ........           LDR      R5,??DataTable38  ;; global_hooks
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           BL       cJSON_New_Item
   \   00000014   0060B0E1           MOVS     R6,R0
   2325              if(item)
   \   00000018   0B00000A           BEQ      ??cJSON_CreateString_0
   2326              {
   2327                  item->type = cJSON_String;
   \   0000001C   1000A0E3           MOV      R0,#+16
   \   00000020   0C0086E5           STR      R0,[R6, #+12]
   2328                  item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       cJSON_strdup
   \   00000030   100086E5           STR      R0,[R6, #+16]
   2329                  if(!item->valuestring)
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0300001A           BNE      ??cJSON_CreateString_0
   2330                  {
   2331                      cJSON_Delete(item);
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   ........           BL       cJSON_Delete
   2332                      return NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   7080BDE8           POP      {R4-R6,PC}
   2333                  }
   2334              }
   2335          
   2336              return item;
   \                     ??cJSON_CreateString_0:
   \   0000004C   0600A0E1           MOV      R0,R6
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
   2337          }
   2338          

   \                                 In segment CODE, align 4, keep-with-next
   2339          CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
   2340          {
   \                     cJSON_CreateStringReference:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2341              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   0000000C   ........           BL       cJSON_New_Item
   2342              if (item != NULL)
   \   00000010   000050E3           CMP      R0,#+0
   2343              {
   2344                  item->type = cJSON_String | cJSON_IsReference;
   \   00000014   441FA013           MOVNE    R1,#+272
   \   00000018   0C108015           STRNE    R1,[R0, #+12]
   2345                  item->valuestring = (char*)cast_away_const(string);
   \   0000001C   10408015           STRNE    R4,[R0, #+16]
   2346              }
   2347          
   2348              return item;
   \   00000020   1080BDE8           POP      {R4,PC}          ;; return
   2349          }
   2350          

   \                                 In segment CODE, align 4, keep-with-next
   2351          CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
   2352          {
   \                     cJSON_CreateObjectReference:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2353              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   0000000C   ........           BL       cJSON_New_Item
   2354              if (item != NULL) {
   \   00000010   000050E3           CMP      R0,#+0
   2355                  item->type = cJSON_Object | cJSON_IsReference;
   \   00000014   501FA013           MOVNE    R1,#+320
   \   00000018   0C108015           STRNE    R1,[R0, #+12]
   2356                  item->child = (cJSON*)cast_away_const(child);
   \   0000001C   08408015           STRNE    R4,[R0, #+8]
   2357              }
   2358          
   2359              return item;
   \   00000020   1080BDE8           POP      {R4,PC}          ;; return
   2360          }
   2361          

   \                                 In segment CODE, align 4, keep-with-next
   2362          CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
   \                     cJSON_CreateArrayReference:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2363              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   0000000C   ........           BL       cJSON_New_Item
   2364              if (item != NULL) {
   \   00000010   000050E3           CMP      R0,#+0
   2365                  item->type = cJSON_Array | cJSON_IsReference;
   \   00000014   481FA013           MOVNE    R1,#+288
   \   00000018   0C108015           STRNE    R1,[R0, #+12]
   2366                  item->child = (cJSON*)cast_away_const(child);
   \   0000001C   08408015           STRNE    R4,[R0, #+8]
   2367              }
   2368          
   2369              return item;
   \   00000020   1080BDE8           POP      {R4,PC}          ;; return
   2370          }
   2371          

   \                                 In segment CODE, align 4, keep-with-next
   2372          CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
   2373          {
   \                     cJSON_CreateRaw:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   2374              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000004   ........           LDR      R5,??DataTable38  ;; global_hooks
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           BL       cJSON_New_Item
   \   00000014   0060B0E1           MOVS     R6,R0
   2375              if(item)
   \   00000018   0B00000A           BEQ      ??cJSON_CreateRaw_0
   2376              {
   2377                  item->type = cJSON_Raw;
   \   0000001C   8000A0E3           MOV      R0,#+128
   \   00000020   0C0086E5           STR      R0,[R6, #+12]
   2378                  item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       cJSON_strdup
   \   00000030   100086E5           STR      R0,[R6, #+16]
   2379                  if(!item->valuestring)
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0300001A           BNE      ??cJSON_CreateRaw_0
   2380                  {
   2381                      cJSON_Delete(item);
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   ........           BL       cJSON_Delete
   2382                      return NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   7080BDE8           POP      {R4-R6,PC}
   2383                  }
   2384              }
   2385          
   2386              return item;
   \                     ??cJSON_CreateRaw_0:
   \   0000004C   0600A0E1           MOV      R0,R6
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
   2387          }
   2388          

   \                                 In segment CODE, align 4, keep-with-next
   2389          CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
   2390          {
   2391              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateArray:
   \   00000000   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2392              if(item)
   \   0000000C   000050E3           CMP      R0,#+0
   2393              {
   2394                  item->type=cJSON_Array;
   \   00000010   2010A013           MOVNE    R1,#+32
   \   00000014   0C108015           STRNE    R1,[R0, #+12]
   2395              }
   2396          
   2397              return item;
   \   00000018   0080BDE8           POP      {PC}             ;; return
   2398          }
   2399          

   \                                 In segment CODE, align 4, keep-with-next
   2400          CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
   2401          {
   2402              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateObject:
   \   00000000   ........           LDR      R0,??DataTable38  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2403              if (item)
   \   0000000C   000050E3           CMP      R0,#+0
   2404              {
   2405                  item->type = cJSON_Object;
   \   00000010   4010A013           MOVNE    R1,#+64
   \   00000014   0C108015           STRNE    R1,[R0, #+12]
   2406              }
   2407          
   2408              return item;
   \   00000018   0080BDE8           POP      {PC}             ;; return
   2409          }
   2410          
   2411          /* Create Arrays: */

   \                                 In segment CODE, align 4, keep-with-next
   2412          CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
   2413          {
   \                     cJSON_CreateIntArray:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   2414              size_t i = 0;
   2415              cJSON *n = NULL;
   2416              cJSON *p = NULL;
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0070A0E3           MOV      R7,#+0
   2417              cJSON *a = NULL;
   2418          
   2419              if ((count < 0) || (numbers == NULL))
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   1200004A           BMI      ??cJSON_CreateIntArray_0
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0000001A           BNE      ??cJSON_CreateIntArray_1
   2420              {
   2421                  return NULL;
   \                     ??cJSON_CreateIntArray_2:
   \   00000024   0F0000EA           B        ??cJSON_CreateIntArray_0
   2422              }
   2423          
   2424              a = cJSON_CreateArray();
   \                     ??cJSON_CreateIntArray_1:
   \   00000028   ........           BL       cJSON_CreateArray
   \   0000002C   0080B0E1           MOVS     R8,R0
   2425              for(i = 0; a && (i < (size_t)count); i++)
   \   00000030   0300001A           BNE      ??cJSON_CreateIntArray_3
   2426              {
   2427                  n = cJSON_CreateNumber(numbers[i]);
   2428                  if (!n)
   2429                  {
   2430                      cJSON_Delete(a);
   2431                      return NULL;
   2432                  }
   2433                  if(!i)
   2434                  {
   2435                      a->child = n;
   2436                  }
   2437                  else
   2438                  {
   2439                      suffix_object(p, n);
   2440                  }
   2441                  p = n;
   2442              }
   2443          
   2444              return a;
   \                     ??cJSON_CreateIntArray_4:
   \   00000034   0800A0E1           MOV      R0,R8
   \   00000038   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??cJSON_CreateIntArray_5:
   \   0000003C   0070A0E1           MOV      R7,R0
   \   00000040   014084E2           ADD      R4,R4,#+1
   \                     ??cJSON_CreateIntArray_3:
   \   00000044   060054E1           CMP      R4,R6
   \   00000048   F9FFFF2A           BCS      ??cJSON_CreateIntArray_4
   \   0000004C   040195E7           LDR      R0,[R5, +R4, LSL #+2]
   \   00000050   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000054   ........           BL       cJSON_CreateNumber
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0300001A           BNE      ??cJSON_CreateIntArray_6
   \   00000060   0800A0E1           MOV      R0,R8
   \   00000064   ........           BL       cJSON_Delete
   \                     ??cJSON_CreateIntArray_0:
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   F081BDE8           POP      {R4-R8,PC}
   \                     ??cJSON_CreateIntArray_6:
   \   00000070   000054E3           CMP      R4,#+0
   \   00000074   00008715           STRNE    R0,[R7, #+0]
   \   00000078   04708015           STRNE    R7,[R0, #+4]
   \   0000007C   08008805           STREQ    R0,[R8, #+8]
   \   00000080   EDFFFFEA           B        ??cJSON_CreateIntArray_5
   2445          }
   2446          

   \                                 In segment CODE, align 4, keep-with-next
   2447          CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
   2448          {
   \                     cJSON_CreateFloatArray:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   2449              size_t i = 0;
   2450              cJSON *n = NULL;
   2451              cJSON *p = NULL;
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0070A0E3           MOV      R7,#+0
   2452              cJSON *a = NULL;
   2453          
   2454              if ((count < 0) || (numbers == NULL))
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   1200004A           BMI      ??cJSON_CreateFloatArray_0
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0000001A           BNE      ??cJSON_CreateFloatArray_1
   2455              {
   2456                  return NULL;
   \                     ??cJSON_CreateFloatArray_2:
   \   00000024   0F0000EA           B        ??cJSON_CreateFloatArray_0
   2457              }
   2458          
   2459              a = cJSON_CreateArray();
   \                     ??cJSON_CreateFloatArray_1:
   \   00000028   ........           BL       cJSON_CreateArray
   \   0000002C   0080B0E1           MOVS     R8,R0
   2460          
   2461              for(i = 0; a && (i < (size_t)count); i++)
   \   00000030   0300001A           BNE      ??cJSON_CreateFloatArray_3
   2462              {
   2463                  n = cJSON_CreateNumber((double)numbers[i]);
   2464                  if(!n)
   2465                  {
   2466                      cJSON_Delete(a);
   2467                      return NULL;
   2468                  }
   2469                  if(!i)
   2470                  {
   2471                      a->child = n;
   2472                  }
   2473                  else
   2474                  {
   2475                      suffix_object(p, n);
   2476                  }
   2477                  p = n;
   2478              }
   2479          
   2480              return a;
   \                     ??cJSON_CreateFloatArray_4:
   \   00000034   0800A0E1           MOV      R0,R8
   \   00000038   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??cJSON_CreateFloatArray_5:
   \   0000003C   0070A0E1           MOV      R7,R0
   \   00000040   014084E2           ADD      R4,R4,#+1
   \                     ??cJSON_CreateFloatArray_3:
   \   00000044   060054E1           CMP      R4,R6
   \   00000048   F9FFFF2A           BCS      ??cJSON_CreateFloatArray_4
   \   0000004C   040195E7           LDR      R0,[R5, +R4, LSL #+2]
   \   00000050   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   00000054   ........           BL       cJSON_CreateNumber
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0300001A           BNE      ??cJSON_CreateFloatArray_6
   \   00000060   0800A0E1           MOV      R0,R8
   \   00000064   ........           BL       cJSON_Delete
   \                     ??cJSON_CreateFloatArray_0:
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   F081BDE8           POP      {R4-R8,PC}
   \                     ??cJSON_CreateFloatArray_6:
   \   00000070   000054E3           CMP      R4,#+0
   \   00000074   00008715           STRNE    R0,[R7, #+0]
   \   00000078   04708015           STRNE    R7,[R0, #+4]
   \   0000007C   08008805           STREQ    R0,[R8, #+8]
   \   00000080   EDFFFFEA           B        ??cJSON_CreateFloatArray_5
   2481          }
   2482          

   \                                 In segment CODE, align 4, keep-with-next
   2483          CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
   2484          {
   \                     cJSON_CreateDoubleArray:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   2485              size_t i = 0;
   2486              cJSON *n = NULL;
   2487              cJSON *p = NULL;
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0080A0E3           MOV      R8,#+0
   2488              cJSON *a = NULL;
   2489          
   2490              if ((count < 0) || (numbers == NULL))
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   1200004A           BMI      ??cJSON_CreateDoubleArray_0
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0000001A           BNE      ??cJSON_CreateDoubleArray_1
   2491              {
   2492                  return NULL;
   \                     ??cJSON_CreateDoubleArray_2:
   \   00000024   0F0000EA           B        ??cJSON_CreateDoubleArray_0
   2493              }
   2494          
   2495              a = cJSON_CreateArray();
   \                     ??cJSON_CreateDoubleArray_1:
   \   00000028   ........           BL       cJSON_CreateArray
   \   0000002C   0070B0E1           MOVS     R7,R0
   2496          
   2497              for(i = 0;a && (i < (size_t)count); i++)
   \   00000030   0300001A           BNE      ??cJSON_CreateDoubleArray_3
   2498              {
   2499                  n = cJSON_CreateNumber(numbers[i]);
   2500                  if(!n)
   2501                  {
   2502                      cJSON_Delete(a);
   2503                      return NULL;
   2504                  }
   2505                  if(!i)
   2506                  {
   2507                      a->child = n;
   2508                  }
   2509                  else
   2510                  {
   2511                      suffix_object(p, n);
   2512                  }
   2513                  p = n;
   2514              }
   2515          
   2516              return a;
   \                     ??cJSON_CreateDoubleArray_4:
   \   00000034   0700A0E1           MOV      R0,R7
   \   00000038   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??cJSON_CreateDoubleArray_5:
   \   0000003C   0080A0E1           MOV      R8,R0
   \   00000040   014084E2           ADD      R4,R4,#+1
   \                     ??cJSON_CreateDoubleArray_3:
   \   00000044   060054E1           CMP      R4,R6
   \   00000048   F9FFFF2A           BCS      ??cJSON_CreateDoubleArray_4
   \   0000004C   840185E0           ADD      R0,R5,R4, LSL #+3
   \   00000050   030090E8           LDM      R0,{R0,R1}
   \   00000054   ........           BL       cJSON_CreateNumber
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0300001A           BNE      ??cJSON_CreateDoubleArray_6
   \   00000060   0700A0E1           MOV      R0,R7
   \   00000064   ........           BL       cJSON_Delete
   \                     ??cJSON_CreateDoubleArray_0:
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   F081BDE8           POP      {R4-R8,PC}
   \                     ??cJSON_CreateDoubleArray_6:
   \   00000070   000054E3           CMP      R4,#+0
   \   00000074   00008815           STRNE    R0,[R8, #+0]
   \   00000078   04808015           STRNE    R8,[R0, #+4]
   \   0000007C   08008705           STREQ    R0,[R7, #+8]
   \   00000080   EDFFFFEA           B        ??cJSON_CreateDoubleArray_5
   2517          }
   2518          

   \                                 In segment CODE, align 4, keep-with-next
   2519          CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
   2520          {
   \                     cJSON_CreateStringArray:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   2521              size_t i = 0;
   2522              cJSON *n = NULL;
   2523              cJSON *p = NULL;
   \   0000000C   0060A0E3           MOV      R6,#+0
   \   00000010   0070A0E3           MOV      R7,#+0
   2524              cJSON *a = NULL;
   2525          
   2526              if ((count < 0) || (strings == NULL))
   \   00000014   000055E3           CMP      R5,#+0
   \   00000018   1100004A           BMI      ??cJSON_CreateStringArray_0
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   0000001A           BNE      ??cJSON_CreateStringArray_1
   2527              {
   2528                  return NULL;
   \                     ??cJSON_CreateStringArray_2:
   \   00000024   0E0000EA           B        ??cJSON_CreateStringArray_0
   2529              }
   2530          
   2531              a = cJSON_CreateArray();
   \                     ??cJSON_CreateStringArray_1:
   \   00000028   ........           BL       cJSON_CreateArray
   \   0000002C   0080B0E1           MOVS     R8,R0
   2532          
   2533              for (i = 0; a && (i < (size_t)count); i++)
   \   00000030   0300001A           BNE      ??cJSON_CreateStringArray_3
   2534              {
   2535                  n = cJSON_CreateString(strings[i]);
   2536                  if(!n)
   2537                  {
   2538                      cJSON_Delete(a);
   2539                      return NULL;
   2540                  }
   2541                  if(!i)
   2542                  {
   2543                      a->child = n;
   2544                  }
   2545                  else
   2546                  {
   2547                      suffix_object(p,n);
   2548                  }
   2549                  p = n;
   2550              }
   2551          
   2552              return a;
   \                     ??cJSON_CreateStringArray_4:
   \   00000034   0800A0E1           MOV      R0,R8
   \   00000038   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??cJSON_CreateStringArray_5:
   \   0000003C   0070A0E1           MOV      R7,R0
   \   00000040   016086E2           ADD      R6,R6,#+1
   \                     ??cJSON_CreateStringArray_3:
   \   00000044   050056E1           CMP      R6,R5
   \   00000048   F9FFFF2A           BCS      ??cJSON_CreateStringArray_4
   \   0000004C   060194E7           LDR      R0,[R4, +R6, LSL #+2]
   \   00000050   ........           BL       cJSON_CreateString
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0300001A           BNE      ??cJSON_CreateStringArray_6
   \   0000005C   0800A0E1           MOV      R0,R8
   \   00000060   ........           BL       cJSON_Delete
   \                     ??cJSON_CreateStringArray_0:
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   F081BDE8           POP      {R4-R8,PC}
   \                     ??cJSON_CreateStringArray_6:
   \   0000006C   000056E3           CMP      R6,#+0
   \   00000070   00008715           STRNE    R0,[R7, #+0]
   \   00000074   04708015           STRNE    R7,[R0, #+4]
   \   00000078   08008805           STREQ    R0,[R8, #+8]
   \   0000007C   EEFFFFEA           B        ??cJSON_CreateStringArray_5
   2553          }
   2554          
   2555          /* Duplication */

   \                                 In segment CODE, align 4, keep-with-next
   2556          CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
   2557          {
   \                     cJSON_Duplicate:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0060A0E1           MOV      R6,R0
   \   00000008   0170A0E1           MOV      R7,R1
   2558              cJSON *newitem = NULL;
   2559              cJSON *child = NULL;
   2560              cJSON *next = NULL;
   \   0000000C   0040A0E3           MOV      R4,#+0
   2561              cJSON *newchild = NULL;
   2562          
   2563              /* Bail on bad ptr */
   2564              if (!item)
   \   00000010   000056E3           CMP      R6,#+0
   \   00000014   3600000A           BEQ      ??cJSON_Duplicate_0
   2565              {
   2566                  goto fail;
   2567              }
   2568              /* Create new item */
   2569              newitem = cJSON_New_Item(&global_hooks);
   \   00000018   ........           LDR      R8,??DataTable38  ;; global_hooks
   \   0000001C   0800A0E1           MOV      R0,R8
   \   00000020   ........           BL       cJSON_New_Item
   \   00000024   0050B0E1           MOVS     R5,R0
   2570              if (!newitem)
   \   00000028   3100000A           BEQ      ??cJSON_Duplicate_0
   2571              {
   2572                  goto fail;
   2573              }
   2574              /* Copy over all vars */
   2575              newitem->type = item->type & (~cJSON_IsReference);
   \   0000002C   0C0096E5           LDR      R0,[R6, #+12]
   \   00000030   400FC0E3           BIC      R0,R0,#0x100
   \   00000034   0C0085E5           STR      R0,[R5, #+12]
   2576              newitem->valueint = item->valueint;
   \   00000038   140096E5           LDR      R0,[R6, #+20]
   \   0000003C   140085E5           STR      R0,[R5, #+20]
   2577              newitem->valuedouble = item->valuedouble;
   \   00000040   180096E5           LDR      R0,[R6, #+24]
   \   00000044   1C1096E5           LDR      R1,[R6, #+28]
   \   00000048   180085E5           STR      R0,[R5, #+24]
   \   0000004C   1C1085E5           STR      R1,[R5, #+28]
   2578              if (item->valuestring)
   \   00000050   100096E5           LDR      R0,[R6, #+16]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0400000A           BEQ      ??cJSON_Duplicate_1
   2579              {
   2580                  newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
   \   0000005C   0810A0E1           MOV      R1,R8
   \   00000060   ........           BL       cJSON_strdup
   \   00000064   100085E5           STR      R0,[R5, #+16]
   2581                  if (!newitem->valuestring)
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   1E00000A           BEQ      ??cJSON_Duplicate_2
   2582                  {
   2583                      goto fail;
   2584                  }
   2585              }
   2586              if (item->string)
   \                     ??cJSON_Duplicate_1:
   \   00000070   200096E5           LDR      R0,[R6, #+32]
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0700000A           BEQ      ??cJSON_Duplicate_3
   2587              {
   2588                  newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
   \   0000007C   0C1096E5           LDR      R1,[R6, #+12]
   \   00000080   800F11E3           TST      R1,#0x200
   \   00000084   0100001A           BNE      ??cJSON_Duplicate_4
   \   00000088   0810A0E1           MOV      R1,R8
   \   0000008C   ........           BL       cJSON_strdup
   \                     ??cJSON_Duplicate_4:
   \   00000090   200085E5           STR      R0,[R5, #+32]
   2589                  if (!newitem->string)
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   1300000A           BEQ      ??cJSON_Duplicate_2
   2590                  {
   2591                      goto fail;
   2592                  }
   2593              }
   2594              /* If non-recursive, then we're done! */
   2595              if (!recurse)
   \                     ??cJSON_Duplicate_3:
   \   0000009C   000057E3           CMP      R7,#+0
   \   000000A0   0100001A           BNE      ??cJSON_Duplicate_5
   2596              {
   2597                  return newitem;
   \                     ??cJSON_Duplicate_6:
   \   000000A4   0500A0E1           MOV      R0,R5
   \   000000A8   F081BDE8           POP      {R4-R8,PC}
   2598              }
   2599              /* Walk the ->next chain for the child. */
   2600              child = item->child;
   \                     ??cJSON_Duplicate_5:
   \   000000AC   086096E5           LDR      R6,[R6, #+8]
   \   000000B0   010000EA           B        ??cJSON_Duplicate_7
   2601              while (child != NULL)
   2602              {
   2603                  newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
   2604                  if (!newchild)
   2605                  {
   2606                      goto fail;
   2607                  }
   2608                  if (next != NULL)
   2609                  {
   2610                      /* If newitem->child already set, then crosswire ->prev and ->next and move on */
   2611                      next->next = newchild;
   2612                      newchild->prev = next;
   2613                      next = newchild;
   2614                  }
   2615                  else
   2616                  {
   2617                      /* Set newitem->child and move to it */
   2618                      newitem->child = newchild;
   2619                      next = newchild;
   2620                  }
   2621                  child = child->next;
   \                     ??cJSON_Duplicate_8:
   \   000000B4   006096E5           LDR      R6,[R6, #+0]
   \   000000B8   0040A0E1           MOV      R4,R0
   \                     ??cJSON_Duplicate_7:
   \   000000BC   000056E3           CMP      R6,#+0
   \   000000C0   F7FFFF0A           BEQ      ??cJSON_Duplicate_6
   \   000000C4   0110A0E3           MOV      R1,#+1
   \   000000C8   0600A0E1           MOV      R0,R6
   \   000000CC   CBFFFFEB           BL       cJSON_Duplicate
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   0400000A           BEQ      ??cJSON_Duplicate_2
   \   000000D8   000054E3           CMP      R4,#+0
   \   000000DC   08008505           STREQ    R0,[R5, #+8]
   \   000000E0   00008415           STRNE    R0,[R4, #+0]
   \   000000E4   04408015           STRNE    R4,[R0, #+4]
   \   000000E8   F1FFFFEA           B        ??cJSON_Duplicate_8
   2622              }
   2623          
   2624              return newitem;
   2625          
   2626          fail:
   2627              if (newitem != NULL)
   2628              {
   2629                  cJSON_Delete(newitem);
   \                     ??cJSON_Duplicate_2:
   \   000000EC   0500A0E1           MOV      R0,R5
   \   000000F0   ........           BL       cJSON_Delete
   2630              }
   2631          
   2632              return NULL;
   \                     ??cJSON_Duplicate_0:
   \   000000F4   0000A0E3           MOV      R0,#+0
   \   000000F8   F081BDE8           POP      {R4-R8,PC}       ;; return
   2633          }
   2634          

   \                                 In segment CODE, align 4, keep-with-next
   2635          CJSON_PUBLIC(void) cJSON_Minify(char *json)
   2636          {
   2637              unsigned char *into = (unsigned char*)json;
   \                     cJSON_Minify:
   \   00000000   0010B0E1           MOVS     R1,R0
   2638          
   2639              if (json == NULL)
   \   00000004   0100001A           BNE      ??cJSON_Minify_0
   \   00000008   1EFF2FE1           BX       LR
   2640              {
   2641                  return;
   2642              }
   2643          
   2644              while (*json)
   2645              {
   2646                  if (*json == ' ')
   2647                  {
   2648                      json++;
   \                     ??cJSON_Minify_1:
   \   0000000C   010080E2           ADD      R0,R0,#+1
   2649                  }
   \                     ??cJSON_Minify_0:
   \   00000010   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   2F00000A           BEQ      ??cJSON_Minify_2
   \   0000001C   200052E3           CMP      R2,#+32
   2650                  else if (*json == '\t')
   \   00000020   09005213           CMPNE    R2,#+9
   2651                  {
   2652                      /* Whitespace characters. */
   2653                      json++;
   2654                  }
   2655                  else if (*json == '\r')
   \   00000024   0D005213           CMPNE    R2,#+13
   2656                  {
   2657                      json++;
   2658                  }
   2659                  else if (*json=='\n')
   \   00000028   0A005213           CMPNE    R2,#+10
   \   0000002C   F6FFFF0A           BEQ      ??cJSON_Minify_1
   2660                  {
   2661                      json++;
   2662                  }
   2663                  else if ((*json == '/') && (json[1] == '/'))
   \   00000030   2F0052E3           CMP      R2,#+47
   \   00000034   0120D005           LDRBEQ   R2,[R0, #+1]
   \   00000038   2F005203           CMPEQ    R2,#+47
   \   0000003C   0500001A           BNE      ??cJSON_Minify_3
   2664                  {
   2665                      /* double-slash comments, to end of line. */
   2666                      while (*json && (*json != '\n'))
   \                     ??cJSON_Minify_4:
   \   00000040   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000044   000052E3           CMP      R2,#+0
   \   00000048   0A005213           CMPNE    R2,#+10
   \   0000004C   EFFFFF0A           BEQ      ??cJSON_Minify_0
   2667                      {
   2668                          json++;
   \   00000050   010080E2           ADD      R0,R0,#+1
   \   00000054   F9FFFFEA           B        ??cJSON_Minify_4
   2669                      }
   2670                  }
   2671                  else if ((*json == '/') && (json[1] == '*'))
   \                     ??cJSON_Minify_3:
   \   00000058   0020D0E5           LDRB     R2,[R0, #+0]
   \   0000005C   2F0052E3           CMP      R2,#+47
   \   00000060   0120D005           LDRBEQ   R2,[R0, #+1]
   \   00000064   2A005203           CMPEQ    R2,#+42
   \   00000068   0600000A           BEQ      ??cJSON_Minify_5
   2672                  {
   2673                      /* multiline comments. */
   2674                      while (*json && !((*json == '*') && (json[1] == '/')))
   2675                      {
   2676                          json++;
   2677                      }
   2678                      json += 2;
   2679                  }
   2680                  else if (*json == '\"')
   \   0000006C   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000070   220052E3           CMP      R2,#+34
   \   00000074   ........           LDRB     R2,[R0], #+1
   \   00000078   ........           STRB     R2,[R1], #+1
   \   0000007C   E3FFFF1A           BNE      ??cJSON_Minify_0
   2681                  {
   2682                      /* string literals, which are \" sensitive. */
   2683                      *into++ = (unsigned char)*json++;
   \   00000080   0E0000EA           B        ??cJSON_Minify_6
   \                     ??cJSON_Minify_7:
   \   00000084   010080E2           ADD      R0,R0,#+1
   \                     ??cJSON_Minify_5:
   \   00000088   0020D0E5           LDRB     R2,[R0, #+0]
   \   0000008C   000052E3           CMP      R2,#+0
   \   00000090   0300000A           BEQ      ??cJSON_Minify_8
   \   00000094   2A0052E3           CMP      R2,#+42
   \   00000098   0120D005           LDRBEQ   R2,[R0, #+1]
   \   0000009C   2F005203           CMPEQ    R2,#+47
   \   000000A0   F7FFFF1A           BNE      ??cJSON_Minify_7
   \                     ??cJSON_Minify_8:
   \   000000A4   020080E2           ADD      R0,R0,#+2
   \   000000A8   D8FFFFEA           B        ??cJSON_Minify_0
   2684                      while (*json && (*json != '\"'))
   2685                      {
   2686                          if (*json == '\\')
   \                     ??cJSON_Minify_9:
   \   000000AC   5C0052E3           CMP      R2,#+92
   2687                          {
   2688                              *into++ = (unsigned char)*json++;
   \   000000B0   ........           STRBEQ   R2,[R1], #+1
   \   000000B4   01008002           ADDEQ    R0,R0,#+1
   2689                          }
   2690                          *into++ = (unsigned char)*json++;
   \   000000B8   ........           LDRB     R2,[R0], #+1
   \   000000BC   ........           STRB     R2,[R1], #+1
   2691                      }
   \                     ??cJSON_Minify_6:
   \   000000C0   0020D0E5           LDRB     R2,[R0, #+0]
   \   000000C4   000052E3           CMP      R2,#+0
   \   000000C8   22005213           CMPNE    R2,#+34
   \   000000CC   F6FFFF1A           BNE      ??cJSON_Minify_9
   2692                      *into++ = (unsigned char)*json++;
   \   000000D0   ........           LDRB     R2,[R0], #+1
   \   000000D4   ........           STRB     R2,[R1], #+1
   \   000000D8   CCFFFFEA           B        ??cJSON_Minify_0
   2693                  }
   2694                  else
   2695                  {
   2696                      /* All other characters. */
   2697                      *into++ = (unsigned char)*json++;
   2698                  }
   2699              }
   2700          
   2701              /* and null-terminate. */
   2702              *into = '\0';
   \                     ??cJSON_Minify_2:
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   0000C1E5           STRB     R0,[R1, #+0]
   2703          }
   \   000000E4   1EFF2FE1           BX       LR               ;; return
   2704          

   \                                 In segment CODE, align 4, keep-with-next
   2705          CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
   2706          {
   2707              if (item == NULL)
   \                     cJSON_IsInvalid:
   \   00000000   000050E3           CMP      R0,#+0
   2708              {
   2709                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2710              }
   2711          
   2712              return (item->type & 0xFF) == cJSON_Invalid;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   000CB0E1           LSLS     R0,R0,#+24
   \   00000010   0100A003           MOVEQ    R0,#+1
   \   00000014   1EFF2F01           BXEQ     LR
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   1EFF2FE1           BX       LR               ;; return
   2713          }
   2714          

   \                                 In segment CODE, align 4, keep-with-next
   2715          CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
   2716          {
   2717              if (item == NULL)
   \                     cJSON_IsFalse:
   \   00000000   000050E3           CMP      R0,#+0
   2718              {
   2719                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2720              }
   2721          
   2722              return (item->type & 0xFF) == cJSON_False;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   010050E3           CMP      R0,#+1
   \   00000014   1EFF2F01           BXEQ     LR
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   1EFF2FE1           BX       LR               ;; return
   2723          }
   2724          

   \                                 In segment CODE, align 4, keep-with-next
   2725          CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
   2726          {
   2727              if (item == NULL)
   \                     cJSON_IsTrue:
   \   00000000   000050E3           CMP      R0,#+0
   2728              {
   2729                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2730              }
   2731          
   2732              return (item->type & 0xff) == cJSON_True;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   020050E3           CMP      R0,#+2
   \   00000014   0100A003           MOVEQ    R0,#+1
   \   00000018   1EFF2F01           BXEQ     LR
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   1EFF2FE1           BX       LR               ;; return
   2733          }
   2734          
   2735          

   \                                 In segment CODE, align 4, keep-with-next
   2736          CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
   2737          {
   2738              if (item == NULL)
   \                     cJSON_IsBool:
   \   00000000   000050E3           CMP      R0,#+0
   2739              {
   2740                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2741              }
   2742          
   2743              return (item->type & (cJSON_True | cJSON_False)) != 0;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   030010E3           TST      R0,#0x3
   \   00000010   0100A013           MOVNE    R0,#+1
   \   00000014   1EFF2F11           BXNE     LR
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   1EFF2FE1           BX       LR               ;; return
   2744          }

   \                                 In segment CODE, align 4, keep-with-next
   2745          CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
   2746          {
   2747              if (item == NULL)
   \                     cJSON_IsNull:
   \   00000000   000050E3           CMP      R0,#+0
   2748              {
   2749                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2750              }
   2751          
   2752              return (item->type & 0xFF) == cJSON_NULL;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   040050E3           CMP      R0,#+4
   \   00000014   0100A003           MOVEQ    R0,#+1
   \   00000018   1EFF2F01           BXEQ     LR
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   1EFF2FE1           BX       LR               ;; return
   2753          }
   2754          

   \                                 In segment CODE, align 4, keep-with-next
   2755          CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
   2756          {
   2757              if (item == NULL)
   \                     cJSON_IsNumber:
   \   00000000   000050E3           CMP      R0,#+0
   2758              {
   2759                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2760              }
   2761          
   2762              return (item->type & 0xFF) == cJSON_Number;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   080050E3           CMP      R0,#+8
   \   00000014   0100A003           MOVEQ    R0,#+1
   \   00000018   1EFF2F01           BXEQ     LR
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   1EFF2FE1           BX       LR               ;; return
   2763          }
   2764          

   \                                 In segment CODE, align 4, keep-with-next
   2765          CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
   2766          {
   2767              if (item == NULL)
   \                     cJSON_IsString:
   \   00000000   000050E3           CMP      R0,#+0
   2768              {
   2769                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2770              }
   2771          
   2772              return (item->type & 0xFF) == cJSON_String;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   100050E3           CMP      R0,#+16
   \   00000014   0100A003           MOVEQ    R0,#+1
   \   00000018   1EFF2F01           BXEQ     LR
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   1EFF2FE1           BX       LR               ;; return
   2773          }
   2774          

   \                                 In segment CODE, align 4, keep-with-next
   2775          CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
   2776          {
   2777              if (item == NULL)
   \                     cJSON_IsArray:
   \   00000000   000050E3           CMP      R0,#+0
   2778              {
   2779                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2780              }
   2781          
   2782              return (item->type & 0xFF) == cJSON_Array;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   200050E3           CMP      R0,#+32
   \   00000014   0100A003           MOVEQ    R0,#+1
   \   00000018   1EFF2F01           BXEQ     LR
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   1EFF2FE1           BX       LR               ;; return
   2783          }
   2784          

   \                                 In segment CODE, align 4, keep-with-next
   2785          CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
   2786          {
   2787              if (item == NULL)
   \                     cJSON_IsObject:
   \   00000000   000050E3           CMP      R0,#+0
   2788              {
   2789                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2790              }
   2791          
   2792              return (item->type & 0xFF) == cJSON_Object;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   400050E3           CMP      R0,#+64
   \   00000014   0100A003           MOVEQ    R0,#+1
   \   00000018   1EFF2F01           BXEQ     LR
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   1EFF2FE1           BX       LR               ;; return
   2793          }
   2794          

   \                                 In segment CODE, align 4, keep-with-next
   2795          CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
   2796          {
   2797              if (item == NULL)
   \                     cJSON_IsRaw:
   \   00000000   000050E3           CMP      R0,#+0
   2798              {
   2799                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2800              }
   2801          
   2802              return (item->type & 0xFF) == cJSON_Raw;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   800050E3           CMP      R0,#+128
   \   00000014   0100A003           MOVEQ    R0,#+1
   \   00000018   1EFF2F01           BXEQ     LR
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   1EFF2FE1           BX       LR               ;; return
   2803          }
   2804          

   \                                 In segment CODE, align 4, keep-with-next
   2805          CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
   2806          {
   \                     cJSON_Compare:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   2807              if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   00005413           CMPNE    R4,#+0
   \   00000018   3300000A           BEQ      ??cJSON_Compare_2
   \   0000001C   0C7095E5           LDR      R7,[R5, #+12]
   \   00000020   0C1094E5           LDR      R1,[R4, #+12]
   \   00000024   FF0007E2           AND      R0,R7,#0xFF
   \   00000028   FF1001E2           AND      R1,R1,#0xFF
   \   0000002C   010050E1           CMP      R0,R1
   \   00000030   2D00001A           BNE      ??cJSON_Compare_2
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   ........           BL       cJSON_IsInvalid
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   2900001A           BNE      ??cJSON_Compare_2
   2808              {
   2809                  return false;
   2810              }
   2811          
   2812              /* check if type is valid */
   2813              switch (a->type & 0xFF)
   \   00000044   FF0007E2           AND      R0,R7,#0xFF
   \   00000048   010040E2           SUB      R0,R0,#+1
   \   0000004C   7F0050E3           CMP      R0,#+127
   \   00000050   2500008A           BHI      ??cJSON_Compare_2
   \   00000054   011F8FE2           ADR      R1,??cJSON_Compare_0
   \   00000058   0010D1E7           LDRB     R1,[R1, R0]
   \   0000005C   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??cJSON_Compare_0:
   \   00000060   1F1F221F           DC8      +31,+31,+34,+31
   \   00000064   2222221F           DC8      +34,+34,+34,+31
   \   00000068   22222222           DC8      +34,+34,+34,+34
   \   0000006C   2222221F           DC8      +34,+34,+34,+31
   \   00000070   22222222           DC8      +34,+34,+34,+34
   \   00000074   22222222           DC8      +34,+34,+34,+34
   \   00000078   22222222           DC8      +34,+34,+34,+34
   \   0000007C   2222221F           DC8      +34,+34,+34,+31
   \   00000080   22222222           DC8      +34,+34,+34,+34
   \   00000084   22222222           DC8      +34,+34,+34,+34
   \   00000088   22222222           DC8      +34,+34,+34,+34
   \   0000008C   22222222           DC8      +34,+34,+34,+34
   \   00000090   22222222           DC8      +34,+34,+34,+34
   \   00000094   22222222           DC8      +34,+34,+34,+34
   \   00000098   22222222           DC8      +34,+34,+34,+34
   \   0000009C   2222221F           DC8      +34,+34,+34,+31
   \   000000A0   22222222           DC8      +34,+34,+34,+34
   \   000000A4   22222222           DC8      +34,+34,+34,+34
   \   000000A8   22222222           DC8      +34,+34,+34,+34
   \   000000AC   22222222           DC8      +34,+34,+34,+34
   \   000000B0   22222222           DC8      +34,+34,+34,+34
   \   000000B4   22222222           DC8      +34,+34,+34,+34
   \   000000B8   22222222           DC8      +34,+34,+34,+34
   \   000000BC   22222222           DC8      +34,+34,+34,+34
   \   000000C0   22222222           DC8      +34,+34,+34,+34
   \   000000C4   22222222           DC8      +34,+34,+34,+34
   \   000000C8   22222222           DC8      +34,+34,+34,+34
   \   000000CC   22222222           DC8      +34,+34,+34,+34
   \   000000D0   22222222           DC8      +34,+34,+34,+34
   \   000000D4   22222222           DC8      +34,+34,+34,+34
   \   000000D8   22222222           DC8      +34,+34,+34,+34
   \   000000DC   2222221F           DC8      +34,+34,+34,+31
   2814              {
   2815                  case cJSON_False:
   2816                  case cJSON_True:
   2817                  case cJSON_NULL:
   2818                  case cJSON_Number:
   2819                  case cJSON_String:
   2820                  case cJSON_Raw:
   2821                  case cJSON_Array:
   2822                  case cJSON_Object:
   2823                      break;
   2824          
   2825                  default:
   2826                      return false;
   2827              }
   2828          
   2829              /* identical objects are equal */
   2830              if (a == b)
   \                     ??cJSON_Compare_3:
   \   000000E0   040055E1           CMP      R5,R4
   \   000000E4   0200001A           BNE      ??cJSON_Compare_4
   2831              {
   2832                  return true;
   \   000000E8   3D0000EA           B        ??cJSON_Compare_5
   2833              }
   \                     ??cJSON_Compare_2:
   \   000000EC   0000A0E3           MOV      R0,#+0
   \   000000F0   F081BDE8           POP      {R4-R8,PC}
   2834          
   2835              switch (a->type & 0xFF)
   \                     ??cJSON_Compare_4:
   \   000000F4   088095E5           LDR      R8,[R5, #+8]
   \   000000F8   FF7007E2           AND      R7,R7,#0xFF
   \   000000FC   017047E2           SUB      R7,R7,#+1
   \   00000100   7F0057E3           CMP      R7,#+127
   \   00000104   F8FFFF8A           BHI      ??cJSON_Compare_2
   \   00000108   010F8FE2           ADR      R0,??cJSON_Compare_1
   \   0000010C   0700D0E7           LDRB     R0,[R0, R7]
   \   00000110   00F18FE0           ADD      PC,PC,R0, LSL #+2
   \                     ??cJSON_Compare_1:
   \   00000114   1F1F681F           DC8      +31,+31,+104,+31
   \   00000118   68686821           DC8      +104,+104,+104,+33
   \   0000011C   68686868           DC8      +104,+104,+104,+104
   \   00000120   68686829           DC8      +104,+104,+104,+41
   \   00000124   68686868           DC8      +104,+104,+104,+104
   \   00000128   68686868           DC8      +104,+104,+104,+104
   \   0000012C   68686868           DC8      +104,+104,+104,+104
   \   00000130   68686835           DC8      +104,+104,+104,+53
   \   00000134   68686868           DC8      +104,+104,+104,+104
   \   00000138   68686868           DC8      +104,+104,+104,+104
   \   0000013C   68686868           DC8      +104,+104,+104,+104
   \   00000140   68686868           DC8      +104,+104,+104,+104
   \   00000144   68686868           DC8      +104,+104,+104,+104
   \   00000148   68686868           DC8      +104,+104,+104,+104
   \   0000014C   68686868           DC8      +104,+104,+104,+104
   \   00000150   68686847           DC8      +104,+104,+104,+71
   \   00000154   68686868           DC8      +104,+104,+104,+104
   \   00000158   68686868           DC8      +104,+104,+104,+104
   \   0000015C   68686868           DC8      +104,+104,+104,+104
   \   00000160   68686868           DC8      +104,+104,+104,+104
   \   00000164   68686868           DC8      +104,+104,+104,+104
   \   00000168   68686868           DC8      +104,+104,+104,+104
   \   0000016C   68686868           DC8      +104,+104,+104,+104
   \   00000170   68686868           DC8      +104,+104,+104,+104
   \   00000174   68686868           DC8      +104,+104,+104,+104
   \   00000178   68686868           DC8      +104,+104,+104,+104
   \   0000017C   68686868           DC8      +104,+104,+104,+104
   \   00000180   68686868           DC8      +104,+104,+104,+104
   \   00000184   68686868           DC8      +104,+104,+104,+104
   \   00000188   68686868           DC8      +104,+104,+104,+104
   \   0000018C   68686868           DC8      +104,+104,+104,+104
   \   00000190   68686829           DC8      +104,+104,+104,+41
   2836              {
   2837                  /* in these cases and equal type is enough */
   2838                  case cJSON_False:
   2839                  case cJSON_True:
   2840                  case cJSON_NULL:
   2841                      return true;
   \                     ??cJSON_Compare_6:
   \   00000194   0100A0E3           MOV      R0,#+1
   \   00000198   F081BDE8           POP      {R4-R8,PC}
   2842          
   2843                  case cJSON_Number:
   2844                      if (a->valuedouble == b->valuedouble)
   \                     ??cJSON_Compare_7:
   \   0000019C   180095E5           LDR      R0,[R5, #+24]
   \   000001A0   1C1095E5           LDR      R1,[R5, #+28]
   \   000001A4   182094E5           LDR      R2,[R4, #+24]
   \   000001A8   1C3094E5           LDR      R3,[R4, #+28]
   \   000001AC   ........           _BLF     __dEqual,??__dEqual??rA
   \   000001B0   000050E3           CMP      R0,#+0
   2845                      {
   2846                          return true;
   \   000001B4   0100A013           MOVNE    R0,#+1
   2847                      }
   2848                      return false;
   \   000001B8   F081BDE8           POP      {R4-R8,PC}
   2849          
   2850                  case cJSON_String:
   2851                  case cJSON_Raw:
   2852                      if ((a->valuestring == NULL) || (b->valuestring == NULL))
   \                     ??cJSON_Compare_8:
   \   000001BC   100095E5           LDR      R0,[R5, #+16]
   \   000001C0   000050E3           CMP      R0,#+0
   \   000001C4   F081BD08           POPEQ    {R4-R8,PC}
   \   000001C8   101094E5           LDR      R1,[R4, #+16]
   \   000001CC   000051E3           CMP      R1,#+0
   2853                      {
   2854                          return false;
   \   000001D0   0000A003           MOVEQ    R0,#+0
   \   000001D4   F081BD08           POPEQ    {R4-R8,PC}
   2855                      }
   2856                      if (strcmp(a->valuestring, b->valuestring) == 0)
   \   000001D8   190000EF           SWI      +25
   \   000001DC   000050E3           CMP      R0,#+0
   \   000001E0   C1FFFF1A           BNE      ??cJSON_Compare_2
   2857                      {
   2858                          return true;
   \                     ??cJSON_Compare_5:
   \   000001E4   0100A0E3           MOV      R0,#+1
   \   000001E8   F081BDE8           POP      {R4-R8,PC}
   2859                      }
   2860          
   2861                      return false;
   2862          
   2863                  case cJSON_Array:
   2864                  {
   2865                      cJSON *a_element = a->child;
   2866                      cJSON *b_element = b->child;
   \                     ??cJSON_Compare_9:
   \   000001EC   084094E5           LDR      R4,[R4, #+8]
   \   000001F0   010000EA           B        ??cJSON_Compare_10
   2867          
   2868                      for (; (a_element != NULL) && (b_element != NULL);)
   2869                      {
   2870                          if (!cJSON_Compare(a_element, b_element, case_sensitive))
   2871                          {
   2872                              return false;
   2873                          }
   2874          
   2875                          a_element = a_element->next;
   \                     ??cJSON_Compare_11:
   \   000001F4   008098E5           LDR      R8,[R8, #+0]
   2876                          b_element = b_element->next;
   \   000001F8   004094E5           LDR      R4,[R4, #+0]
   \                     ??cJSON_Compare_10:
   \   000001FC   000058E3           CMP      R8,#+0
   \   00000200   00005413           CMPNE    R4,#+0
   \   00000204   0600000A           BEQ      ??cJSON_Compare_12
   \   00000208   0620A0E1           MOV      R2,R6
   \   0000020C   0410A0E1           MOV      R1,R4
   \   00000210   0800A0E1           MOV      R0,R8
   \   00000214   79FFFFEB           BL       cJSON_Compare
   \   00000218   000050E3           CMP      R0,#+0
   \   0000021C   F4FFFF1A           BNE      ??cJSON_Compare_11
   \   00000220   F081BDE8           POP      {R4-R8,PC}
   2877                      }
   2878          
   2879                      /* one of the arrays is longer than the other */
   2880                      if (a_element != b_element) {
   \                     ??cJSON_Compare_12:
   \   00000224   040058E1           CMP      R8,R4
   \   00000228   D9FFFF0A           BEQ      ??cJSON_Compare_6
   2881                          return false;
   \   0000022C   210000EA           B        ??cJSON_Compare_13
   2882                      }
   2883          
   2884                      return true;
   2885                  }
   2886          
   2887                  case cJSON_Object:
   2888                  {
   2889                      cJSON *a_element = NULL;
   2890                      cJSON *b_element = NULL;
   2891                      cJSON_ArrayForEach(a_element, a)
   \                     ??cJSON_Compare_14:
   \   00000230   008098E5           LDR      R8,[R8, #+0]
   \                     ??cJSON_Compare_15:
   \   00000234   000058E3           CMP      R8,#+0
   \   00000238   0C00000A           BEQ      ??cJSON_Compare_16
   2892                      {
   2893                          /* TODO This has O(n^2) runtime, which is horrible! */
   2894                          b_element = get_object_item(b, a_element->string, case_sensitive);
   \   0000023C   201098E5           LDR      R1,[R8, #+32]
   \   00000240   0620A0E1           MOV      R2,R6
   \   00000244   0400A0E1           MOV      R0,R4
   \   00000248   ........           BL       get_object_item
   \   0000024C   0070B0E1           MOVS     R7,R0
   2895                          if (b_element == NULL)
   \   00000250   A5FFFF0A           BEQ      ??cJSON_Compare_2
   2896                          {
   2897                              return false;
   2898                          }
   2899          
   2900                          if (!cJSON_Compare(a_element, b_element, case_sensitive))
   \   00000254   0620A0E1           MOV      R2,R6
   \   00000258   0010A0E1           MOV      R1,R0
   \   0000025C   0800A0E1           MOV      R0,R8
   \   00000260   66FFFFEB           BL       cJSON_Compare
   \   00000264   000050E3           CMP      R0,#+0
   \   00000268   F0FFFF1A           BNE      ??cJSON_Compare_14
   2901                          {
   2902                              return false;
   \   0000026C   F081BDE8           POP      {R4-R8,PC}
   2903                          }
   2904                      }
   \                     ??cJSON_Compare_16:
   \   00000270   087094E5           LDR      R7,[R4, #+8]
   \   00000274   000000EA           B        ??cJSON_Compare_17
   2905          
   2906                      /* doing this twice, once on a and b to prevent true comparison if a subset of b
   2907                       * TODO: Do this the proper way, this is just a fix for now */
   2908                      cJSON_ArrayForEach(b_element, b)
   \                     ??cJSON_Compare_18:
   \   00000278   007097E5           LDR      R7,[R7, #+0]
   \                     ??cJSON_Compare_17:
   \   0000027C   000057E3           CMP      R7,#+0
   \   00000280   C3FFFF0A           BEQ      ??cJSON_Compare_6
   2909                      {
   2910                          a_element = get_object_item(a, b_element->string, case_sensitive);
   \   00000284   201097E5           LDR      R1,[R7, #+32]
   \   00000288   0620A0E1           MOV      R2,R6
   \   0000028C   0500A0E1           MOV      R0,R5
   \   00000290   ........           BL       get_object_item
   \   00000294   0080B0E1           MOVS     R8,R0
   2911                          if (a_element == NULL)
   \   00000298   93FFFF0A           BEQ      ??cJSON_Compare_2
   2912                          {
   2913                              return false;
   2914                          }
   2915          
   2916                          if (!cJSON_Compare(b_element, a_element, case_sensitive))
   \   0000029C   0620A0E1           MOV      R2,R6
   \   000002A0   0010A0E1           MOV      R1,R0
   \   000002A4   0700A0E1           MOV      R0,R7
   \   000002A8   54FFFFEB           BL       cJSON_Compare
   \   000002AC   000050E3           CMP      R0,#+0
   \   000002B0   F0FFFF1A           BNE      ??cJSON_Compare_18
   2917                          {
   2918                              return false;
   \   000002B4   F081BDE8           POP      {R4-R8,PC}
   2919                          }
   2920                      }
   2921          
   2922                      return true;
   2923                  }
   2924          
   2925                  default:
   2926                      return false;
   \                     ??cJSON_Compare_13:
   \   000002B8   0000A0E3           MOV      R0,#+0
   \   000002BC   F081BDE8           POP      {R4-R8,PC}
   2927              }
   2928          }
   2929          

   \                                 In segment CODE, align 4, keep-with-next
   2930          CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
   2931          {
   2932              return global_hooks.allocate(size);
   \                     cJSON_malloc:
   \   00000000   ........           LDR      R1,??DataTable39  ;; global_hooks
   \   00000004   001091E5           LDR      R1,[R1, #+0]
   \   00000008   01F0A0E1           MOV      PC,R1            ;; tailcall
   2933          }
   2934          

   \                                 In segment CODE, align 4, keep-with-next
   2935          CJSON_PUBLIC(void) cJSON_free(void *object)
   2936          {
   2937              global_hooks.deallocate(object);
   \                     cJSON_free:
   \   00000000   04109FE5           LDR      R1,??cJSON_free_0  ;; global_hooks + 4
   \   00000004   001091E5           LDR      R1,[R1, #+0]
   \   00000008   01F0A0E1           MOV      PC,R1            ;; tailcall
   \                     ??cJSON_free_0:
   \   0000000C   ........           DC32     global_hooks + 4
   2938          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     global_hooks

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     global_hooks

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     `?<Constant "null">`

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     `?<Constant "null">`

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   ........           DC32     global_hooks

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   ........           DC32     global_hooks

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for global_hooks>`:
   \   00000000   ............       DC32 internal_malloc, internal_free, internal_realloc
   \              ............
   \                     `?<Initializer for global_error>`:
   \   0000000C   000000000000       DC32 0H, 0
   \              0000        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%i.%i.%i">`:
   \   00000000   25692E25692E       DC8 "%i.%i.%i"
   \              256900      
   \   00000009   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   222200             DC8 "\"\""

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "u%04x">`:
   \   00000000   752530347800       DC8 "u%04x"
   \   00000006   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   EFBBBF00           DC8 "\357\273\277"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   000000000000       DC32 0H, 0, 0, 0, 0H, 0H, 0H
   \              000000000000
   \              000000000000
   \              000000000000
   \              00000000    

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   000000000000       DC32 0H, 0, 0, 0, 0, 0, 0H, 0H, 0H
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   000000000000       DC32 0H, 0, 0, 0, 0, 0, 0H, 0H, 0H
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     add_item_to_array                  0
     add_item_to_object                24
     buffer_skip_whitespace             0
     cJSON_AddArrayToObject            20
     cJSON_AddBoolToObject             20
     cJSON_AddFalseToObject            20
     cJSON_AddItemReferenceToArray     16
     cJSON_AddItemReferenceToObject    32
     cJSON_AddItemToArray               4
     cJSON_AddItemToObject              8
     cJSON_AddItemToObjectCS            8
     cJSON_AddNullToObject             20
     cJSON_AddNumberToObject           20
     cJSON_AddObjectToObject           20
     cJSON_AddRawToObject              20
     cJSON_AddStringToObject           20
     cJSON_AddTrueToObject             20
     cJSON_Compare                     24
     cJSON_CreateArray                  4
     cJSON_CreateArrayReference         8
     cJSON_CreateBool                   8
     cJSON_CreateDoubleArray           24
     cJSON_CreateFalse                  4
     cJSON_CreateFloatArray            24
     cJSON_CreateIntArray              24
     cJSON_CreateNull                   4
     cJSON_CreateNumber                16
     cJSON_CreateObject                 4
     cJSON_CreateObjectReference        8
     cJSON_CreateRaw                   16
     cJSON_CreateString                16
     cJSON_CreateStringArray           24
     cJSON_CreateStringReference        8
     cJSON_CreateTrue                   4
     cJSON_Delete                      16
     cJSON_DeleteItemFromArray          4
     cJSON_DeleteItemFromObject         4
     cJSON_DeleteItemFromObjectCaseSensitive
                                        4
     cJSON_DetachItemFromArray          4
     cJSON_DetachItemFromObject         8
     cJSON_DetachItemFromObjectCaseSensitive
                                        8
     cJSON_DetachItemViaPointer         0
     cJSON_Duplicate                   24
     cJSON_GetArrayItem                 0
     cJSON_GetArraySize                 0
     cJSON_GetErrorPtr                  0
     cJSON_GetObjectItem                4
     cJSON_GetObjectItemCaseSensitive
                                        4
     cJSON_GetStringValue               8
     cJSON_HasObjectItem                4
     cJSON_InitHooks                   12
     cJSON_InsertItemInArray            4
     cJSON_IsArray                      0
     cJSON_IsBool                       0
     cJSON_IsFalse                      0
     cJSON_IsInvalid                    0
     cJSON_IsNull                       0
     cJSON_IsNumber                     0
     cJSON_IsObject                     0
     cJSON_IsRaw                        0
     cJSON_IsString                     0
     cJSON_IsTrue                       0
     cJSON_Minify                       0
     cJSON_New_Item                     8
     cJSON_Parse                        4
     cJSON_ParseWithOpts               56
     cJSON_Print                        4
     cJSON_PrintBuffered               56
     cJSON_PrintPreallocated           52
     cJSON_PrintUnformatted             4
     cJSON_ReplaceItemInArray           4
     cJSON_ReplaceItemInObject         20
     cJSON_ReplaceItemInObjectCaseSensitive
                                       20
     cJSON_ReplaceItemViaPointer        4
     cJSON_SetNumberHelper             16
     cJSON_Version                     12
     cJSON_free                         4
     cJSON_malloc                       4
     cJSON_strdup                      16
     ensure                            16
     get_object_item                   24
     internal_free                      4
     internal_malloc                    4
     internal_realloc                   4
     parse_array                       20
     parse_number                      88
     parse_object                      24
     parse_string                      40
     parse_value                       20
     print                             60
     print_array                       20
     print_number                      60
     print_object                      32
     print_string_ptr                  28
     print_value                       16
     update_offset                      8
     utf16_literal_to_utf8             16


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     ?<Constant "null">               44
     cJSON_GetErrorPtr                20
     cJSON_GetStringValue             28
     cJSON_Version                    52
     version                          16
     internal_malloc                  12
     internal_free                    12
     internal_realloc                 12
     global_hooks                     20
     cJSON_strdup                     76
     cJSON_InitHooks                 128
     cJSON_New_Item                   48
     cJSON_Delete                    136
     parse_number                    400
     cJSON_SetNumberHelper           128
     ensure                          248
     update_offset                    48
     print_number                    308
     utf16_literal_to_utf8           504
     parse_string                    548
     print_string_ptr                576
     buffer_skip_whitespace           76
     cJSON_ParseWithOpts             384
     cJSON_Parse                      12
     print                           296
     cJSON_Print                      12
     cJSON_PrintUnformatted           12
     cJSON_PrintBuffered             164
     cJSON_PrintPreallocated         124
     parse_value                     388
     print_value                     412
     parse_array                     352
     print_array                     264
     parse_object                    456
     print_object                    560
     cJSON_GetArraySize               48
     cJSON_GetArrayItem               52
     get_object_item                 200
     cJSON_GetObjectItem               8
     cJSON_GetObjectItemCaseSensitive
                                       8
     cJSON_HasObjectItem              24
     add_item_to_array                68
     cJSON_AddItemToArray              4
     add_item_to_object              148
     cJSON_AddItemToObject            24
     cJSON_AddItemToObjectCS          24
     cJSON_AddItemReferenceToArray   108
     cJSON_AddItemReferenceToObject  136
     cJSON_AddNullToObject            76
     cJSON_AddTrueToObject            76
     cJSON_AddFalseToObject           76
     cJSON_AddBoolToObject            80
     cJSON_AddNumberToObject          84
     cJSON_AddStringToObject          80
     cJSON_AddRawToObject             80
     cJSON_AddObjectToObject          76
     cJSON_AddArrayToObject           76
     cJSON_DetachItemViaPointer       88
     cJSON_DetachItemFromArray        60
     cJSON_DeleteItemFromArray        16
     cJSON_DetachItemFromObject       32
     cJSON_DetachItemFromObjectCaseSensitive
                                      32
     cJSON_DeleteItemFromObject       16
     cJSON_DeleteItemFromObjectCaseSensitive
                                      16
     cJSON_InsertItemInArray         116
     cJSON_ReplaceItemViaPointer     112
     cJSON_ReplaceItemInArray         64
     cJSON_ReplaceItemInObject       124
     cJSON_ReplaceItemInObjectCaseSensitive
                                     124
     cJSON_CreateNull                 28
     cJSON_CreateTrue                 28
     cJSON_CreateFalse                28
     cJSON_CreateBool                 44
     cJSON_CreateNumber              144
     cJSON_CreateString               84
     cJSON_CreateStringReference      36
     cJSON_CreateObjectReference      36
     cJSON_CreateArrayReference       36
     cJSON_CreateRaw                  84
     cJSON_CreateArray                28
     cJSON_CreateObject               28
     cJSON_CreateIntArray            132
     cJSON_CreateFloatArray          132
     cJSON_CreateDoubleArray         132
     cJSON_CreateStringArray         128
     cJSON_Duplicate                 252
     cJSON_Minify                    232
     cJSON_IsInvalid                  32
     cJSON_IsFalse                    32
     cJSON_IsTrue                     36
     cJSON_IsBool                     32
     cJSON_IsNull                     36
     cJSON_IsNumber                   36
     cJSON_IsString                   36
     cJSON_IsArray                    36
     cJSON_IsObject                   36
     cJSON_IsRaw                      36
     cJSON_Compare                   704
     cJSON_malloc                     12
     cJSON_free                       16
     ??DataTable2                      4
     ??DataTable8                      4
     ??DataTable9                      4
     ??DataTable10                     4
     ??DataTable38                     4
     ??DataTable39                     4
     ?<Initializer for global_hooks>
                                      20
     ?<Constant "%i.%i.%i">           12
     ?<Constant "\"\"">                3
     ?<Constant "u%04x">               8
     ?<Constant "\357\273\277">        4
     ?<Constant {(unsigned char const *)0, 0, 0, 0,
                                      28
     ?<Constant {(unsigned char *)0, 0, 0, 0, 0, 0,
                                      36
     ?<Constant {(unsigned char *)0, 0, 0, 0, 0, 0,_1
                                      36
      Others                         532

 
 12 376 bytes in segment CODE
    171 bytes in segment DATA_C
     20 bytes in segment DATA_I
     20 bytes in segment DATA_ID
     16 bytes in segment DATA_Z
     24 bytes in segment INITTAB
 
 11 868 bytes of CODE  memory (+ 532 bytes shared)
    191 bytes of CONST memory
     36 bytes of DATA  memory

Errors: none
Warnings: none
