##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    11/Nov/2018  23:56:23 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\Users\alfinant\Documents\Siemens\alfinant\VK.ELF_ #
#                       C\clist.c                                            #
#    Command line    =  C:\Users\alfinant\Documents\Siemens\alfinant\VK.ELF_ #
#                       C\clist.c -D NEWSGOLD -D DEVELOP -lCN                #
#                       C:\Users\alfinant\Documents\Siemens\alfinant\VK.ELF_ #
#                       C\Releas_NSG\List\ -la C:\Users\alfinant\Documents\S #
#                       iemens\alfinant\VK.ELF_C\Releas_NSG\List\ -o         #
#                       C:\Users\alfinant\Documents\Siemens\alfinant\VK.ELF_ #
#                       C\Releas_NSG\Obj\ -z9 --cpu_mode arm --endian        #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       --diag_suppress Pe301 -e --fpu None --dlib_config    #
#                       C:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I C:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  C:\Users\alfinant\Documents\Siemens\alfinant\VK.ELF_ #
#                       C\Releas_NSG\List\clist.lst                          #
#    Object file     =  C:\Users\alfinant\Documents\Siemens\alfinant\VK.ELF_ #
#                       C\Releas_NSG\Obj\clist.r79                           #
#                                                                            #
#                                                                            #
##############################################################################

C:\Users\alfinant\Documents\Siemens\alfinant\VK.ELF_C\clist.c
      1          #include "clist.h"
      2          #include "list.h"
      3          #include <siemens\swilib.h>
      4          #include "main.h"
      5          #include "vk_api.h"
      6          #include "string_util.h"
      7          
      8          static const char percent_d[]="%d,";
      9          
     10          
     11          struct prs_message_st* new_PrsMessage(unsigned date, int from_id, int id, char* text, int out)
     12          {
     13            struct prs_message_st* msg = malloc(sizeof(struct prs_message_st));
     14            msg->date = date;
     15            msg->from_id = from_id;
     16            msg->id = id;
     17            msg->text = text;
     18            msg->out = out;
     19            INIT_LIST_HEAD(&msg->list);
     20            return msg;
     21          }
     22          
     23          struct dialog_st* new_Dialog(struct prs_message_st* msg, struct user_st* user)
     24          {
     25            struct dialog_st* dialog = malloc(sizeof(struct dialog_st));
     26            INIT_LIST_HEAD(&dialog->list);
     27            INIT_LIST_HEAD(&dialog->message);
     28            list_add(&msg->list, &dialog->message);
     29            dialog->user = user;
     30            return dialog;
     31          }
     32          
     33          
     34          void FreeAtachments(WALL_ATTACH* a)
     35          {
     36            while (a)
     37            {
     38              if (a->url)
     39                mfree(a->url);
     40              void* next=a->next;
     41              mfree(a);
     42              a=next;
     43            }
     44          }
     45          
     46          WALL_ATTACH* FindAttachByIndex(WALL_MSG* msg, int i)
     47          {
     48            WALL_ATTACH* attach=msg->attach_list;
     49            int n=0;
     50            
     51            while(attach)
     52            {
     53              if (i == n)
     54                break;
     55              n++;
     56              attach=attach->next;
     57            }
     58            return attach;  
     59          }
     60          
     61          PERSONAL_MSG* AllocMSG()
     62          {
     63            PERSONAL_MSG* msg;
     64            
     65            msg=malloc(sizeof(PERSONAL_MSG));
     66            msg->prev=0;  
     67            msg->next=0;
     68            msg->body=NULL;  
     69            msg->id=0;
     70            msg->date=0;  
     71            msg->user_id=0;
     72            msg->read_state=0;
     73            msg->out=0;
     74            msg->emoji=0;
     75            msg->attach=0;
     76            
     77            return msg;
     78          };
     79          
     80          void FreeWALLMSG(CLIST* c)
     81          {
     82            WALL_MSG* msg=(WALL_MSG*)c->wall_msglist;
     83            c->wall_msglist=NULL;
     84            
     85            while (msg)
     86            {
     87              if (msg->text)
     88                FreeWS(msg->text);
     89              if (msg->attach_list)
     90                FreeAtachments(msg->attach_list);
     91              if (msg->profiles)
     92                CLIST_Free(&msg->profiles);
     93              void* next=msg->next;
     94              mfree(msg);
     95              msg=next;
     96            }
     97          }
     98          
     99          void FreeMSGLIST(CLIST* c)
    100          {
    101            PERSONAL_MSG* msg=c->msglist;
    102            
    103            while (msg)
    104            {
    105              void* next=msg->next;
    106              if (msg->body)
    107                FreeWS(msg->body);
    108              mfree(msg);
    109              msg=next;
    110            }
    111            c->msglist=NULL;
    112          }
    113          
    114          PERSONAL_MSG* FindMsgById(CLIST* c, int id)
    115          {
    116            PERSONAL_MSG* msg;
    117            
    118            if (c==NULL)
    119              return(0);
    120            
    121            msg=c->msglist;
    122            
    123            while(msg)
    124            {
    125              if (msg->id==id)
    126                return msg;
    127              msg=msg->next;
    128            }
    129            return(0);  
    130          }
    131          
    132          void AddMsg(CLIST* c, PERSONAL_MSG* msg)
    133          {
    134            PERSONAL_MSG* msg_i; 
    135            PERSONAL_MSG* msg_prev;
    136            
    137            c->msg_count++;//счетчик сообщений
    138            
    139            if (msg->out==0 && msg->read_state==0)//если не прочитано
    140              c->unread++;
    141            
    142            if (c->msglist==NULL)//добавляем первое сообщение
    143            {
    144               c->msglist=msg;
    145              return;
    146            }
    147            
    148            msg_i=c->msglist;
    149            
    150            while (msg_i)
    151            {
    152              if (msg->id > msg_i->id)//ищем мессагу с id мньше нашего
    153              {
    154                msg_prev=msg_i->prev;
    155                if (msg_prev==0)//значит топ
    156                  c->msglist=msg;
    157                else
    158                  msg_prev->next=msg;
    159                msg->next=msg_i;
    160                msg->prev=msg_prev;
    161                msg_i->prev=msg;
    162                break;
    163              }
    164              else
    165                if (msg_i->next==NULL)//не нашли,вставляем в конец списка
    166                {
    167                  msg->next=0;
    168                  msg->prev=msg_i;
    169                  msg_i->next=msg;     
    170                  break;
    171                }
    172              msg_i=msg_i->next;
    173            }  
    174          }
    175          
    176          //******************************************************************************
    177          
    178          int AddMsgNew(unsigned date, int from_id, int id, const char* text, int out)
    179          {
    180            CLIST* c = FindContactById(csm->dialogs_list, from_id);
    181            
    182            if (c == NULL)//если контакта нет в списке
    183              c = CreateContact(from_id);
    184            
    185            PERSONAL_MSG* msg = FindMsgById(c, id);
    186            
    187            if (msg)//если сообщение уже есть в списке
    188              return 0;
    189            
    190            //подмена в utf8 тексте символов эмоджи и перевод в WSHDR
    191            char* text_utf8 = malloc(strlen(text) + 1);
    192            strcpy(text_utf8, text);
    193            int len = Replace_Smiles_Syms(text_utf8);
    194            WSHDR* text_ws = AllocWS(utf8_syms_n(text_utf8, len));
    195            utf8_2ws(text_ws, text_utf8, len);
    196            mfree(text_utf8);
    197            
    198            msg = AllocMSG();
    199            msg->id = id;
    200            msg->date = date;
    201            msg->user_id = from_id;
    202            msg->body = text_ws;
    203            msg->out = out;
    204            
    205            AddMsg(c, msg);
    206            AddContactToList(&csm->dialogs_list, c);
    207            return 1;
    208          }
    209          
    210          void AddUserInfo(int id, int deactivated, char* first_name, char* last_name, char* photo_50)
    211          {
    212            if (id == my_id)//свои данные пока не обновляем
    213              return;
    214            
    215            CLIST* c = FindContactById(csm->dialogs_list, id);
    216            
    217            if (c == NULL)//если контакта нет в списке
    218              return;
    219               
    220            if (first_name)
    221            {
    222              if (c->first_name == NULL)
    223                c->first_name = AllocWS(65);     
    224              utf8_2ws(c->first_name, first_name, strlen(first_name));
    225          
    226            }
    227            
    228            if (last_name)
    229            {
    230              if (c->last_name == NULL)
    231                c->last_name = AllocWS(65);     
    232              utf8_2ws(c->last_name, last_name, strlen(last_name));
    233            }
    234            
    235            if (photo_50)
    236            {
    237              if (c->photo_url == NULL)
    238                c->photo_url = malloc(strlen(photo_50));
    239              c->photo_url = photo_50;
    240            }
    241           
    242          }
    243          
    244          //******************************************************************************
    245          
    246          CLIST* CreateContact(int id)
    247          {
    248            CLIST* c;
    249            
    250            c=malloc(sizeof(CLIST));
    251            c->next=NULL;
    252            c->prev=NULL;
    253            c->msglist=NULL;
    254            c->wall_msglist=NULL;
    255            c->user_id=id;
    256            c->first_name=NULL;
    257            c->last_name=NULL;
    258            c->photo=NULL;
    259            c->photo_url=NULL;
    260            c->flag_load_photo=0;
    261            c->deactivated=0;
    262            c->msg_count=0;  
    263            c->unread=0;
    264            return c;
    265          }
    266          
    267          static void FreeContact(CLIST* c)
    268          {
    269            if (c->first_name)
    270              FreeWS(c->first_name);
    271            
    272            if (c->last_name)
    273              FreeWS(c->last_name);
    274            
    275            if (c->msglist)
    276              FreeMSGLIST(c);
    277          
    278            if (c->wall_msglist)
    279              FreeWALLMSG(c);
    280            
    281            if (c->photo_url)
    282              mfree(c->photo_url);
    283            
    284            if (c->photo)
    285            {
    286              mfree(c->photo->bitmap);
    287              mfree(c->photo);
    288            }
    289            mfree(c);
    290          }
    291          
    292          void CLIST_Free(CLIST** cl)
    293          {
    294            CLIST* c=*cl;
    295          
    296            while(c)
    297            {
    298              CLIST* c_next=c->next;
    299              FreeContact(c);
    300              c=c_next;
    301            }
    302            *cl=NULL;
    303          }
    304          
    305          static int FindContact(CLIST* cl, CLIST* c)
    306          {
    307            CLIST* c_next=cl;
    308            
    309            while(c_next)
    310            {
    311              if (c_next == c)
    312                return (1);
    313              c_next=c_next->next;
    314            }
    315            return(0);
    316          }
    317          
    318          CLIST* FindContactById(CLIST* cl, int user_id)
    319          {
    320            CLIST* c=cl;
    321            
    322            while(c)
    323            {
    324              if (c->user_id==user_id)
    325                return c;
    326              c=c->next;
    327            }
    328            return(0);
    329          }
    330          
    331          static void CutContactFromList(CLIST** cl, CLIST* c)
    332          { 
    333            CLIST* c_prev=c->prev;
    334            CLIST* c_next=c->next;
    335            c->prev=0;
    336            c->next=0;
    337            if (c_prev)
    338              c_prev->next=c_next;
    339            else//если контакт был в топе
    340              *cl=c_next;
    341            if (c_next)
    342              c_next->prev=c_prev;
    343          }
    344          
    345          void DeleteContact(CLIST** cl, int user_id)
    346          {
    347            CLIST* c;
    348            
    349            if (c=FindContactById(*cl, user_id))
    350            {
    351              CutContactFromList(cl, c);
    352              FreeContact(c);
    353            }
    354          }
    355          
    356          void AddContactToList(CLIST** cl, CLIST* c)//добавление с сортировкой по дате
    357          {
    358            CLIST* c_next;
    359            CLIST* c_prev;
    360            
    361            if (*cl==NULL)
    362            {
    363              *cl=c;
    364              return;
    365            }
    366            
    367            if (FindContact(*cl, c))
    368            {
    369              if (c->next==NULL && c->prev==0)//если в списке только наш контакт
    370                return;
    371              else 
    372                CutContactFromList(cl, c);  
    373            }
    374            
    375            c_next=*cl;
    376            
    377            while (c_next)
    378            {
    379              if (c->msglist->date > c_next->msglist->date)//ищем сообщение с date меньше нашего
    380              {
    381                c_prev=c_next->prev;
    382                
    383                if (c_prev == 0)//непорядок-контакт с меньшим id сообщения в топе.
    384                  *cl=c;
    385                else
    386                  c_prev->next=c;
    387                c->next=c_next;
    388                c->prev=c_prev;
    389                c_next->prev=c;
    390                break;
    391              }
    392              else
    393                if (c_next->next==NULL)//не нашли,вставляем в конец списка
    394                {
    395                  c->next=0;
    396                  c->prev=c_next;
    397                  c_next->next=c;
    398                  break;
    399                }
    400              
    401              c_next=c_next->next;
    402            } 
    403          }
    404          
    405          
    406          CLIST* FindContactByN(CLIST* cl, int n)
    407          {
    408            CLIST* c;
    409            int i=0;
    410            
    411            c=cl;
    412            
    413            while(c)
    414            {
    415              if (i == n)
    416                break;
    417              i++;
    418              c=c->next;
    419            }
    420            return c;
    421          }
    422          
    423          int GetContactN(CLIST* cl, CLIST* c)
    424          {
    425            CLIST* c_next;
    426            int i=0;
    427            
    428            c_next=cl;
    429            
    430            while(c_next)
    431            {
    432              if (c_next == c)
    433                break;
    434              i++;
    435              c_next=c->next;
    436            }
    437            return i;
    438          }
    439          
    440          CLIST* FindLastContact(CLIST* cl)
    441          {
    442            CLIST* c=cl;
    443            
    444            if(c==NULL)
    445              return(0);
    446            
    447            while(c)
    448            {
    449              if (c->next == NULL)
    450                break;
    451              c=c->next;
    452            }
    453            
    454            return c;     
    455          }
    456          
    457          int CLIST_GetCount(CLIST* cl)
    458          {
    459            CLIST* c=cl;
    460            int count=0;
    461            
    462            if(c==NULL)
    463              return(0);
    464            
    465            while(c)
    466            {
    467              count++;
    468              c=c->next;
    469            }
    470            
    471            return count;  
    472          }
    473          
    474          /*
    475          char* create_noninfo_users_ids(CLIST* cl) 
    476          {
    477            int len_c=0;
    478            int len_s=0;
    479            char* s=NULL;
    480            char c[32];
    481            
    482            CLIST* user=cl;
    483            
    484            while (user)
    485            {
    486              if (user->first_name==NULL && user->user_id > 0)
    487              {
    488                sprintf(c, percent_d, user_id);
    489                len_c=strlen(c);
    490                if (s)
    491                  len_s=strlen(s);
    492                s=realloc(s, len_s+len_c+2);
    493                if (len_s)
    494                {
    495                  s[len_s]=',';
    496                  s[len_s+1]='\0';
    497                }
    498                strcat(s, c);
    499              }
    500              user=user->next;
    501            }
    502            
    503            return s;
    504          }
    505          */
    506          
    507          char* create_noninfo_users_ids(CLIST* cl) 
    508          {
    509            char* s;
    510            char* s1;
    511            int i=0;
    512            
    513            CLIST* c=cl;
    514            
    515            while (c)
    516            {
    517              if (c->first_name==NULL && c->user_id > 0)
    518                i++;
    519              c=c->next;
    520            }
    521           
    522            if (i==0)
    523              return NULL;
    524            
    525            s=malloc(16 * i);
    526            s1=s;
    527            
    528            c=cl;
    529            
    530            while (c)
    531            {
    532              if (c->first_name==NULL && c->user_id > 0)
    533                s1+=sprintf(s1, percent_d, c->user_id);
    534              c=c->next;
    535            }
    536            return s;
    537          }
    538          
    539          char* create_noninfo_groups_ids(CLIST* cl)
    540          {
    541            char* s;
    542            char* s1;
    543            int i=0;
    544            
    545            CLIST* c=cl;
    546            
    547            while (c)
    548            {
    549              if (c->first_name==NULL && c->user_id < 0)
    550                i++;
    551              c=c->next;
    552            }
    553           
    554            if (i==0)
    555              return NULL;
    556            
    557            s=malloc(16 * i);
    558            s1=s;
    559            
    560            c=cl;
    561            
    562            while (c)
    563            {
    564              if (c->first_name==NULL && c->user_id < 0)
    565                s1+=sprintf(s1, percent_d, -c->user_id);
    566              c=c->next;
    567            }
    568            return s;  
    569          }
    570          
    571          char* create_unread_msg_ids(CLIST* cl) 
    572          {
    573            char* s;
    574            char* s1;
    575            int i=0;
    576            
    577            PERSONAL_MSG* msg=cl->msglist;
    578            
    579            while (msg)
    580            {
    581              if (msg->out==0)
    582              {
    583                if (msg->read_state==0)
    584                  i++;
    585              }
    586              msg=msg->next;
    587            }
    588           
    589            if (i==0)
    590              return NULL;
    591            
    592            s=malloc(16 * i);
    593            s1=s;
    594            
    595            msg=cl->msglist;
    596            
    597            while (msg)
    598            {
    599              if (msg->out==0)
    600              {
    601                if (msg->read_state==0)
    602                  s1+=sprintf(s1, percent_d, msg->user_id);
    603              }
    604              msg=msg->next;
    605            }
    606            return s;
    607          }
    608          
    609          //******************************************************************************
    610          

Errors: 44
Warnings: none
