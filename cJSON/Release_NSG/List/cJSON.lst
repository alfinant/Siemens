##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    21/Oct/2018  18:38:05 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\json\cJSON.c                                  #
#    Command line    =  E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\json\cJSON.c -D NEWSGOLD -lCN                 #
#                       E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\List\ -la                         #
#                       E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\List\ --diag_suppress Pe301 -o    #
#                       E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\Obj\ -z9 --cpu_mode arm --endian  #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --dlib_config                          #
#                       E:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I E:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\List\cJSON.lst                    #
#    Object file     =  E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\Obj\cJSON.r79                     #
#                                                                            #
#                                                                            #
##############################################################################

E:\Users\alfinant\Documents\Siemens\alfinant\src_iar\cJSON\json\cJSON.c
      1          /*
      2            Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
      3          
      4            Permission is hereby granted, free of charge, to any person obtaining a copy
      5            of this software and associated documentation files (the "Software"), to deal
      6            in the Software without restriction, including without limitation the rights
      7            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      8            copies of the Software, and to permit persons to whom the Software is
      9            furnished to do so, subject to the following conditions:
     10          
     11            The above copyright notice and this permission notice shall be included in
     12            all copies or substantial portions of the Software.
     13          
     14            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     15            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     16            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     17            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     18            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     19            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     20            THE SOFTWARE.
     21          */
     22          
     23          /* cJSON */
     24          /* JSON parser in C. */
     25          
     26          /* disable warnings about old C89 functions in MSVC */
     27          #if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
     28          #define _CRT_SECURE_NO_DEPRECATE
     29          #endif
     30          
     31          #ifdef __GNUC__
     32          #pragma GCC visibility push(default)
     33          #endif
     34          #if defined(_MSC_VER)
     35          #pragma warning (push)
     36          /* disable warning about single line comments in system headers */
     37          #pragma warning (disable : 4001)
     38          #endif
     39          
     40          #include <siemens\swilib.h>
     41          
     42          //#include <string.h>
     43          //#include <stdio.h>
     44          //#include <math.h>
     45          //#include <stdlib.h>
     46          #include <limits.h>
     47          //#include <ctype.h>
     48          
     49          #ifdef ENABLE_LOCALES
     50          #include <locale.h>
     51          #endif
     52          
     53          #if defined(_MSC_VER)
     54          #pragma warning (pop)
     55          #endif
     56          #ifdef __GNUC__
     57          #pragma GCC visibility pop
     58          #endif
     59          
     60          #include "cJSON.h"
     61          
     62          /* define our own boolean type */
     63          #define true ((cJSON_bool)1)
     64          #define false ((cJSON_bool)0)
     65          

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "null">`:
   \   00000000   6E756C6C00         DC8 "null"
   \   00000005   000000             DC8 0, 0, 0
   \   00000008   66616C736500       DC8 "false"
   \   0000000E   0000               DC8 0, 0
   \   00000010   7472756500         DC8 "true"
   \   00000015   000000             DC8 0, 0, 0
   \   00000018   25312E313567       DC8 "%1.15g"
   \              00          
   \   0000001F   00                 DC8 0
   \   00000020   25312E313767       DC8 "%1.17g"
   \              00          
   \   00000027   00                 DC8 0
   \   00000028   256C6700           DC8 "%lg"
     66          static const char percent_1_15g[] = "%1.15g";
     67          static const char percent_1_17g[] = "%1.17g";
     68          static const char percent_lg[] = "%lg";
     69          
     70          typedef struct {
     71              const unsigned char *json;
     72              size_t position;
     73          } error;
     74          static error global_error = { NULL, 0 };
     75          

   \                                 In segment CODE, align 4, keep-with-next
     76          CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
     77          {
     78              return (const char*) (global_error.json + global_error.position);
   \                     cJSON_GetErrorPtr:
   \   00000000   ........           LDR      R0,??DataTable2  ;; global_hooks
   \   00000004   101090E5           LDR      R1,[R0, #+16]
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   000081E0           ADD      R0,R1,R0
   \   00000010   1EFF2FE1           BX       LR               ;; return
     79          }
     80          

   \                                 In segment CODE, align 4, keep-with-next
     81          CJSON_PUBLIC(char *) cJSON_GetStringValue(cJSON *item) {
   \                     cJSON_GetStringValue:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     82              if (!cJSON_IsString(item)) {
   \   00000008   ........           BL       cJSON_IsString
   \   0000000C   000050E3           CMP      R0,#+0
     83                  return NULL;
   \   00000010   1080BD08           POPEQ    {R4,PC}
     84              }
     85          
     86              return item->valuestring;
   \   00000014   100094E5           LDR      R0,[R4, #+16]
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return
     87          }
     88          
     89          /* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
     90          #if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 8)
     91              #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
     92          #endif
     93          

   \                                 In segment CODE, align 4, keep-with-next
     94          CJSON_PUBLIC(const char*) cJSON_Version(void)
     95          {
   \                     cJSON_Version:
   \   00000000   10402DE9           PUSH     {R4,LR}
     96              static char version[15];
     97              sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
   \   00000004   20409FE5           LDR      R4,??cJSON_Version_0  ;; ??version
   \   00000008   20109FE5           LDR      R1,??cJSON_Version_0+0x4  ;; `?<Constant "%i.%i.%i">`
   \   0000000C   0800A0E3           MOV      R0,#+8
   \   00000010   01002DE9           PUSH     {R0}
   \   00000014   0730A0E3           MOV      R3,#+7
   \   00000018   0120A0E3           MOV      R2,#+1
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   160000EF           SWI      +22
     98          
     99              return version;
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   1280BDE8           POP      {R1,R4,PC}       ;; return
   \                     ??cJSON_Version_0:
   \   0000002C   ........           DC32     ??version
   \   00000030   ........           DC32     `?<Constant "%i.%i.%i">`
    100          }

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??version:
   \   00000000                      DS8 16
    101          
    102          /* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
    103          static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
    104          {
    105              if ((string1 == NULL) || (string2 == NULL))
    106              {
    107                  return 1;
    108              }
    109          
    110              if (string1 == string2)
    111              {
    112                  return 0;
    113              }
    114          
    115              for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
    116              {
    117                  if (*string1 == '\0')
    118                  {
    119                      return 0;
    120                  }
    121              }
    122          
    123              return tolower(*string1) - tolower(*string2);
    124          }
    125          
    126          typedef struct internal_hooks
    127          {
    128              void *(CJSON_CDECL *allocate)(size_t size);
    129              void (CJSON_CDECL *deallocate)(void *pointer);
    130              void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
    131          } internal_hooks;
    132          
    133          //#if defined(_MSC_VER)
    134          /* work around MSVC error C2322: '...' address of dillimport '...' is not static */

   \                                 In segment CODE, align 4, keep-with-next
    135          static void * CJSON_CDECL internal_malloc(size_t size)
    136          {
   \                     internal_malloc:
   \   00000000   00402DE9           PUSH     {LR}
    137              return malloc(size);
   \   00000004   140000EF           SWI      +20
   \   00000008   0080BDE8           POP      {PC}             ;; return
    138          }

   \                                 In segment CODE, align 4, keep-with-next
    139          static void CJSON_CDECL internal_free(void *pointer)
    140          {
   \                     internal_free:
   \   00000000   00402DE9           PUSH     {LR}
    141              mfree(pointer);
   \   00000004   150000EF           SWI      +21
    142          }
   \   00000008   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
    143          static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
    144          {
   \                     internal_realloc:
   \   00000000   00402DE9           PUSH     {LR}
    145              return realloc(pointer, size);
   \   00000004   BA0000EF           SWI      +186
   \   00000008   0080BDE8           POP      {PC}             ;; return
    146          }

   \                                 In segment DATA_I, align 4, align-sorted
    147          //#else
    148          //#define internal_malloc malloc
    149          //#define internal_free free
    150          //#define internal_realloc realloc
    151          //#endif
    152          
    153          static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
   \                     global_hooks:
   \   00000000                      DS8 12
   \   0000000C                      REQUIRE `?<Initializer for global_hooks>`
   \   0000000C                      DS8 8
   \   00000014                      REQUIRE `?<Initializer for global_error>`
    154          

   \                                 In segment CODE, align 4, keep-with-next
    155          static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
    156          {
   \                     cJSON_strdup:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    157              size_t length = 0;
    158              unsigned char *copy = NULL;
    159          
    160              if (string == NULL)
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   0600000A           BEQ      ??cJSON_strdup_0
    161              {
    162                  return NULL;
    163              }
    164          
    165              length = strlen((const char*)string) + sizeof("");
   \   00000014   1B0000EF           SWI      +27
    166              copy = (unsigned char*)hooks->allocate(length);
   \   00000018   001095E5           LDR      R1,[R5, #+0]
   \   0000001C   016080E2           ADD      R6,R0,#+1
   \   00000020   0600A0E1           MOV      R0,R6
   \   00000024   31FF2FE1           BLX      R1
   \   00000028   0050B0E1           MOVS     R5,R0
    167              if (copy == NULL)
   \   0000002C   0000001A           BNE      ??cJSON_strdup_1
    168              {
    169                  return NULL;
   \                     ??cJSON_strdup_0:
   \   00000030   ........           B        ??Subroutine107_1
    170              }
    171              memcpy(copy, string, length);
   \                     ??cJSON_strdup_1:
   \   00000034   0620A0E1           MOV      R2,R6
   \   00000038   0410A0E1           MOV      R1,R4
   \   0000003C   1E0100EF           SWI      +286
    172          
    173              return copy;
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   7080BDE8           POP      {R4-R6,PC}       ;; return
    174          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine107:
   \   00000000   ........           LDR      R3,??DataTable29  ;; global_hooks
   \   00000004   0060A0E1           MOV      R6,R0
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   01002DE9           PUSH     {R0}
   \   00000010   0620A0E1           MOV      R2,R6
   \   00000014   0510A0E1           MOV      R1,R5
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       add_item_to_object
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   04D08DE2           ADD      SP,SP,#+4
   \   00000028   0600A0E1           MOV      R0,R6
   \   0000002C   7080BD18           POPNE    {R4-R6,PC}
   \                     ??Subroutine107_0:
   \   00000030   ........           BL       cJSON_Delete
   \                     ??Subroutine107_1:
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   7080BDE8           POP      {R4-R6,PC}       ;; return
    175          

   \                                 In segment CODE, align 4, keep-with-next
    176          CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
    177          {
   \                     cJSON_InitHooks:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    178              if (hooks == NULL)
   \   00000004   ........           LDR      R4,??DataTable2  ;; global_hooks
   \   00000008   0050B0E1           MOVS     R5,R0
   \   0000000C   0400001A           BNE      ??cJSON_InitHooks_0
    179              {
    180                  /* Reset hooks */
    181                  global_hooks.allocate = (void*(*)(size_t)) malloc_adr();
   \   00000010   148000EF           SWI      +32788
   \   00000014   000084E5           STR      R0,[R4, #+0]
    182                  global_hooks.deallocate = (void(*)(void*)) mfree_adr();
   \   00000018   158000EF           SWI      +32789
   \   0000001C   040084E5           STR      R0,[R4, #+4]
    183                  global_hooks.reallocate = (void*(*)(void*, size_t)) realloc_adr();
   \   00000020   130000EA           B        ??cJSON_InitHooks_1
    184                  return;
    185              }
    186          
    187              global_hooks.allocate = (void*(*)(size_t)) malloc_adr();
   \                     ??cJSON_InitHooks_0:
   \   00000024   148000EF           SWI      +32788
    188              if (hooks->malloc_fn != NULL)
   \   00000028   001095E5           LDR      R1,[R5, #+0]
   \   0000002C   000051E3           CMP      R1,#+0
    189              {
    190                  global_hooks.allocate = hooks->malloc_fn;
   \   00000030   0100A011           MOVNE    R0,R1
   \   00000034   000084E5           STR      R0,[R4, #+0]
    191              }
    192          
    193              global_hooks.deallocate = (void(*)(void*)) mfree_adr();
   \   00000038   158000EF           SWI      +32789
    194              if (hooks->free_fn != NULL)
   \   0000003C   041095E5           LDR      R1,[R5, #+4]
   \   00000040   000051E3           CMP      R1,#+0
    195              {
    196                  global_hooks.deallocate = hooks->free_fn;
   \   00000044   0100A011           MOVNE    R0,R1
   \   00000048   040084E5           STR      R0,[R4, #+4]
    197              }
    198          
    199              /* use realloc only if both free and malloc are used */
    200              global_hooks.reallocate = NULL;
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   080084E5           STR      R0,[R4, #+8]
    201              if ((global_hooks.allocate == (void*(*)(size_t))malloc_adr()) && (global_hooks.deallocate == (void(*)(void*))mfree_adr()))
   \   00000054   148000EF           SWI      +32788
   \   00000058   001094E5           LDR      R1,[R4, #+0]
   \   0000005C   000051E1           CMP      R1,R0
   \   00000060   3080BD18           POPNE    {R4,R5,PC}
   \   00000064   158000EF           SWI      +32789
   \   00000068   041094E5           LDR      R1,[R4, #+4]
   \   0000006C   000051E1           CMP      R1,R0
   \   00000070   3080BD18           POPNE    {R4,R5,PC}
    202              {
    203                  global_hooks.reallocate = (void*(*)(void*, size_t))realloc_adr();
   \                     ??cJSON_InitHooks_1:
   \   00000074   BA8000EF           SWI      +32954
   \   00000078   080084E5           STR      R0,[R4, #+8]
   \   0000007C   3080BDE8           POP      {R4,R5,PC}       ;; return
    204              }
    205          }
    206          
    207          /* Internal constructor. */

   \                                 In segment CODE, align 4, keep-with-next
    208          static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
    209          {
   \                     cJSON_New_Item:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0010A0E1           MOV      R1,R0
    210              cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
   \   00000008   001091E5           LDR      R1,[R1, #+0]
   \   0000000C   2400A0E3           MOV      R0,#+36
   \   00000010   31FF2FE1           BLX      R1
   \   00000014   0040B0E1           MOVS     R4,R0
    211              if (node)
   \   00000018   0200000A           BEQ      ??cJSON_New_Item_0
    212              {
    213                  memset(node, '\0', sizeof(cJSON));
   \   0000001C   2420A0E3           MOV      R2,#+36
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   BB0000EF           SWI      +187
    214              }
    215          
    216              return node;
   \                     ??cJSON_New_Item_0:
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
    217          }
    218          
    219          /* Delete a cJSON structure. */

   \                                 In segment CODE, align 4, keep-with-next
    220          CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
    221          {
   \                     cJSON_Delete:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    222              cJSON *next = NULL;
   \   00000004   ........           LDR      R6,??DataTable2  ;; global_hooks
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   1B0000EA           B        ??cJSON_Delete_0
    223              while (item != NULL)
    224              {
    225                  next = item->next;
    226                  if (!(item->type & cJSON_IsReference) && (item->child != NULL))
   \                     ??cJSON_Delete_1:
   \   00000010   0C0094E5           LDR      R0,[R4, #+12]
   \   00000014   005094E5           LDR      R5,[R4, #+0]
   \   00000018   400F10E3           TST      R0,#0x100
   \   0000001C   0300001A           BNE      ??cJSON_Delete_2
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0000000A           BEQ      ??cJSON_Delete_2
    227                  {
    228                      cJSON_Delete(item->child);
   \   0000002C   F3FFFFEB           BL       cJSON_Delete
    229                  }
    230                  if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
   \                     ??cJSON_Delete_2:
   \   00000030   0C0094E5           LDR      R0,[R4, #+12]
   \   00000034   400F10E3           TST      R0,#0x100
   \   00000038   0400001A           BNE      ??cJSON_Delete_3
   \   0000003C   100094E5           LDR      R0,[R4, #+16]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0100000A           BEQ      ??cJSON_Delete_3
    231                  {
    232                      global_hooks.deallocate(item->valuestring);
   \   00000048   041096E5           LDR      R1,[R6, #+4]
   \   0000004C   31FF2FE1           BLX      R1
    233                  }
    234                  if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
   \                     ??cJSON_Delete_3:
   \   00000050   0C0094E5           LDR      R0,[R4, #+12]
   \   00000054   800F10E3           TST      R0,#0x200
   \   00000058   0400001A           BNE      ??cJSON_Delete_4
   \   0000005C   200094E5           LDR      R0,[R4, #+32]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0100000A           BEQ      ??cJSON_Delete_4
    235                  {
    236                      global_hooks.deallocate(item->string);
   \   00000068   041096E5           LDR      R1,[R6, #+4]
   \   0000006C   31FF2FE1           BLX      R1
    237                  }
    238                  global_hooks.deallocate(item);
   \                     ??cJSON_Delete_4:
   \   00000070   041096E5           LDR      R1,[R6, #+4]
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   31FF2FE1           BLX      R1
    239                  item = next;
   \   0000007C   0540A0E1           MOV      R4,R5
    240              }
   \                     ??cJSON_Delete_0:
   \   00000080   000054E3           CMP      R4,#+0
   \   00000084   E1FFFF1A           BNE      ??cJSON_Delete_1
    241          }
   \   00000088   7080BDE8           POP      {R4-R6,PC}       ;; return
    242          
    243          /* get the decimal point character of the current locale */
    244          static unsigned char get_decimal_point(void)
    245          {
    246          #ifdef ENABLE_LOCALES
    247              struct lconv *lconv = localeconv();
    248              return (unsigned char) lconv->decimal_point[0];
    249          #else
    250              return '.';
    251          #endif
    252          }
    253          
    254          typedef struct
    255          {
    256              const unsigned char *content;
    257              size_t length;
    258              size_t offset;
    259              size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
    260              internal_hooks hooks;
    261          } parse_buffer;
    262          
    263          /* check if the given size is left to read in a given parse buffer (starting with 1) */
    264          #define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
    265          /* check if the buffer can be accessed at the given index (starting with 0) */
    266          #define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
    267          #define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
    268          /* get a pointer to the buffer at the position */
    269          #define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
    270          
    271          /* Parse the input text to generate a number, and populate the result into item. */

   \                                 In segment CODE, align 4, keep-with-next
    272          static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
    273          {
   \                     parse_number:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   44D04DE2           SUB      SP,SP,#+68
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150B0E1           MOVS     R5,R1
    274              double number = 0;
    275              unsigned char *after_end = NULL;
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   00008DE5           STR      R0,[SP, #+0]
    276              unsigned char number_c_string[64];
    277              unsigned char decimal_point = get_decimal_point();
    278              size_t i = 0;
    279          
    280              if ((input_buffer == NULL) || (input_buffer->content == NULL))
   \   00000018   00109515           LDRNE    R1,[R5, #+0]
   \   0000001C   00005113           CMPNE    R1,#+0
   \   00000020   0100001A           BNE      ??parse_number_0
    281              {
    282                  return false;
   \                     ??parse_number_1:
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   4A0000EA           B        ??parse_number_2
    283              }
    284          
    285              /* copy the number into a temporary buffer and replace '.' with the decimal point
    286               * of the current locale (for strtod)
    287               * This also takes care of '\0' not necessarily being available for marking the end of the input */
    288              for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
   \                     ??parse_number_0:
   \   0000002C   0010A0E3           MOV      R1,#+0
   \                     ??parse_number_3:
   \   00000030   082095E5           LDR      R2,[R5, #+8]
   \   00000034   04C095E5           LDR      R12,[R5, #+4]
   \   00000038   023081E0           ADD      R3,R1,R2
   \   0000003C   0C0053E1           CMP      R3,R12
   \   00000040   1700002A           BCS      ??parse_number_4
    289              {
    290                  switch (buffer_at_offset(input_buffer)[i])
   \   00000044   003095E5           LDR      R3,[R5, #+0]
   \   00000048   032082E0           ADD      R2,R2,R3
   \   0000004C   022081E0           ADD      R2,R1,R2
   \   00000050   00C0D2E5           LDRB     R12,[R2, #+0]
   \   00000054   04308DE2           ADD      R3,SP,#+4
   \   00000058   033081E0           ADD      R3,R1,R3
   \   0000005C   2BC05CE2           SUBS     R12,R12,#+43
   \   00000060   02C05C12           SUBSNE   R12,R12,#+2
   \   00000064   0700000A           BEQ      ??parse_number_5
   \   00000068   01C05CE2           SUBS     R12,R12,#+1
   \   0000006C   0700000A           BEQ      ??parse_number_6
   \   00000070   02C04CE2           SUB      R12,R12,#+2
   \   00000074   09005CE3           CMP      R12,#+9
   \   00000078   0200009A           BLS      ??parse_number_5
   \   0000007C   15C05CE2           SUBS     R12,R12,#+21
   \   00000080   20C05C12           SUBSNE   R12,R12,#+32
   \   00000084   0600001A           BNE      ??parse_number_4
    291                  {
    292                      case '0':
    293                      case '1':
    294                      case '2':
    295                      case '3':
    296                      case '4':
    297                      case '5':
    298                      case '6':
    299                      case '7':
    300                      case '8':
    301                      case '9':
    302                      case '+':
    303                      case '-':
    304                      case 'e':
    305                      case 'E':
    306                          number_c_string[i] = buffer_at_offset(input_buffer)[i];
   \                     ??parse_number_5:
   \   00000088   0020D2E5           LDRB     R2,[R2, #+0]
   \   0000008C   000000EA           B        ??parse_number_7
    307                          break;
    308          
    309                      case '.':
    310                          number_c_string[i] = decimal_point;
   \                     ??parse_number_6:
   \   00000090   2E20A0E3           MOV      R2,#+46
    311                          break;
    312          
    313                      default:
    314                          goto loop_end;
    315                  }
    316              }
   \                     ??parse_number_7:
   \   00000094   011081E2           ADD      R1,R1,#+1
   \   00000098   0020C3E5           STRB     R2,[R3, #+0]
   \   0000009C   3F0051E3           CMP      R1,#+63
   \   000000A0   E2FFFF3A           BCC      ??parse_number_3
    317          loop_end:
    318              number_c_string[i] = '\0';
   \                     ??parse_number_4:
   \   000000A4   04208DE2           ADD      R2,SP,#+4
   \   000000A8   0200C1E7           STRB     R0,[R1, +R2]
    319          
    320              number = strtod((const char*)number_c_string, (char**)&after_end);
   \   000000AC   0D10A0E1           MOV      R1,SP
   \   000000B0   04008DE2           ADD      R0,SP,#+4
   \   000000B4   ........           _BLF     strtod,??strtod??rA
   \   000000B8   0170A0E1           MOV      R7,R1
    321              if (number_c_string == after_end)
   \   000000BC   00109DE5           LDR      R1,[SP, #+0]
   \   000000C0   0060A0E1           MOV      R6,R0
   \   000000C4   04008DE2           ADD      R0,SP,#+4
   \   000000C8   010050E1           CMP      R0,R1
   \   000000CC   D4FFFF0A           BEQ      ??parse_number_1
    322              {
    323                  return false; /* parse_error */
    324              }
    325          
    326              item->valuedouble = number;
   \   000000D0   186084E5           STR      R6,[R4, #+24]
   \   000000D4   1C7084E5           STR      R7,[R4, #+28]
    327          
    328              /* use saturation in case of overflow */
    329              if (number >= INT_MAX)
   \   000000D8   0600A0E1           MOV      R0,R6
   \   000000DC   0710A0E1           MOV      R1,R7
   \   000000E0   C024A0E3           MOV      R2,#-1073741824
   \   000000E4   FF2582E3           ORR      R2,R2,#0x3FC00000
   \   000000E8   B034E0E3           MVN      R3,#-1342177280
   \   000000EC   E236C3E3           BIC      R3,R3,#0xE200000
   \   000000F0   ........           _BLF     __dGreaterEqual,??__dGreaterEqual??rA
   \   000000F4   000050E3           CMP      R0,#+0
    330              {
    331                  item->valueint = INT_MAX;
   \   000000F8   8004E013           MVNNE    R0,#-2147483648
   \   000000FC   0B00001A           BNE      ??parse_number_8
    332              }
    333              else if (number <= (double)INT_MIN)
   \   00000100   0600A0E1           MOV      R0,R6
   \   00000104   0710A0E1           MOV      R1,R7
   \   00000108   0120E0E3           MVN      R2,#+1
   \   0000010C   C035E0E3           MVN      R3,#+805306368
   \   00000110   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000114   ........           _BLF     __dLess,??__dLess??rA
   \   00000118   000050E3           CMP      R0,#+0
    334              {
    335                  item->valueint = INT_MIN;
   \   0000011C   8004A013           MOVNE    R0,#-2147483648
   \   00000120   0200001A           BNE      ??parse_number_8
    336              }
    337              else
    338              {
    339                  item->valueint = (int)number;
   \   00000124   0600A0E1           MOV      R0,R6
   \   00000128   0710A0E1           MOV      R1,R7
   \   0000012C   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \                     ??parse_number_8:
   \   00000130   140084E5           STR      R0,[R4, #+20]
    340              }
    341          
    342              item->type = cJSON_Number;
   \   00000134   0800A0E3           MOV      R0,#+8
   \   00000138   0C0084E5           STR      R0,[R4, #+12]
    343          
    344              input_buffer->offset += (size_t)(after_end - number_c_string);
   \   0000013C   080095E5           LDR      R0,[R5, #+8]
   \   00000140   00109DE5           LDR      R1,[SP, #+0]
   \   00000144   000081E0           ADD      R0,R1,R0
   \   00000148   04108DE2           ADD      R1,SP,#+4
   \   0000014C   010040E0           SUB      R0,R0,R1
   \   00000150   080085E5           STR      R0,[R5, #+8]
    345              return true;
   \   00000154   0100A0E3           MOV      R0,#+1
   \                     ??parse_number_2:
   \   00000158   44D08DE2           ADD      SP,SP,#+68       ;; stack cleaning
   \   0000015C   F080BDE8           POP      {R4-R7,PC}       ;; return
    346          }
    347          
    348          /* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */

   \                                 In segment CODE, align 4, keep-with-next
    349          CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
    350          {
   \                     cJSON_SetNumberHelper:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0060A0E1           MOV      R6,R0
    351              if (number >= INT_MAX)
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   0510A0E1           MOV      R1,R5
   \   00000018   C024A0E3           MOV      R2,#-1073741824
   \   0000001C   FF2582E3           ORR      R2,R2,#0x3FC00000
   \   00000020   B034E0E3           MVN      R3,#-1342177280
   \   00000024   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000028   ........           _BLF     __dGreaterEqual,??__dGreaterEqual??rA
   \   0000002C   000050E3           CMP      R0,#+0
    352              {
    353                  object->valueint = INT_MAX;
   \   00000030   8004E013           MVNNE    R0,#-2147483648
   \   00000034   0B00001A           BNE      ??cJSON_SetNumberHelper_0
    354              }
    355              else if (number <= (double)INT_MIN)
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0120E0E3           MVN      R2,#+1
   \   00000044   C035E0E3           MVN      R3,#+805306368
   \   00000048   E236C3E3           BIC      R3,R3,#0xE200000
   \   0000004C   ........           _BLF     __dLess,??__dLess??rA
   \   00000050   000050E3           CMP      R0,#+0
    356              {
    357                  object->valueint = INT_MIN;
   \   00000054   8004A013           MOVNE    R0,#-2147483648
   \   00000058   0200001A           BNE      ??cJSON_SetNumberHelper_0
    358              }
    359              else
    360              {
    361                  object->valueint = (int)number;
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \                     ??cJSON_SetNumberHelper_0:
   \   00000068   140086E5           STR      R0,[R6, #+20]
    362              }
    363          
    364              return object->valuedouble = number;
   \   0000006C   184086E5           STR      R4,[R6, #+24]
   \   00000070   1C5086E5           STR      R5,[R6, #+28]
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   0510A0E1           MOV      R1,R5
   \   0000007C   7080BDE8           POP      {R4-R6,PC}       ;; return
    365          }
    366          
    367          typedef struct
    368          {
    369              unsigned char *buffer;
    370              size_t length;
    371              size_t offset;
    372              size_t depth; /* current nesting depth (for formatted printing) */
    373              cJSON_bool noalloc;
    374              cJSON_bool format; /* is this print a formatted print */
    375              internal_hooks hooks;
    376          } printbuffer;
    377          
    378          /* realloc printbuffer if necessary to have at least "needed" bytes more */

   \                                 In segment CODE, align 4, keep-with-next
    379          static unsigned char* ensure(printbuffer * const p, size_t needed)
    380          {
   \                     ensure:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    381              unsigned char *newbuffer = NULL;
    382              size_t newsize = 0;
    383          
    384              if ((p == NULL) || (p->buffer == NULL))
   \   00000008   00009415           LDRNE    R0,[R4, #+0]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   0000001A           BNE      ??ensure_0
    385              {
    386                  return NULL;
   \                     ??ensure_1:
   \   00000014   ........           B        ??Subroutine107_1
    387              }
    388          
    389              if ((p->length > 0) && (p->offset >= p->length))
   \                     ??ensure_0:
   \   00000018   043094E5           LDR      R3,[R4, #+4]
   \   0000001C   082094E5           LDR      R2,[R4, #+8]
   \   00000020   000053E3           CMP      R3,#+0
   \   00000024   0100000A           BEQ      ??ensure_2
   \   00000028   030052E1           CMP      R2,R3
   \   0000002C   F8FFFF2A           BCS      ??ensure_1
    390              {
    391                  /* make sure that offset is valid */
    392                  return NULL;
    393              }
    394          
    395              if (needed > INT_MAX)
   \                     ??ensure_2:
   \   00000030   800451E3           CMP      R1,#-2147483648
   \   00000034   F6FFFF2A           BCS      ??ensure_1
    396              {
    397                  /* sizes bigger than INT_MAX are currently not supported */
    398                  return NULL;
    399              }
    400          
    401              needed += p->offset + 1;
   \   00000038   015082E2           ADD      R5,R2,#+1
   \   0000003C   011085E0           ADD      R1,R5,R1
    402              if (needed <= p->length)
   \   00000040   010053E1           CMP      R3,R1
    403              {
    404                  return p->buffer + p->offset;
   \   00000044   00008220           ADDCS    R0,R2,R0
   \   00000048   7080BD28           POPCS    {R4-R6,PC}
    405              }
    406          
    407              if (p->noalloc) {
   \   0000004C   102094E5           LDR      R2,[R4, #+16]
   \   00000050   000052E3           CMP      R2,#+0
   \   00000054   EEFFFF1A           BNE      ??ensure_1
    408                  return NULL;
    409              }
    410          
    411              /* calculate new buffer size */
    412              if (needed > (INT_MAX / 2))
   \   00000058   400451E3           CMP      R1,#+1073741824
   \   0000005C   0300003A           BCC      ??ensure_3
    413              {
    414                  /* overflow of int, use INT_MAX if possible */
    415                  if (needed <= INT_MAX)
   \   00000060   800451E3           CMP      R1,#-2147483648
   \   00000064   EAFFFF2A           BCS      ??ensure_1
    416                  {
    417                      newsize = INT_MAX;
   \   00000068   8054E0E3           MVN      R5,#-2147483648
   \   0000006C   000000EA           B        ??ensure_4
    418                  }
    419                  else
    420                  {
    421                      return NULL;
    422                  }
    423              }
    424              else
    425              {
    426                  newsize = needed * 2;
   \                     ??ensure_3:
   \   00000070   8150A0E1           LSL      R5,R1,#+1
    427              }
    428          
    429              if (p->hooks.reallocate != NULL)
   \                     ??ensure_4:
   \   00000074   202094E5           LDR      R2,[R4, #+32]
   \   00000078   000052E3           CMP      R2,#+0
   \   0000007C   0A00000A           BEQ      ??ensure_5
    430              {
    431                  /* reallocate with realloc if available */
    432                  newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
   \   00000080   0510A0E1           MOV      R1,R5
   \   00000084   32FF2FE1           BLX      R2
   \   00000088   0060B0E1           MOVS     R6,R0
    433                  if (newbuffer == NULL)
   \   0000008C   1300001A           BNE      ??ensure_6
    434                  {
    435                      p->hooks.deallocate(p->buffer);
   \                     ??ensure_7:
   \   00000090   000094E5           LDR      R0,[R4, #+0]
   \   00000094   1C1094E5           LDR      R1,[R4, #+28]
   \   00000098   31FF2FE1           BLX      R1
    436                      p->length = 0;
   \   0000009C   0000A0E3           MOV      R0,#+0
   \   000000A0   040084E5           STR      R0,[R4, #+4]
    437                      p->buffer = NULL;
   \   000000A4   000084E5           STR      R0,[R4, #+0]
   \   000000A8   D9FFFFEA           B        ??ensure_1
    438          
    439                      return NULL;
    440                  }
    441              }
    442              else
    443              {
    444                  /* otherwise reallocate manually */
    445                  newbuffer = (unsigned char*)p->hooks.allocate(newsize);
   \                     ??ensure_5:
   \   000000AC   181094E5           LDR      R1,[R4, #+24]
   \   000000B0   0500A0E1           MOV      R0,R5
   \   000000B4   31FF2FE1           BLX      R1
   \   000000B8   0060B0E1           MOVS     R6,R0
    446                  if (!newbuffer)
   \   000000BC   F3FFFF0A           BEQ      ??ensure_7
    447                  {
    448                      p->hooks.deallocate(p->buffer);
    449                      p->length = 0;
    450                      p->buffer = NULL;
    451          
    452                      return NULL;
    453                  }
    454                  if (newbuffer)
    455                  {
    456                      memcpy(newbuffer, p->buffer, p->offset + 1);
   \   000000C0   080094E5           LDR      R0,[R4, #+8]
   \   000000C4   001094E5           LDR      R1,[R4, #+0]
   \   000000C8   012080E2           ADD      R2,R0,#+1
   \   000000CC   0600A0E1           MOV      R0,R6
   \   000000D0   1E0100EF           SWI      +286
    457                  }
    458                  p->hooks.deallocate(p->buffer);
   \   000000D4   000094E5           LDR      R0,[R4, #+0]
   \   000000D8   1C1094E5           LDR      R1,[R4, #+28]
   \   000000DC   31FF2FE1           BLX      R1
    459              }
    460              p->length = newsize;
   \                     ??ensure_6:
   \   000000E0   045084E5           STR      R5,[R4, #+4]
    461              p->buffer = newbuffer;
   \   000000E4   006084E5           STR      R6,[R4, #+0]
    462          
    463              return newbuffer + p->offset;
   \   000000E8   080094E5           LDR      R0,[R4, #+8]
   \   000000EC   060080E0           ADD      R0,R0,R6
   \   000000F0   7080BDE8           POP      {R4-R6,PC}       ;; return
    464          }
    465          
    466          /* calculate the new length of the string in a printbuffer and update the offset */

   \                                 In segment CODE, align 4, keep-with-next
    467          static void update_offset(printbuffer * const buffer)
    468          {
   \                     update_offset:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    469              const unsigned char *buffer_pointer = NULL;
    470              if ((buffer == NULL) || (buffer->buffer == NULL))
   \   00000008   00009415           LDRNE    R0,[R4, #+0]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   1080BD08           POPEQ    {R4,PC}
    471              {
    472                  return;
    473              }
    474              buffer_pointer = buffer->buffer + buffer->offset;
    475          
    476              buffer->offset += strlen((const char*)buffer_pointer);
   \   00000014   081094E5           LDR      R1,[R4, #+8]
   \   00000018   000081E0           ADD      R0,R1,R0
   \   0000001C   1B0000EF           SWI      +27
   \   00000020   081094E5           LDR      R1,[R4, #+8]
   \   00000024   010080E0           ADD      R0,R0,R1
   \   00000028   080084E5           STR      R0,[R4, #+8]
    477          }
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
    478          
    479          /* Render the number nicely from the given item into a string. */

   \                                 In segment CODE, align 4, keep-with-next
    480          static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
    481          {
   \                     print_number:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
    482              unsigned char *output_pointer = NULL;
    483              double d = item->valuedouble;
   \   00000008   184090E5           LDR      R4,[R0, #+24]
   \   0000000C   1C5090E5           LDR      R5,[R0, #+28]
   \   00000010   0180B0E1           MOVS     R8,R1
    484              int length = 0;
    485              size_t i = 0;
    486              unsigned char number_buffer[26]; /* temporary buffer to print the number into */
    487              unsigned char decimal_point = get_decimal_point();
    488              double test;
    489          
    490              if (output_buffer == NULL)
   \   00000014   0100001A           BNE      ??print_number_0
    491              {
    492                  return false;
   \                     ??print_number_1:
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   3F0000EA           B        ??print_number_2
    493              }
    494          
    495              /* This checks for NaN and Infinity */
    496              if ((d * 0) != 0)
   \                     ??print_number_0:
   \   00000020   ........           LDR      R6,??DataTable10  ;; `?<Constant "null">`
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   0420A0E1           MOV      R2,R4
   \   00000030   0530A0E1           MOV      R3,R5
   \   00000034   ........           _BLF     __dMul,??__dMul??rA
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0230A0E1           MOV      R3,R2
   \   00000040   ........           _BLF     __dNotEqual,??__dNotEqual??rA
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0300000A           BEQ      ??print_number_3
    497              {
    498                  length = sprintf((char*)number_buffer, "null");
   \   0000004C   0610A0E1           MOV      R1,R6
   \   00000050   08008DE2           ADD      R0,SP,#+8
   \   00000054   160000EF           SWI      +22
   \   00000058   170000EA           B        ??print_number_4
    499              }
    500              else
    501              {
    502                  /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
    503                  length = sprintf((char*)number_buffer, percent_1_15g, d);
   \                     ??print_number_3:
   \   0000005C   0420A0E1           MOV      R2,R4
   \   00000060   0530A0E1           MOV      R3,R5
   \   00000064   181086E2           ADD      R1,R6,#+24
   \   00000068   08008DE2           ADD      R0,SP,#+8
   \   0000006C   160000EF           SWI      +22
   \   00000070   0070A0E1           MOV      R7,R0
    504          
    505                  /* Check whether the original double can be recovered */
    506                  if ((sscanf((char*)number_buffer, percent_lg, &test) != 1) || ((double)test != d))
   \   00000074   0D20A0E1           MOV      R2,SP
   \   00000078   281086E2           ADD      R1,R6,#+40
   \   0000007C   08008DE2           ADD      R0,SP,#+8
   \   00000080   F50100EF           SWI      +501
   \   00000084   010050E3           CMP      R0,#+1
   \   00000088   0600001A           BNE      ??print_number_5
   \   0000008C   0D00A0E1           MOV      R0,SP
   \   00000090   030090E8           LDM      R0,{R0,R1}
   \   00000094   0420A0E1           MOV      R2,R4
   \   00000098   0530A0E1           MOV      R3,R5
   \   0000009C   ........           _BLF     __dNotEqual,??__dNotEqual??rA
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   0500000A           BEQ      ??print_number_6
    507                  {
    508                      /* If not, print with 17 decimal places of precision */
    509                      length = sprintf((char*)number_buffer, percent_1_17g, d);
   \                     ??print_number_5:
   \   000000A8   0420A0E1           MOV      R2,R4
   \   000000AC   0530A0E1           MOV      R3,R5
   \   000000B0   201086E2           ADD      R1,R6,#+32
   \   000000B4   08008DE2           ADD      R0,SP,#+8
   \   000000B8   160000EF           SWI      +22
   \                     ??print_number_4:
   \   000000BC   0070A0E1           MOV      R7,R0
    510                  }
    511              }
    512          
    513              /* sprintf failed or buffer overrun occured */
    514              if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
   \                     ??print_number_6:
   \   000000C0   000057E3           CMP      R7,#+0
   \   000000C4   D3FFFF4A           BMI      ??print_number_1
   \   000000C8   1A0057E3           CMP      R7,#+26
   \   000000CC   D1FFFFAA           BGE      ??print_number_1
    515              {
    516                  return false;
    517              }
    518          
    519              /* reserve appropriate space in the output */
    520              output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
   \   000000D0   011087E2           ADD      R1,R7,#+1
   \   000000D4   0800A0E1           MOV      R0,R8
   \   000000D8   ........           BL       ensure
    521              if (output_pointer == NULL)
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   0E00000A           BEQ      ??print_number_2
    522              {
    523                  return false;
    524              }
    525          
    526              /* copy the printed number to the output and replace locale
    527               * dependent decimal point with '.' */
    528              for (i = 0; i < ((size_t)length); i++)
   \   000000E4   0010A0E3           MOV      R1,#+0
   \   000000E8   0020A0E3           MOV      R2,#+0
   \   000000EC   000000EA           B        ??print_number_7
    529              {
    530                  if (number_buffer[i] == decimal_point)
    531                  {
    532                      output_pointer[i] = '.';
    533                      continue;
    534                  }
    535          
    536                  output_pointer[i] = number_buffer[i];
   \                     ??print_number_8:
   \   000000F0   012082E2           ADD      R2,R2,#+1
   \                     ??print_number_7:
   \   000000F4   070052E1           CMP      R2,R7
   \   000000F8   08608D32           ADDCC    R6,SP,#+8
   \   000000FC   0660D237           LDRBCC   R6,[R2, +R6]
   \   00000100   003082E0           ADD      R3,R2,R0
   \   00000104   0060C335           STRBCC   R6,[R3, #+0]
   \   00000108   F8FFFF3A           BCC      ??print_number_8
    537              }
    538              output_pointer[i] = '\0';
   \   0000010C   0010C3E5           STRB     R1,[R3, #+0]
    539          
    540              output_buffer->offset += (size_t)length;
   \   00000110   080098E5           LDR      R0,[R8, #+8]
   \   00000114   000087E0           ADD      R0,R7,R0
   \   00000118   080088E5           STR      R0,[R8, #+8]
    541          
    542              return true;
   \   0000011C   0100A0E3           MOV      R0,#+1
   \                     ??print_number_2:
   \   00000120                      REQUIRE ?Subroutine111
   \   00000120                      ;; // Fall through to label ?Subroutine111
    543          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine111:
   \   00000000   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   00000004   F081BDE8           POP      {R4-R8,PC}       ;; return
    544          
    545          /* parse 4 digit hexadecimal number */

   \                                 In segment CODE, align 4, keep-with-next
    546          static unsigned parse_hex4(const unsigned char * const input)
    547          {
    548              unsigned int h = 0;
   \                     parse_hex4:
   \   00000000   0010A0E3           MOV      R1,#+0
    549              size_t i = 0;
    550          
    551              for (i = 0; i < 4; i++)
   \   00000004   0020A0E3           MOV      R2,#+0
    552              {
    553                  /* parse digit */
    554                  if ((input[i] >= '0') && (input[i] <= '9'))
   \                     ??parse_hex4_0:
   \   00000008   003082E0           ADD      R3,R2,R0
   \   0000000C   00C0D3E5           LDRB     R12,[R3, #+0]
   \   00000010   30005CE3           CMP      R12,#+48
   \   00000014   0900003A           BCC      ??parse_hex4_1
   \   00000018   3A005CE3           CMP      R12,#+58
   \   0000001C   0700002A           BCS      ??parse_hex4_1
    555                  {
    556                      h += (unsigned int) input[i] - '0';
   \   00000020   30304CE2           SUB      R3,R12,#+48
   \                     ??parse_hex4_2:
   \   00000024   011083E0           ADD      R1,R3,R1
    557                  }
    558                  else if ((input[i] >= 'A') && (input[i] <= 'F'))
    559                  {
    560                      h += (unsigned int) 10 + input[i] - 'A';
    561                  }
    562                  else if ((input[i] >= 'a') && (input[i] <= 'f'))
    563                  {
    564                      h += (unsigned int) 10 + input[i] - 'a';
    565                  }
    566                  else /* invalid */
    567                  {
    568                      return 0;
    569                  }
    570          
    571                  if (i < 3)
   \   00000028   030052E3           CMP      R2,#+3
    572                  {
    573                      /* shift left to make place for the next nibble */
    574                      h = h << 4;
   \   0000002C   0112A031           LSLCC    R1,R1,#+4
    575                  }
   \   00000030   012082E2           ADD      R2,R2,#+1
   \   00000034   040052E3           CMP      R2,#+4
   \   00000038   F2FFFF3A           BCC      ??parse_hex4_0
    576              }
    577          
    578              return h;
   \   0000003C   ........           B        ?Subroutine103
   \                     ??parse_hex4_1:
   \   00000040   41005CE3           CMP      R12,#+65
   \   00000044   0200003A           BCC      ??parse_hex4_3
   \   00000048   47005CE3           CMP      R12,#+71
   \   0000004C   37304C32           SUBCC    R3,R12,#+55
   \   00000050   F3FFFF3A           BCC      ??parse_hex4_2
   \                     ??parse_hex4_3:
   \   00000054   61005CE3           CMP      R12,#+97
   \   00000058   0200003A           BCC      ??parse_hex4_4
   \   0000005C   67005CE3           CMP      R12,#+103
   \   00000060   57304C32           SUBCC    R3,R12,#+87
   \   00000064   EEFFFF3A           BCC      ??parse_hex4_2
   \                     ??parse_hex4_4:
   \   00000068   ........           B        ??Subroutine102_1
    579          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine103:
   \   00000000   0100A0E1           MOV      R0,R1
   \   00000004   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine102:
   \   00000000   0100A003           MOVEQ    R0,#+1
   \                     ??Subroutine102_0:
   \   00000004   1EFF2F01           BXEQ     LR
   \                     ??Subroutine102_1:
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    580          
    581          /* converts a UTF-16 literal to UTF-8
    582           * A literal can be one or two sequences of the form \uXXXX */

   \                                 In segment CODE, align 4, keep-with-next
    583          static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
    584          {
   \                     utf16_literal_to_utf8:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0240A0E1           MOV      R4,R2
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0180A0E1           MOV      R8,R1
    585              long unsigned int codepoint = 0;
    586              unsigned int first_code = 0;
    587              const unsigned char *first_sequence = input_pointer;
    588              unsigned char utf8_length = 0;
    589              unsigned char utf8_position = 0;
    590              unsigned char sequence_length = 0;
    591              unsigned char first_byte_mark = 0;
   \   00000010   0050A0E3           MOV      R5,#+0
    592          
    593              if ((input_end - first_sequence) < 6)
   \   00000014   070048E0           SUB      R0,R8,R7
   \   00000018   060050E3           CMP      R0,#+6
   \   0000001C   060000BA           BLT      ??utf16_literal_to_utf8_0
    594              {
    595                  /* input ends unexpectedly */
    596                  goto fail;
    597              }
    598          
    599              /* get the first utf16 sequence */
    600              first_code = parse_hex4(first_sequence + 2);
   \   00000020   020087E2           ADD      R0,R7,#+2
   \   00000024   ........           BL       parse_hex4
   \   00000028   0060A0E1           MOV      R6,R0
    601          
    602              /* check that the code is valid */
    603              if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
   \   0000002C   DC0C56E3           CMP      R6,#+56320
   \   00000030   0200003A           BCC      ??utf16_literal_to_utf8_1
   \   00000034   E00C56E3           CMP      R6,#+57344
   \   00000038   1900002A           BCS      ??utf16_literal_to_utf8_2
    604              {
    605                  goto fail;
    606              }
    607          
    608              /* UTF16 surrogate pair */
    609              if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
    610              {
    611                  const unsigned char *second_sequence = first_sequence + 6;
    612                  unsigned int second_code = 0;
    613                  sequence_length = 12; /* \uXXXX\uXXXX */
    614          
    615                  if ((input_end - second_sequence) < 6)
    616                  {
    617                      /* input ends unexpectedly */
    618                      goto fail;
    619                  }
    620          
    621                  if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
    622                  {
    623                      /* missing second half of the surrogate pair */
    624                      goto fail;
    625                  }
    626          
    627                  /* get the second utf16 sequence */
    628                  second_code = parse_hex4(second_sequence + 2);
    629                  /* check that the code is valid */
    630                  if ((second_code < 0xDC00) || (second_code > 0xDFFF))
    631                  {
    632                      /* invalid second half of the surrogate pair */
    633                      goto fail;
    634                  }
    635          
    636          
    637                  /* calculate the unicode codepoint from the surrogate pair */
    638                  codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
    639              }
    640              else
    641              {
    642                  sequence_length = 6; /* \uXXXX */
    643                  codepoint = first_code;
    644              }
    645          
    646              /* encode as UTF-8
    647               * takes at maximum 4 bytes to encode:
    648               * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    649              if (codepoint < 0x80)
    650              {
    651                  /* normal ascii, encoding 0xxxxxxx */
    652                  utf8_length = 1;
    653              }
    654              else if (codepoint < 0x800)
    655              {
    656                  /* two bytes, encoding 110xxxxx 10xxxxxx */
    657                  utf8_length = 2;
    658                  first_byte_mark = 0xC0; /* 11000000 */
    659              }
    660              else if (codepoint < 0x10000)
    661              {
    662                  /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
    663                  utf8_length = 3;
    664                  first_byte_mark = 0xE0; /* 11100000 */
    665              }
    666              else if (codepoint <= 0x10FFFF)
    667              {
    668                  /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
    669                  utf8_length = 4;
    670                  first_byte_mark = 0xF0; /* 11110000 */
    671              }
    672              else
    673              {
    674                  /* invalid unicode codepoint */
    675                  goto fail;
    676              }
    677          
    678              /* encode as utf8 */
    679              for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
    680              {
    681                  /* 10xxxxxx */
    682                  (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
    683                  codepoint >>= 6;
    684              }
    685              /* encode first byte */
    686              if (utf8_length > 1)
    687              {
    688                  (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
    689              }
    690              else
    691              {
    692                  (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
    693              }
    694          
    695              *output_pointer += utf8_length;
    696          
    697              return sequence_length;
    698          
    699          fail:
    700              return 0;
   \                     ??utf16_literal_to_utf8_0:
   \   0000003C   ........           B        ?Subroutine112
   \                     ??utf16_literal_to_utf8_1:
   \   00000040   D80C56E3           CMP      R6,#+55296
   \   00000044   1600003A           BCC      ??utf16_literal_to_utf8_2
   \   00000048   060087E2           ADD      R0,R7,#+6
   \   0000004C   0C70A0E3           MOV      R7,#+12
   \   00000050   001048E0           SUB      R1,R8,R0
   \   00000054   060051E3           CMP      R1,#+6
   \   00000058   F7FFFFBA           BLT      ??utf16_literal_to_utf8_0
   \   0000005C   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000060   5C0051E3           CMP      R1,#+92
   \   00000064   0110D005           LDRBEQ   R1,[R0, #+1]
   \   00000068   75005103           CMPEQ    R1,#+117
   \   0000006C   F2FFFF1A           BNE      ??utf16_literal_to_utf8_0
   \   00000070   020080E2           ADD      R0,R0,#+2
   \   00000074   ........           BL       parse_hex4
   \   00000078   DC0C50E3           CMP      R0,#+56320
   \   0000007C   EEFFFF3A           BCC      ??utf16_literal_to_utf8_0
   \   00000080   E00C50E3           CMP      R0,#+57344
   \   00000084   ECFFFF2A           BCS      ??utf16_literal_to_utf8_0
   \   00000088   FF10A0E3           MOV      R1,#+255
   \   0000008C   C01F81E3           ORR      R1,R1,#0x300
   \   00000090   062001E0           AND      R2,R1,R6
   \   00000094   000001E0           AND      R0,R1,R0
   \   00000098   020580E1           ORR      R0,R0,R2, LSL #+10
   \   0000009C   406B80E2           ADD      R6,R0,#+65536
   \   000000A0   000000EA           B        ??utf16_literal_to_utf8_3
   \                     ??utf16_literal_to_utf8_2:
   \   000000A4   0670A0E3           MOV      R7,#+6
   \                     ??utf16_literal_to_utf8_3:
   \   000000A8   800056E3           CMP      R6,#+128
   \   000000AC   0100A033           MOVCC    R0,#+1
   \   000000B0   0B00003A           BCC      ??utf16_literal_to_utf8_4
   \   000000B4   800E56E3           CMP      R6,#+2048
   \   000000B8   0200A033           MOVCC    R0,#+2
   \   000000BC   C050A033           MOVCC    R5,#+192
   \   000000C0   0700003A           BCC      ??utf16_literal_to_utf8_4
   \   000000C4   400B56E3           CMP      R6,#+65536
   \   000000C8   0300A033           MOVCC    R0,#+3
   \   000000CC   E050A033           MOVCC    R5,#+224
   \   000000D0   0300003A           BCC      ??utf16_literal_to_utf8_4
   \   000000D4   440956E3           CMP      R6,#+1114112
   \   000000D8   D7FFFF2A           BCS      ??utf16_literal_to_utf8_0
   \   000000DC   0400A0E3           MOV      R0,#+4
   \   000000E0   F050A0E3           MOV      R5,#+240
   \                     ??utf16_literal_to_utf8_4:
   \   000000E4   011040E2           SUB      R1,R0,#+1
   \   000000E8   040000EA           B        ??utf16_literal_to_utf8_5
   \                     ??utf16_literal_to_utf8_6:
   \   000000EC   BF8006E2           AND      R8,R6,#0xBF
   \   000000F0   808088E3           ORR      R8,R8,#0x80
   \   000000F4   0280C1E7           STRB     R8,[R1, +R2]
   \   000000F8   2663A0E1           LSR      R6,R6,#+6
   \   000000FC   011041E2           SUB      R1,R1,#+1
   \                     ??utf16_literal_to_utf8_5:
   \   00000100   002094E5           LDR      R2,[R4, #+0]
   \   00000104   FF1001E2           AND      R1,R1,#0xFF
   \   00000108   0130B0E1           MOVS     R3,R1
   \   0000010C   F6FFFF1A           BNE      ??utf16_literal_to_utf8_6
   \   00000110   020050E3           CMP      R0,#+2
   \   00000114   06108521           ORRCS    R1,R5,R6
   \   00000118   7F100632           ANDCC    R1,R6,#0x7F
   \   0000011C   0010C2E5           STRB     R1,[R2, #+0]
   \   00000120   001094E5           LDR      R1,[R4, #+0]
   \   00000124   010080E0           ADD      R0,R0,R1
   \   00000128   000084E5           STR      R0,[R4, #+0]
   \   0000012C   0700A0E1           MOV      R0,R7
   \   00000130   F081BDE8           POP      {R4-R8,PC}
    701          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine112:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   F081BDE8           POP      {R4-R8,PC}       ;; return
    702          
    703          /* Parse the input text into an unescaped cinput, and populate item. */

   \                                 In segment CODE, align 4, keep-with-next
    704          static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
    705          {
   \                     parse_string:
   \   00000000   F3452DE9           PUSH     {R0,R1,R4-R8,R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   000095E5           LDR      R0,[R5, #+0]
   \   00000010   081095E5           LDR      R1,[R5, #+8]
    706              const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
    707              const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
    708              unsigned char *output_pointer = NULL;
   \   00000014   0080A0E3           MOV      R8,#+0
   \   00000018   001081E0           ADD      R1,R1,R0
   \   0000001C   00808DE5           STR      R8,[SP, #+0]
    709              unsigned char *output = NULL;
    710          
    711              /* not a string */
    712              if (buffer_at_offset(input_buffer)[0] != '\"')
   \   00000020   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000024   016081E2           ADD      R6,R1,#+1
   \   00000028   017081E2           ADD      R7,R1,#+1
   \   0000002C   220052E3           CMP      R2,#+34
   \   00000030   6A00001A           BNE      ??parse_string_0
    713              {
    714                  goto fail;
    715              }
    716          
    717              {
    718                  /* calculate approximate size of the output (overestimate) */
    719                  size_t allocation_length = 0;
    720                  size_t skipped_bytes = 0;
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   080000EA           B        ??parse_string_1
    721                  while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
    722                  {
    723                      /* is escape sequence */
    724                      if (input_end[0] == '\\')
   \                     ??parse_string_2:
   \   0000003C   5C0053E3           CMP      R3,#+92
   \   00000040   0500001A           BNE      ??parse_string_3
    725                      {
    726                          if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
   \   00000044   013087E2           ADD      R3,R7,#+1
   \   00000048   003043E0           SUB      R3,R3,R0
   \   0000004C   0A0053E1           CMP      R3,R10
   \   00000050   6200002A           BCS      ??parse_string_0
    727                          {
    728                              /* prevent buffer overflow when last input character is a backslash */
    729                              goto fail;
    730                          }
    731                          skipped_bytes++;
   \   00000054   012082E2           ADD      R2,R2,#+1
    732                          input_end++;
   \   00000058   017087E2           ADD      R7,R7,#+1
    733                      }
    734                      input_end++;
   \                     ??parse_string_3:
   \   0000005C   017087E2           ADD      R7,R7,#+1
    735                  }
   \                     ??parse_string_1:
   \   00000060   04A095E5           LDR      R10,[R5, #+4]
   \   00000064   003047E0           SUB      R3,R7,R0
   \   00000068   0A0053E1           CMP      R3,R10
   \   0000006C   5B00002A           BCS      ??parse_string_0
   \   00000070   0030D7E5           LDRB     R3,[R7, #+0]
   \   00000074   220053E3           CMP      R3,#+34
   \   00000078   EFFFFF1A           BNE      ??parse_string_2
   \   0000007C   5700001A           BNE      ??parse_string_0
    736                  if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
    737                  {
    738                      goto fail; /* string ended unexpectedly */
    739                  }
    740          
    741                  /* This is at most how much we need for the output */
    742                  allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
    743                  output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
   \   00000080   010047E0           SUB      R0,R7,R1
   \   00000084   101095E5           LDR      R1,[R5, #+16]
   \   00000088   020040E0           SUB      R0,R0,R2
   \   0000008C   010080E2           ADD      R0,R0,#+1
   \   00000090   31FF2FE1           BLX      R1
   \   00000094   00A0B0E1           MOVS     R10,R0
    744                  if (output == NULL)
   \   00000098   4B00000A           BEQ      ??parse_string_4
    745                  {
    746                      goto fail; /* allocation failure */
    747                  }
    748              }
    749          
    750              output_pointer = output;
   \   0000009C   00A08DE5           STR      R10,[SP, #+0]
   \   000000A0   050000EA           B        ??parse_string_5
    751              /* loop through the string literal */
    752              while (input_pointer < input_end)
    753              {
    754                  if (*input_pointer != '\\')
    755                  {
    756                      *output_pointer++ = *input_pointer++;
   \                     ??parse_string_6:
   \   000000A4   ........           LDRB     R1,[R6], #+1
   \   000000A8   00009DE5           LDR      R0,[SP, #+0]
   \   000000AC   0010C0E5           STRB     R1,[R0, #+0]
   \   000000B0   00109DE5           LDR      R1,[SP, #+0]
   \   000000B4   011081E2           ADD      R1,R1,#+1
   \   000000B8   00108DE5           STR      R1,[SP, #+0]
    757                  }
   \                     ??parse_string_5:
   \   000000BC   070056E1           CMP      R6,R7
   \   000000C0   3600002A           BCS      ??parse_string_7
   \   000000C4   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000C8   5C0050E3           CMP      R0,#+92
   \   000000CC   F4FFFF1A           BNE      ??parse_string_6
    758                  /* escape sequence */
    759                  else
    760                  {
    761                      unsigned char sequence_length = 2;
   \   000000D0   0200A0E3           MOV      R0,#+2
    762                      if ((input_end - input_pointer) < 1)
   \   000000D4   061047E0           SUB      R1,R7,R6
   \   000000D8   010051E3           CMP      R1,#+1
   \   000000DC   3C0000BA           BLT      ??parse_string_8
    763                      {
    764                          goto fail;
    765                      }
    766          
    767                      switch (input_pointer[1])
   \   000000E0   0110D6E5           LDRB     R1,[R6, #+1]
   \   000000E4   221051E2           SUBS     R1,R1,#+34
   \   000000E8   0D105112           SUBSNE   R1,R1,#+13
   \   000000EC   2D105112           SUBSNE   R1,R1,#+45
   \   000000F0   1F00000A           BEQ      ??parse_string_9
   \   000000F4   061051E2           SUBS     R1,R1,#+6
   \   000000F8   0A00000A           BEQ      ??parse_string_10
   \   000000FC   041051E2           SUBS     R1,R1,#+4
   \   00000100   0F00000A           BEQ      ??parse_string_11
   \   00000104   081051E2           SUBS     R1,R1,#+8
   \   00000108   1000000A           BEQ      ??parse_string_12
   \   0000010C   041051E2           SUBS     R1,R1,#+4
   \   00000110   1100000A           BEQ      ??parse_string_13
   \   00000114   021051E2           SUBS     R1,R1,#+2
   \   00000118   1200000A           BEQ      ??parse_string_14
   \   0000011C   011051E2           SUBS     R1,R1,#+1
   \   00000120   1600000A           BEQ      ??parse_string_15
   \   00000124   280000EA           B        ??parse_string_4
    768                      {
    769                          case 'b':
    770                              *output_pointer++ = '\b';
   \                     ??parse_string_10:
   \   00000128   00109DE5           LDR      R1,[SP, #+0]
   \   0000012C   0820A0E3           MOV      R2,#+8
   \                     ??parse_string_16:
   \   00000130   0020C1E5           STRB     R2,[R1, #+0]
   \   00000134   00209DE5           LDR      R2,[SP, #+0]
   \   00000138   012082E2           ADD      R2,R2,#+1
   \   0000013C   00208DE5           STR      R2,[SP, #+0]
   \   00000140   140000EA           B        ??parse_string_17
    771                              break;
    772                          case 'f':
    773                              *output_pointer++ = '\f';
   \                     ??parse_string_11:
   \   00000144   00109DE5           LDR      R1,[SP, #+0]
   \   00000148   0C20A0E3           MOV      R2,#+12
   \   0000014C   F7FFFFEA           B        ??parse_string_16
    774                              break;
    775                          case 'n':
    776                              *output_pointer++ = '\n';
   \                     ??parse_string_12:
   \   00000150   00109DE5           LDR      R1,[SP, #+0]
   \   00000154   0A20A0E3           MOV      R2,#+10
   \                     ??parse_string_18:
   \   00000158   F4FFFFEA           B        ??parse_string_16
    777                              break;
    778                          case 'r':
    779                              *output_pointer++ = '\r';
   \                     ??parse_string_13:
   \   0000015C   00109DE5           LDR      R1,[SP, #+0]
   \   00000160   0D20A0E3           MOV      R2,#+13
   \   00000164   F1FFFFEA           B        ??parse_string_16
    780                              break;
    781                          case 't':
    782                              *output_pointer++ = '\t';
   \                     ??parse_string_14:
   \   00000168   00109DE5           LDR      R1,[SP, #+0]
   \   0000016C   0920A0E3           MOV      R2,#+9
   \   00000170   EEFFFFEA           B        ??parse_string_16
    783                              break;
    784                          case '\"':
    785                          case '\\':
    786                          case '/':
    787                              *output_pointer++ = input_pointer[1];
   \                     ??parse_string_9:
   \   00000174   00109DE5           LDR      R1,[SP, #+0]
   \   00000178   0120D6E5           LDRB     R2,[R6, #+1]
   \   0000017C   EBFFFFEA           B        ??parse_string_16
    788                              break;
    789          
    790                          /* UTF-16 literal */
    791                          case 'u':
    792                              sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
   \                     ??parse_string_15:
   \   00000180   0D20A0E1           MOV      R2,SP
   \   00000184   0710A0E1           MOV      R1,R7
   \   00000188   0600A0E1           MOV      R0,R6
   \   0000018C   ........           BL       utf16_literal_to_utf8
    793                              if (sequence_length == 0)
   \   00000190   0010B0E1           MOVS     R1,R0
   \   00000194   0E00000A           BEQ      ??parse_string_8
    794                              {
    795                                  /* failed to convert UTF16-literal to UTF-8 */
    796                                  goto fail;
    797                              }
    798                              break;
    799          
    800                          default:
    801                              goto fail;
    802                      }
    803                      input_pointer += sequence_length;
   \                     ??parse_string_17:
   \   00000198   066080E0           ADD      R6,R0,R6
   \   0000019C   C6FFFFEA           B        ??parse_string_5
    804                  }
    805              }
    806          
    807              /* zero terminate the output */
    808              *output_pointer = '\0';
   \                     ??parse_string_7:
   \   000001A0   00009DE5           LDR      R0,[SP, #+0]
   \   000001A4   0080C0E5           STRB     R8,[R0, #+0]
    809          
    810              item->type = cJSON_String;
   \   000001A8   1000A0E3           MOV      R0,#+16
   \   000001AC   0C0084E5           STR      R0,[R4, #+12]
    811              item->valuestring = (char*)output;
   \   000001B0   10A084E5           STR      R10,[R4, #+16]
    812          
    813              input_buffer->offset = (size_t) (input_end - input_buffer->content);
    814              input_buffer->offset++;
   \   000001B4   000095E5           LDR      R0,[R5, #+0]
   \   000001B8   000047E0           SUB      R0,R7,R0
   \   000001BC   010080E2           ADD      R0,R0,#+1
   \   000001C0   080085E5           STR      R0,[R5, #+8]
    815          
    816              return true;
   \   000001C4   0100A0E3           MOV      R0,#+1
   \   000001C8   F685BDE8           POP      {R1,R2,R4-R8,R10,PC}
    817          
    818          fail:
    819              if (output != NULL)
   \                     ??parse_string_4:
   \   000001CC   00005AE3           CMP      R10,#+0
   \   000001D0   0200000A           BEQ      ??parse_string_0
    820              {
    821                  input_buffer->hooks.deallocate(output);
   \                     ??parse_string_8:
   \   000001D4   141095E5           LDR      R1,[R5, #+20]
   \   000001D8   0A00A0E1           MOV      R0,R10
   \   000001DC   31FF2FE1           BLX      R1
    822              }
    823          
    824              if (input_pointer != NULL)
   \                     ??parse_string_0:
   \   000001E0   000056E3           CMP      R6,#+0
    825              {
    826                  input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
   \   000001E4   00009515           LDRNE    R0,[R5, #+0]
   \   000001E8   00004610           SUBNE    R0,R6,R0
   \   000001EC   08008515           STRNE    R0,[R5, #+8]
    827              }
    828          
    829              return false;
   \   000001F0   0000A0E3           MOV      R0,#+0
   \   000001F4   F685BDE8           POP      {R1,R2,R4-R8,R10,PC}
    830          }
    831          
    832          /* Render the cstring provided to an escaped version that can be printed. */

   \                                 In segment CODE, align 4, keep-with-next
    833          static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
    834          {
   \                     print_string_ptr:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0100A0E1           MOV      R0,R1
    835              const unsigned char *input_pointer = NULL;
    836              unsigned char *output = NULL;
    837              unsigned char *output_pointer = NULL;
    838              size_t output_length = 0;
    839              /* numbers of additional characters needed for escaping */
    840              size_t escape_characters = 0;
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   00A0A0E3           MOV      R10,#+0
    841          
    842              if (output_buffer == NULL)
   \   00000014   000050E3           CMP      R0,#+0
    843              {
    844                  return false;
   \   00000018   F087BD08           POPEQ    {R4-R10,PC}
    845              }
    846          
    847              /* empty string */
    848              if (input == NULL)
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   0600001A           BNE      ??print_string_ptr_0
    849              {
    850                  output = ensure(output_buffer, sizeof("\"\""));
   \   00000024   0310A0E3           MOV      R1,#+3
   \   00000028   ........           BL       ensure
   \   0000002C   0080B0E1           MOVS     R8,R0
    851                  if (output == NULL)
   \   00000030   1A00000A           BEQ      ??print_string_ptr_1
    852                  {
    853                      return false;
    854                  }
    855                  strcpy((char*)output, "\"\"");
   \   00000034   591F8FE2           ADR      R1,??print_string_ptr_2  ;; "\"\""
   \   00000038   1A0000EF           SWI      +26
    856          
    857                  return true;
   \   0000003C   240000EA           B        ??print_string_ptr_3
    858              }
    859          
    860              /* set "flag" to 1 if something needs to be escaped */
    861              for (input_pointer = input; *input_pointer; input_pointer++)
   \                     ??print_string_ptr_0:
   \   00000040   0460A0E1           MOV      R6,R4
   \   00000044   020000EA           B        ??print_string_ptr_4
    862              {
    863                  switch (*input_pointer)
    864                  {
    865                      case '\"':
    866                      case '\\':
    867                      case '\b':
    868                      case '\f':
    869                      case '\n':
    870                      case '\r':
    871                      case '\t':
    872                          /* one character escape sequence */
    873                          escape_characters++;
    874                          break;
    875                      default:
    876                          if (*input_pointer < 32)
   \                     ??print_string_ptr_5:
   \   00000048   200051E3           CMP      R1,#+32
    877                          {
    878                              /* UTF-16 escape sequence uXXXX */
    879                              escape_characters += 5;
   \   0000004C   05A08A32           ADDCC    R10,R10,#+5
    880                          }
   \                     ??print_string_ptr_6:
   \   00000050   016086E2           ADD      R6,R6,#+1
   \                     ??print_string_ptr_4:
   \   00000054   0010D6E5           LDRB     R1,[R6, #+0]
   \   00000058   000051E3           CMP      R1,#+0
   \   0000005C   0900000A           BEQ      ??print_string_ptr_7
   \   00000060   082041E2           SUB      R2,R1,#+8
   \   00000064   020052E3           CMP      R2,#+2
   \   00000068   04204282           SUBHI    R2,R2,#+4
   \   0000006C   01005283           CMPHI    R2,#+1
   \   00000070   0200009A           BLS      ??print_string_ptr_8
   \   00000074   162052E2           SUBS     R2,R2,#+22
   \   00000078   3A205212           SUBSNE   R2,R2,#+58
   \   0000007C   F1FFFF1A           BNE      ??print_string_ptr_5
   \                     ??print_string_ptr_8:
   \   00000080   01A08AE2           ADD      R10,R10,#+1
   \   00000084   F1FFFFEA           B        ??print_string_ptr_6
    881                          break;
    882                  }
    883              }
    884              output_length = (size_t)(input_pointer - input) + escape_characters;
   \                     ??print_string_ptr_7:
   \   00000088   041046E0           SUB      R1,R6,R4
   \   0000008C   01908AE0           ADD      R9,R10,R1
    885          
    886              output = ensure(output_buffer, output_length + sizeof("\"\""));
   \   00000090   031089E2           ADD      R1,R9,#+3
   \   00000094   ........           BL       ensure
   \   00000098   0080B0E1           MOVS     R8,R0
    887              if (output == NULL)
   \   0000009C   0100001A           BNE      ??print_string_ptr_9
    888              {
    889                  return false;
   \                     ??print_string_ptr_1:
   \   000000A0   0000A0E3           MOV      R0,#+0
   \   000000A4   F087BDE8           POP      {R4-R10,PC}
    890              }
    891          
    892              /* no characters have to be escaped */
    893              if (escape_characters == 0)
   \                     ??print_string_ptr_9:
   \   000000A8   2270A0E3           MOV      R7,#+34
   \   000000AC   00005AE3           CMP      R10,#+0
   \   000000B0   0070C8E5           STRB     R7,[R8, #+0]
   \   000000B4   0700001A           BNE      ??print_string_ptr_10
    894              {
    895                  output[0] = '\"';
    896                  memcpy(output + 1, input, output_length);
   \   000000B8   0920A0E1           MOV      R2,R9
   \   000000BC   0410A0E1           MOV      R1,R4
   \   000000C0   010088E2           ADD      R0,R8,#+1
   \   000000C4   1E0100EF           SWI      +286
    897                  output[output_length + 1] = '\"';
    898                  output[output_length + 2] = '\0';
    899          
    900                  return true;
    901              }
    902          
    903              output[0] = '\"';
    904              output_pointer = output + 1;
    905              /* copy the string */
    906              for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
    907              {
    908                  if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
    909                  {
    910                      /* normal character, copy */
    911                      *output_pointer = *input_pointer;
    912                  }
    913                  else
    914                  {
    915                      /* character needs to be escaped */
    916                      *output_pointer++ = '\\';
    917                      switch (*input_pointer)
    918                      {
    919                          case '\\':
    920                              *output_pointer = '\\';
    921                              break;
    922                          case '\"':
    923                              *output_pointer = '\"';
    924                              break;
    925                          case '\b':
    926                              *output_pointer = 'b';
    927                              break;
    928                          case '\f':
    929                              *output_pointer = 'f';
    930                              break;
    931                          case '\n':
    932                              *output_pointer = 'n';
    933                              break;
    934                          case '\r':
    935                              *output_pointer = 'r';
    936                              break;
    937                          case '\t':
    938                              *output_pointer = 't';
    939                              break;
    940                          default:
    941                              /* escape and print as unicode codepoint */
    942                              sprintf((char*)output_pointer, "u%04x", *input_pointer);
    943                              output_pointer += 4;
    944                              break;
    945                      }
    946                  }
    947              }
    948              output[output_length + 1] = '\"';
   \                     ??print_string_ptr_11:
   \   000000C8   080089E0           ADD      R0,R9,R8
   \   000000CC   0170C0E5           STRB     R7,[R0, #+1]
    949              output[output_length + 2] = '\0';
   \   000000D0   0250C0E5           STRB     R5,[R0, #+2]
    950          
    951              return true;
   \                     ??print_string_ptr_3:
   \   000000D4   ........           B        ?Subroutine115
   \                     ??print_string_ptr_10:
   \   000000D8   01A088E2           ADD      R10,R8,#+1
   \   000000DC   0460A0E1           MOV      R6,R4
   \   000000E0   050000EA           B        ??print_string_ptr_12
   \                     ??print_string_ptr_13:
   \   000000E4   B8109FE5           LDR      R1,??print_string_ptr_2+0x4  ;; `?<Constant "u%04x">`
   \   000000E8   0A00A0E1           MOV      R0,R10
   \   000000EC   160000EF           SWI      +22
   \   000000F0   04A08AE2           ADD      R10,R10,#+4
   \                     ??print_string_ptr_14:
   \   000000F4   016086E2           ADD      R6,R6,#+1
   \   000000F8   01A08AE2           ADD      R10,R10,#+1
   \                     ??print_string_ptr_12:
   \   000000FC   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000100   000050E3           CMP      R0,#+0
   \   00000104   EFFFFF0A           BEQ      ??print_string_ptr_11
   \   00000108   200050E3           CMP      R0,#+32
   \   0000010C   0500003A           BCC      ??print_string_ptr_15
   \   00000110   220050E3           CMP      R0,#+34
   \   00000114   0300000A           BEQ      ??print_string_ptr_15
   \   00000118   5C0050E3           CMP      R0,#+92
   \   0000011C   0200000A           BEQ      ??print_string_ptr_16
   \                     ??print_string_ptr_17:
   \   00000120   0000CAE5           STRB     R0,[R10, #+0]
   \   00000124   F2FFFFEA           B        ??print_string_ptr_14
   \                     ??print_string_ptr_15:
   \   00000128   5C00A0E3           MOV      R0,#+92
   \                     ??print_string_ptr_16:
   \   0000012C   ........           STRB     R0,[R10], #+1
   \   00000130   0020D6E5           LDRB     R2,[R6, #+0]
   \   00000134   081052E2           SUBS     R1,R2,#+8
   \   00000138   0E00000A           BEQ      ??print_string_ptr_18
   \   0000013C   011051E2           SUBS     R1,R1,#+1
   \   00000140   1400000A           BEQ      ??print_string_ptr_19
   \   00000144   011051E2           SUBS     R1,R1,#+1
   \   00000148   0E00000A           BEQ      ??print_string_ptr_20
   \   0000014C   021051E2           SUBS     R1,R1,#+2
   \   00000150   0A00000A           BEQ      ??print_string_ptr_21
   \   00000154   011051E2           SUBS     R1,R1,#+1
   \   00000158   0C00000A           BEQ      ??print_string_ptr_22
   \   0000015C   151051E2           SUBS     R1,R1,#+21
   \   00000160   0200000A           BEQ      ??print_string_ptr_23
   \   00000164   3A1051E2           SUBS     R1,R1,#+58
   \   00000168   DDFFFF1A           BNE      ??print_string_ptr_13
   \   0000016C   EBFFFFEA           B        ??print_string_ptr_17
   \                     ??print_string_ptr_23:
   \   00000170   0070CAE5           STRB     R7,[R10, #+0]
   \   00000174   DEFFFFEA           B        ??print_string_ptr_14
   \                     ??print_string_ptr_18:
   \   00000178   6200A0E3           MOV      R0,#+98
   \   0000017C   E7FFFFEA           B        ??print_string_ptr_17
   \                     ??print_string_ptr_21:
   \   00000180   6600A0E3           MOV      R0,#+102
   \   00000184   E5FFFFEA           B        ??print_string_ptr_17
   \                     ??print_string_ptr_20:
   \   00000188   6E00A0E3           MOV      R0,#+110
   \   0000018C   E3FFFFEA           B        ??print_string_ptr_17
   \                     ??print_string_ptr_22:
   \   00000190   7200A0E3           MOV      R0,#+114
   \   00000194   E1FFFFEA           B        ??print_string_ptr_17
   \                     ??print_string_ptr_19:
   \   00000198   7400A0E3           MOV      R0,#+116
   \   0000019C   DFFFFFEA           B        ??print_string_ptr_17
   \                     ??print_string_ptr_2:
   \   000001A0   22220000           DC8      "\"\"",+0
   \   000001A4   ........           DC32     `?<Constant "u%04x">`
    952          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine115:
   \   00000000   0100A0E3           MOV      R0,#+1
   \   00000004   F087BDE8           POP      {R4-R10,PC}      ;; return
    953          
    954          /* Invoke print_string_ptr (which is useful) on an item. */
    955          static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
    956          {
    957              return print_string_ptr((unsigned char*)item->valuestring, p);
    958          }
    959          
    960          /* Predeclare these prototypes. */
    961          static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
    962          static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
    963          static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
    964          static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
    965          static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
    966          static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
    967          
    968          /* Utility to jump whitespace and cr/lf */

   \                                 In segment CODE, align 4, keep-with-next
    969          static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
    970          {
    971              if ((buffer == NULL) || (buffer->content == NULL))
   \                     buffer_skip_whitespace:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1EFF2F01           BXEQ     LR
   \   00000008   001090E5           LDR      R1,[R0, #+0]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0500001A           BNE      ??buffer_skip_whitespace_0
    972              {
    973                  return NULL;
   \   00000014   ........           B        ??Subroutine102_1
    974              }
   \                     ??buffer_skip_whitespace_1:
   \   00000018   0130D2E7           LDRB     R3,[R2, +R1]
   \   0000001C   210053E3           CMP      R3,#+33
   \   00000020   1EFF2F21           BXCS     LR
    975          
    976              while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
    977              {
    978                 buffer->offset++;
   \   00000024   012082E2           ADD      R2,R2,#+1
   \   00000028   082080E5           STR      R2,[R0, #+8]
   \                     ??buffer_skip_whitespace_0:
   \   0000002C   043090E5           LDR      R3,[R0, #+4]
   \   00000030   082090E5           LDR      R2,[R0, #+8]
   \   00000034   030052E1           CMP      R2,R3
   \   00000038   F6FFFF3A           BCC      ??buffer_skip_whitespace_1
    979              }
    980          
    981              if (buffer->offset == buffer->length)
    982              {
    983                  buffer->offset--;
   \   0000003C   01104202           SUBEQ    R1,R2,#+1
   \   00000040   08108005           STREQ    R1,[R0, #+8]
    984              }
    985          
    986              return buffer;
   \   00000044   1EFF2FE1           BX       LR               ;; return
    987          }
    988          
    989          /* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
    990          static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
    991          {
    992              if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
    993              {
    994                  return NULL;
    995              }
    996          
    997              if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
    998              {
    999                  buffer->offset += 3;
   1000              }
   1001          
   1002              return buffer;
   1003          }
   1004          
   1005          /* Parse an object - create a new root, and populate. */

   \                                 In segment CODE, align 4, keep-with-next
   1006          CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
   1007          {
   \                     cJSON_ParseWithOpts:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0280A0E1           MOV      R8,R2
   1008              parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0130A0E1           MOV      R3,R1
   \   00000024   0160A0E1           MOV      R6,R1
   \   00000028   4E00A0E8           STM      R0!,{R1-R3,R6}
   1009              cJSON *item = NULL;
   1010          
   1011              /* reset error position */
   1012              global_error.json = NULL;
   \   0000002C   ........           LDR      R6,??DataTable8  ;; global_hooks
   \   00000030   0E0080E8           STM      R0,{R1-R3}
   \   00000034   0170A0E1           MOV      R7,R1
   \   00000038   0C7086E5           STR      R7,[R6, #+12]
   1013              global_error.position = 0;
   \   0000003C   107086E5           STR      R7,[R6, #+16]
   1014          
   1015              if (value == NULL)
   \   00000040   000054E3           CMP      R4,#+0
   \   00000044   4700000A           BEQ      ??cJSON_ParseWithOpts_0
   1016              {
   1017                  goto fail;
   1018              }
   1019          
   1020              buffer.content = (const unsigned char*)value;
   \   00000048   00408DE5           STR      R4,[SP, #+0]
   1021              buffer.length = strlen((const char*)value) + sizeof("");
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   1B0000EF           SWI      +27
   \   00000054   010080E2           ADD      R0,R0,#+1
   \   00000058   04008DE5           STR      R0,[SP, #+4]
   1022              buffer.offset = 0;
   \   0000005C   08708DE5           STR      R7,[SP, #+8]
   1023              buffer.hooks = global_hooks;
   \   00000060   0C0296E8           LDM      R6,{R2,R3,R9}
   \   00000064   10008DE2           ADD      R0,SP,#+16
   \   00000068   0C0280E8           STM      R0,{R2,R3,R9}
   1024          
   1025              item = cJSON_New_Item(&global_hooks);
   \   0000006C   0600A0E1           MOV      R0,R6
   \   00000070   ........           BL       cJSON_New_Item
   \   00000074   0090B0E1           MOVS     R9,R0
   1026              if (item == NULL) /* memory fail */
   \   00000078   2E00000A           BEQ      ??cJSON_ParseWithOpts_1
   1027              {
   1028                  goto fail;
   1029              }
   1030          
   1031              if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
   \   0000007C   00009DE5           LDR      R0,[SP, #+0]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0200000A           BEQ      ??cJSON_ParseWithOpts_2
   \   00000088   08009DE5           LDR      R0,[SP, #+8]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0100000A           BEQ      ??cJSON_ParseWithOpts_3
   \                     ??cJSON_ParseWithOpts_2:
   \   00000094   0000A0E3           MOV      R0,#+0
   \   00000098   0B0000EA           B        ??cJSON_ParseWithOpts_4
   \                     ??cJSON_ParseWithOpts_3:
   \   0000009C   04009DE5           LDR      R0,[SP, #+4]
   \   000000A0   050050E3           CMP      R0,#+5
   \   000000A4   0700003A           BCC      ??cJSON_ParseWithOpts_5
   \   000000A8   00009DE5           LDR      R0,[SP, #+0]
   \   000000AC   0320A0E3           MOV      R2,#+3
   \   000000B0   2F1F8FE2           ADR      R1,??cJSON_ParseWithOpts_6  ;; ""
   \   000000B4   150100EF           SWI      +277
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   08109D05           LDREQ    R1,[SP, #+8]
   \   000000C0   03108102           ADDEQ    R1,R1,#+3
   \   000000C4   08108D05           STREQ    R1,[SP, #+8]
   \                     ??cJSON_ParseWithOpts_5:
   \   000000C8   0D00A0E1           MOV      R0,SP
   \                     ??cJSON_ParseWithOpts_4:
   \   000000CC   ........           BL       buffer_skip_whitespace
   \   000000D0   0010A0E1           MOV      R1,R0
   \   000000D4   0900A0E1           MOV      R0,R9
   \   000000D8   ........           BL       parse_value
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   1200000A           BEQ      ??cJSON_ParseWithOpts_7
   1032              {
   1033                  /* parse failure. ep is set. */
   1034                  goto fail;
   1035              }
   1036          
   1037              /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
   1038              if (require_null_terminated)
   \   000000E4   000058E3           CMP      R8,#+0
   \   000000E8   0900000A           BEQ      ??cJSON_ParseWithOpts_8
   1039              {
   1040                  buffer_skip_whitespace(&buffer);
   \   000000EC   0D00A0E1           MOV      R0,SP
   \   000000F0   ........           BL       buffer_skip_whitespace
   1041                  if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
   \   000000F4   08009DE5           LDR      R0,[SP, #+8]
   \   000000F8   04109DE5           LDR      R1,[SP, #+4]
   \   000000FC   010050E1           CMP      R0,R1
   \   00000100   0A00002A           BCS      ??cJSON_ParseWithOpts_7
   \   00000104   00109DE5           LDR      R1,[SP, #+0]
   \   00000108   0100D0E7           LDRB     R0,[R0, +R1]
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0600001A           BNE      ??cJSON_ParseWithOpts_7
   1042                  {
   1043                      goto fail;
   1044                  }
   1045              }
   1046              if (return_parse_end)
   \                     ??cJSON_ParseWithOpts_8:
   \   00000114   000055E3           CMP      R5,#+0
   1047              {
   1048                  *return_parse_end = (const char*)buffer_at_offset(&buffer);
   \   00000118   08009D15           LDRNE    R0,[SP, #+8]
   \   0000011C   00109D15           LDRNE    R1,[SP, #+0]
   \   00000120   01008010           ADDNE    R0,R0,R1
   \   00000124   00008515           STRNE    R0,[R5, #+0]
   1049              }
   1050          
   1051              return item;
   \   00000128   0900A0E1           MOV      R0,R9
   \   0000012C   0E0000EA           B        ??cJSON_ParseWithOpts_9
   1052          
   1053          fail:
   1054              if (item != NULL)
   1055              {
   1056                  cJSON_Delete(item);
   \                     ??cJSON_ParseWithOpts_7:
   \   00000130   0900A0E1           MOV      R0,R9
   \   00000134   ........           BL       cJSON_Delete
   1057              }
   1058          
   1059              if (value != NULL)
   1060              {
   1061                  error local_error;
   1062                  local_error.json = (const unsigned char*)value;
   1063                  local_error.position = 0;
   1064          
   1065                  if (buffer.offset < buffer.length)
   \                     ??cJSON_ParseWithOpts_1:
   \   00000138   04009DE5           LDR      R0,[SP, #+4]
   \   0000013C   08109DE5           LDR      R1,[SP, #+8]
   \   00000140   000051E1           CMP      R1,R0
   1066                  {
   1067                      local_error.position = buffer.offset;
   \   00000144   0170A031           MOVCC    R7,R1
   \   00000148   0100003A           BCC      ??cJSON_ParseWithOpts_10
   1068                  }
   1069                  else if (buffer.length > 0)
   \   0000014C   000050E3           CMP      R0,#+0
   1070                  {
   1071                      local_error.position = buffer.length - 1;
   \   00000150   01704012           SUBNE    R7,R0,#+1
   1072                  }
   1073          
   1074                  if (return_parse_end != NULL)
   \                     ??cJSON_ParseWithOpts_10:
   \   00000154   000055E3           CMP      R5,#+0
   1075                  {
   1076                      *return_parse_end = (const char*)local_error.json + local_error.position;
   \   00000158   04008710           ADDNE    R0,R7,R4
   \   0000015C   00008515           STRNE    R0,[R5, #+0]
   1077                  }
   1078          
   1079                  global_error = local_error;
   \   00000160   0C4086E5           STR      R4,[R6, #+12]
   \   00000164   107086E5           STR      R7,[R6, #+16]
   1080              }
   1081          
   1082              return NULL;
   \                     ??cJSON_ParseWithOpts_0:
   \   00000168   0000A0E3           MOV      R0,#+0
   \                     ??cJSON_ParseWithOpts_9:
   \   0000016C   1CD08DE2           ADD      SP,SP,#+28       ;; stack cleaning
   \   00000170   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??cJSON_ParseWithOpts_6:
   \   00000174   EFBBBF00           DC8      ""
   1083          }
   1084          
   1085          /* Default options for cJSON_Parse */

   \                                 In segment CODE, align 4, keep-with-next
   1086          CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
   1087          {
   1088              return cJSON_ParseWithOpts(value, 0, 0);
   \                     cJSON_Parse:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   ........           B        cJSON_ParseWithOpts  ;; tailcall
   1089          }
   1090          
   1091          #define cjson_min(a, b) ((a < b) ? a : b)
   1092          

   \                                 In segment CODE, align 4, keep-with-next
   1093          static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
   1094          {
   \                     print:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0180A0E1           MOV      R8,R1
   \   00000010   0240A0E1           MOV      R4,R2
   1095              static const size_t default_buffer_size = 256;
   1096              printbuffer buffer[1];
   1097              unsigned char *printed = NULL;
   \   00000014   0050A0E3           MOV      R5,#+0
   1098          
   1099              memset(buffer, 0, sizeof(buffer));
   \   00000018   2420A0E3           MOV      R2,#+36
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   BB0000EF           SWI      +187
   1100          
   1101              /* create buffer */
   1102              buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
   \   00000028   001094E5           LDR      R1,[R4, #+0]
   \   0000002C   400FA0E3           MOV      R0,#+256
   \   00000030   31FF2FE1           BLX      R1
   \   00000034   00008DE5           STR      R0,[SP, #+0]
   1103              buffer->length = default_buffer_size;
   \   00000038   401FA0E3           MOV      R1,#+256
   \   0000003C   04108DE5           STR      R1,[SP, #+4]
   1104              buffer->format = format;
   \   00000040   14808DE5           STR      R8,[SP, #+20]
   1105              buffer->hooks = *hooks;
   \   00000044   0C0194E8           LDM      R4,{R2,R3,R8}
   \   00000048   18008DE2           ADD      R0,SP,#+24
   \   0000004C   0C0180E8           STM      R0,{R2,R3,R8}
   1106              if (buffer->buffer == NULL)
   \   00000050   00009DE5           LDR      R0,[SP, #+0]
   \   00000054   0060A0E3           MOV      R6,#+0
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0F00000A           BEQ      ??print_0
   1107              {
   1108                  goto fail;
   1109              }
   1110          
   1111              /* print the value */
   1112              if (!print_value(item, buffer))
   \   00000060   0D10A0E1           MOV      R1,SP
   \   00000064   0700A0E1           MOV      R0,R7
   \   00000068   ........           BL       print_value
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0A00000A           BEQ      ??print_0
   1113              {
   1114                  goto fail;
   1115              }
   1116              update_offset(buffer);
   \   00000074   0D00A0E1           MOV      R0,SP
   \   00000078   ........           BL       update_offset
   1117          
   1118              /* check if reallocate is available */
   1119              if (hooks->reallocate != NULL)
   \   0000007C   082094E5           LDR      R2,[R4, #+8]
   \   00000080   08009DE5           LDR      R0,[SP, #+8]
   \   00000084   000052E3           CMP      R2,#+0
   \   00000088   1000000A           BEQ      ??print_1
   1120              {
   1121                  printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
   \   0000008C   011080E2           ADD      R1,R0,#+1
   \   00000090   00009DE5           LDR      R0,[SP, #+0]
   \   00000094   32FF2FE1           BLX      R2
   \   00000098   0060B0E1           MOVS     R6,R0
   1122                  if (printed == NULL) {
   \   0000009C   1D00001A           BNE      ??print_2
   1123                      goto fail;
   1124                  }
   1125                  buffer->buffer = NULL;
   1126              }
   1127              else /* otherwise copy the JSON over to a new buffer */
   1128              {
   1129                  printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
   1130                  if (printed == NULL)
   1131                  {
   1132                      goto fail;
   1133                  }
   1134                  memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
   1135                  printed[buffer->offset] = '\0'; /* just to be sure */
   1136          
   1137                  /* free the buffer */
   1138                  hooks->deallocate(buffer->buffer);
   1139              }
   1140          
   1141              return printed;
   1142          
   1143          fail:
   1144              if (buffer->buffer != NULL)
   \                     ??print_0:
   \   000000A0   00009DE5           LDR      R0,[SP, #+0]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0100000A           BEQ      ??print_3
   1145              {
   1146                  hooks->deallocate(buffer->buffer);
   \   000000AC   041094E5           LDR      R1,[R4, #+4]
   \   000000B0   31FF2FE1           BLX      R1
   1147              }
   1148          
   1149              if (printed != NULL)
   \                     ??print_3:
   \   000000B4   000056E3           CMP      R6,#+0
   \   000000B8   0200000A           BEQ      ??print_4
   1150              {
   1151                  hooks->deallocate(printed);
   \   000000BC   041094E5           LDR      R1,[R4, #+4]
   \   000000C0   0600A0E1           MOV      R0,R6
   \   000000C4   31FF2FE1           BLX      R1
   1152              }
   1153          
   1154              return NULL;
   \                     ??print_4:
   \   000000C8   0000A0E3           MOV      R0,#+0
   \                     ??print_5:
   \   000000CC   ........           B        ?Subroutine111
   \                     ??print_1:
   \   000000D0   001094E5           LDR      R1,[R4, #+0]
   \   000000D4   010080E2           ADD      R0,R0,#+1
   \   000000D8   31FF2FE1           BLX      R1
   \   000000DC   0060B0E1           MOVS     R6,R0
   \   000000E0   EEFFFF0A           BEQ      ??print_0
   \   000000E4   08009DE5           LDR      R0,[SP, #+8]
   \   000000E8   00109DE5           LDR      R1,[SP, #+0]
   \   000000EC   012080E2           ADD      R2,R0,#+1
   \   000000F0   04009DE5           LDR      R0,[SP, #+4]
   \   000000F4   020050E1           CMP      R0,R2
   \   000000F8   0020A031           MOVCC    R2,R0
   \   000000FC   0600A0E1           MOV      R0,R6
   \   00000100   1E0100EF           SWI      +286
   \   00000104   08009DE5           LDR      R0,[SP, #+8]
   \   00000108   0650C0E7           STRB     R5,[R0, +R6]
   \   0000010C   00009DE5           LDR      R0,[SP, #+0]
   \   00000110   041094E5           LDR      R1,[R4, #+4]
   \   00000114   31FF2FE1           BLX      R1
   \                     ??print_2:
   \   00000118   0600A0E1           MOV      R0,R6
   \   0000011C   EAFFFFEA           B        ??print_5
   1155          }
   1156          
   1157          /* Render a cJSON item/entity/structure to text. */

   \                                 In segment CODE, align 4, keep-with-next
   1158          CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
   1159          {
   1160              return (char*)print(item, true, &global_hooks);
   \                     cJSON_Print:
   \   00000000   ........           LDR      R2,??DataTable8  ;; global_hooks
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   ........           B        print            ;; tailcall
   1161          }
   1162          

   \                                 In segment CODE, align 4, keep-with-next
   1163          CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
   1164          {
   1165              return (char*)print(item, false, &global_hooks);
   \                     cJSON_PrintUnformatted:
   \   00000000   ........           LDR      R2,??DataTable8  ;; global_hooks
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   ........           B        print            ;; tailcall
   1166          }
   1167          

   \                                 In segment CODE, align 4, keep-with-next
   1168          CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
   1169          {
   \                     cJSON_PrintBuffered:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0250A0E1           MOV      R5,R2
   1170              printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   2420A0E3           MOV      R2,#+36
   \                     ??cJSON_PrintBuffered_0:
   \   00000020   042052E2           SUBS     R2,R2,#+4
   \   00000024   021080E7           STR      R1,[R0, R2]
   \   00000028   FCFFFF1A           BNE      ??cJSON_PrintBuffered_0
   1171          
   1172              if (prebuffer < 0)
   \   0000002C   000056E3           CMP      R6,#+0
   1173              {
   1174                  return NULL;
   \   00000030   0000A043           MOVMI    R0,#+0
   \   00000034   1700004A           BMI      ??cJSON_PrintBuffered_1
   1175              }
   1176          
   1177              p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
   \   00000038   ........           LDR      R7,??DataTable8  ;; global_hooks
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   001097E5           LDR      R1,[R7, #+0]
   \   00000044   31FF2FE1           BLX      R1
   \   00000048   00008DE5           STR      R0,[SP, #+0]
   1178              if (!p.buffer)
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   1000000A           BEQ      ??cJSON_PrintBuffered_1
   1179              {
   1180                  return NULL;
   1181              }
   1182          
   1183              p.length = (size_t)prebuffer;
   \   00000054   04608DE5           STR      R6,[SP, #+4]
   1184              p.offset = 0;
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   08008DE5           STR      R0,[SP, #+8]
   1185              p.noalloc = false;
   \   00000060   10008DE5           STR      R0,[SP, #+16]
   1186              p.format = fmt;
   \   00000064   14508DE5           STR      R5,[SP, #+20]
   1187              p.hooks = global_hooks;
   \   00000068   2C0097E8           LDM      R7,{R2,R3,R5}
   \   0000006C   18008DE2           ADD      R0,SP,#+24
   \   00000070   2C0080E8           STM      R0,{R2,R3,R5}
   1188          
   1189              if (!print_value(item, &p))
   \   00000074   0D10A0E1           MOV      R1,SP
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   ........           BL       print_value
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   00009DE5           LDR      R0,[SP, #+0]
   \   00000088   0200001A           BNE      ??cJSON_PrintBuffered_1
   1190              {
   1191                  global_hooks.deallocate(p.buffer);
   \   0000008C   041097E5           LDR      R1,[R7, #+4]
   \   00000090   31FF2FE1           BLX      R1
   1192                  return NULL;
   \   00000094   0000A0E3           MOV      R0,#+0
   1193              }
   1194          
   1195              return (char*)p.buffer;
   \                     ??cJSON_PrintBuffered_1:
   \   00000098   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   0000009C   F080BDE8           POP      {R4-R7,PC}       ;; return
   1196          }
   1197          

   \                                 In segment CODE, align 4, keep-with-next
   1198          CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)
   1199          {
   \                     cJSON_PrintPreallocated:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   1200              printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
   \   00000008   0DC0A0E1           MOV      R12,SP
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   2450A0E3           MOV      R5,#+36
   \                     ??cJSON_PrintPreallocated_0:
   \   00000014   045055E2           SUBS     R5,R5,#+4
   \   00000018   05408CE7           STR      R4,[R12, R5]
   \   0000001C   FCFFFF1A           BNE      ??cJSON_PrintPreallocated_0
   1201          
   1202              if ((len < 0) || (buf == NULL))
   \   00000020   000052E3           CMP      R2,#+0
   \   00000024   0100004A           BMI      ??cJSON_PrintPreallocated_1
   \   00000028   000051E3           CMP      R1,#+0
   \   0000002C   0100001A           BNE      ??cJSON_PrintPreallocated_2
   1203              {
   1204                  return false;
   \                     ??cJSON_PrintPreallocated_1:
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C0000EA           B        ??cJSON_PrintPreallocated_3
   1205              }
   1206          
   1207              p.buffer = (unsigned char*)buf;
   1208              p.length = (size_t)len;
   \                     ??cJSON_PrintPreallocated_2:
   \   00000038   04208DE5           STR      R2,[SP, #+4]
   1209              p.offset = 0;
   \   0000003C   0020A0E3           MOV      R2,#+0
   \   00000040   08208DE5           STR      R2,[SP, #+8]
   1210              p.noalloc = true;
   \   00000044   0120A0E3           MOV      R2,#+1
   \   00000048   10208DE5           STR      R2,[SP, #+16]
   1211              p.format = fmt;
   1212              p.hooks = global_hooks;
   \   0000004C   ........           LDR      R2,??DataTable8  ;; global_hooks
   \   00000050   00108DE5           STR      R1,[SP, #+0]
   \   00000054   14308DE5           STR      R3,[SP, #+20]
   \   00000058   380092E8           LDM      R2,{R3-R5}
   \   0000005C   18108DE2           ADD      R1,SP,#+24
   \   00000060   380081E8           STM      R1,{R3-R5}
   1213          
   1214              return print_value(item, &p);
   \   00000064   0D10A0E1           MOV      R1,SP
   \   00000068   ........           BL       print_value
   \                     ??cJSON_PrintPreallocated_3:
   \   0000006C   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   00000070   3080BDE8           POP      {R4,R5,PC}       ;; return
   1215          }
   1216          
   1217          /* Parser core - when encountering text, process appropriately. */

   \                                 In segment CODE, align 4, keep-with-next
   1218          static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
   1219          {
   \                     parse_value:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   1220              if ((input_buffer == NULL) || (input_buffer->content == NULL))
   \   0000000C   00009515           LDRNE    R0,[R5, #+0]
   \   00000010   00005013           CMPNE    R0,#+0
   \   00000014   0000001A           BNE      ??parse_value_0
   1221              {
   1222                  return false; /* no input */
   \                     ??parse_value_1:
   \   00000018   ........           B        ?Subroutine110
   1223              }
   \                     ??parse_value_0:
   \   0000001C   083095E5           LDR      R3,[R5, #+8]
   \   00000020   041095E5           LDR      R1,[R5, #+4]
   \   00000024   ........           LDR      R6,??DataTable10  ;; `?<Constant "null">`
   \   00000028   042083E2           ADD      R2,R3,#+4
   \   0000002C   020051E1           CMP      R1,R2
   \   00000030   0A00003A           BCC      ??parse_value_2
   \   00000034   0420A0E3           MOV      R2,#+4
   \   00000038   0610A0E1           MOV      R1,R6
   \   0000003C   000083E0           ADD      R0,R3,R0
   \   00000040   150100EF           SWI      +277
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0400001A           BNE      ??parse_value_2
   1224          
   1225              /* parse the different types of values */
   1226              /* null */
   1227              if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
   1228              {
   1229                  item->type = cJSON_NULL;
   \   0000004C   0400A0E3           MOV      R0,#+4
   \   00000050   0C0084E5           STR      R0,[R4, #+12]
   1230                  input_buffer->offset += 4;
   \   00000054   080095E5           LDR      R0,[R5, #+8]
   \   00000058   040080E2           ADD      R0,R0,#+4
   \   0000005C   200000EA           B        ??parse_value_3
   1231                  return true;
   1232              }
   \                     ??parse_value_2:
   \   00000060   080095E5           LDR      R0,[R5, #+8]
   \   00000064   041095E5           LDR      R1,[R5, #+4]
   \   00000068   0170A0E3           MOV      R7,#+1
   \   0000006C   052080E2           ADD      R2,R0,#+5
   \   00000070   020051E1           CMP      R1,R2
   \   00000074   0900003A           BCC      ??parse_value_4
   \   00000078   003095E5           LDR      R3,[R5, #+0]
   \   0000007C   0520A0E3           MOV      R2,#+5
   \   00000080   081086E2           ADD      R1,R6,#+8
   \   00000084   030080E0           ADD      R0,R0,R3
   \   00000088   150100EF           SWI      +277
   \   0000008C   000050E3           CMP      R0,#+0
   1233              /* false */
   1234              if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
   1235              {
   1236                  item->type = cJSON_False;
   \   00000090   0C708405           STREQ    R7,[R4, #+12]
   1237                  input_buffer->offset += 5;
   \   00000094   08009505           LDREQ    R0,[R5, #+8]
   \   00000098   05008002           ADDEQ    R0,R0,#+5
   \   0000009C   1000000A           BEQ      ??parse_value_3
   \                     ??parse_value_4:
   \   000000A0   080095E5           LDR      R0,[R5, #+8]
   \   000000A4   041095E5           LDR      R1,[R5, #+4]
   \   000000A8   042080E2           ADD      R2,R0,#+4
   \   000000AC   020051E1           CMP      R1,R2
   \   000000B0   0C00003A           BCC      ??parse_value_5
   \   000000B4   003095E5           LDR      R3,[R5, #+0]
   \   000000B8   0420A0E3           MOV      R2,#+4
   \   000000BC   101086E2           ADD      R1,R6,#+16
   \   000000C0   030080E0           ADD      R0,R0,R3
   \   000000C4   150100EF           SWI      +277
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   0500001A           BNE      ??parse_value_5
   1238                  return true;
   1239              }
   1240              /* true */
   1241              if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
   1242              {
   1243                  item->type = cJSON_True;
   \   000000D0   0200A0E3           MOV      R0,#+2
   \   000000D4   0C0084E5           STR      R0,[R4, #+12]
   1244                  item->valueint = 1;
   \   000000D8   147084E5           STR      R7,[R4, #+20]
   1245                  input_buffer->offset += 4;
   \   000000DC   080095E5           LDR      R0,[R5, #+8]
   \   000000E0   040080E2           ADD      R0,R0,#+4
   \                     ??parse_value_3:
   \   000000E4   ........           B        ?Subroutine109
   1246                  return true;
   1247              }
   \                     ??parse_value_5:
   \   000000E8   080095E5           LDR      R0,[R5, #+8]
   \   000000EC   041095E5           LDR      R1,[R5, #+4]
   \   000000F0   010050E1           CMP      R0,R1
   \   000000F4   C7FFFF2A           BCS      ??parse_value_1
   \   000000F8   001095E5           LDR      R1,[R5, #+0]
   \   000000FC   010080E0           ADD      R0,R0,R1
   \   00000100   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000104   220051E3           CMP      R1,#+34
   \   00000108   0300001A           BNE      ??parse_value_6
   1248              /* string */
   1249              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
   1250              {
   1251                  return parse_string(item, input_buffer);
   \   0000010C   0510A0E1           MOV      R1,R5
   \   00000110   0400A0E1           MOV      R0,R4
   \   00000114   ........           BL       parse_string
   \   00000118   F080BDE8           POP      {R4-R7,PC}
   1252              }
   \                     ??parse_value_6:
   \   0000011C   2D0051E3           CMP      R1,#+45
   \   00000120   0300000A           BEQ      ??parse_value_7
   \   00000124   300051E3           CMP      R1,#+48
   \   00000128   0500003A           BCC      ??parse_value_8
   \   0000012C   3A0051E3           CMP      R1,#+58
   \   00000130   0300002A           BCS      ??parse_value_8
   1253              /* number */
   1254              if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
   1255              {
   1256                  return parse_number(item, input_buffer);
   \                     ??parse_value_7:
   \   00000134   0510A0E1           MOV      R1,R5
   \   00000138   0400A0E1           MOV      R0,R4
   \   0000013C   ........           BL       parse_number
   \   00000140   F080BDE8           POP      {R4-R7,PC}
   1257              }
   \                     ??parse_value_8:
   \   00000144   5B0051E3           CMP      R1,#+91
   \   00000148   0300001A           BNE      ??parse_value_9
   1258              /* array */
   1259              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
   1260              {
   1261                  return parse_array(item, input_buffer);
   \   0000014C   0510A0E1           MOV      R1,R5
   \   00000150   0400A0E1           MOV      R0,R4
   \   00000154   ........           BL       parse_array
   \   00000158   F080BDE8           POP      {R4-R7,PC}
   1262              }
   \                     ??parse_value_9:
   \   0000015C   7B0051E3           CMP      R1,#+123
   \   00000160   ACFFFF1A           BNE      ??parse_value_1
   1263              /* object */
   1264              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
   1265              {
   1266                  return parse_object(item, input_buffer);
   \   00000164   0510A0E1           MOV      R1,R5
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   ........           BL       parse_object
   \   00000170   F080BDE8           POP      {R4-R7,PC}       ;; return
   1267              }
   1268          
   1269              return false;
   1270          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine110:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   F080BDE8           POP      {R4-R7,PC}

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine109:
   \   00000000   080085E5           STR      R0,[R5, #+8]
   \                     ??Subroutine109_0:
   \   00000004   0100A0E3           MOV      R0,#+1
   \   00000008   F080BDE8           POP      {R4-R7,PC}
   1271          
   1272          /* Render a value to text. */

   \                                 In segment CODE, align 4, keep-with-next
   1273          static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
   1274          {
   \                     print_value:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1275              unsigned char *output = NULL;
   1276          
   1277              if ((item == NULL) || (output_buffer == NULL))
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00005513           CMPNE    R5,#+0
   \   00000014   4700000A           BEQ      ??print_value_0
   1278              {
   1279                  return false;
   1280              }
   1281          
   1282              switch ((item->type) & 0xFF)
   \   00000018   0C1094E5           LDR      R1,[R4, #+12]
   \   0000001C   100094E5           LDR      R0,[R4, #+16]
   \   00000020   ........           LDR      R6,??DataTable10  ;; `?<Constant "null">`
   \   00000024   FF1001E2           AND      R1,R1,#0xFF
   \   00000028   011051E2           SUBS     R1,R1,#+1
   \   0000002C   1500000A           BEQ      ??print_value_1
   \   00000030   011051E2           SUBS     R1,R1,#+1
   \   00000034   1C00000A           BEQ      ??print_value_2
   \   00000038   021051E2           SUBS     R1,R1,#+2
   \   0000003C   0A00000A           BEQ      ??print_value_3
   \   00000040   041051E2           SUBS     R1,R1,#+4
   \   00000044   1F00000A           BEQ      ??print_value_4
   \   00000048   081051E2           SUBS     R1,R1,#+8
   \   0000004C   2E00000A           BEQ      ??print_value_5
   \   00000050   101051E2           SUBS     R1,R1,#+16
   \   00000054   2F00000A           BEQ      ??print_value_6
   \   00000058   201051E2           SUBS     R1,R1,#+32
   \   0000005C   3100000A           BEQ      ??print_value_7
   \   00000060   401051E2           SUBS     R1,R1,#+64
   \   00000064   1B00000A           BEQ      ??print_value_8
   \   00000068   320000EA           B        ??print_value_0
   1283              {
   1284                  case cJSON_NULL:
   1285                      output = ensure(output_buffer, 5);
   \                     ??print_value_3:
   \   0000006C   0510A0E3           MOV      R1,#+5
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           BL       ensure
   1286                      if (output == NULL)
   \   00000078   000050E3           CMP      R0,#+0
   1287                      {
   1288                          return false;
   \   0000007C   7080BD08           POPEQ    {R4-R6,PC}
   1289                      }
   1290                      strcpy((char*)output, "null");
   \   00000080   0610A0E1           MOV      R1,R6
   \   00000084   050000EA           B        ??print_value_9
   1291                      return true;
   1292          
   1293                  case cJSON_False:
   1294                      output = ensure(output_buffer, 6);
   \                     ??print_value_1:
   \   00000088   0610A0E3           MOV      R1,#+6
   \   0000008C   0500A0E1           MOV      R0,R5
   \   00000090   ........           BL       ensure
   1295                      if (output == NULL)
   \   00000094   000050E3           CMP      R0,#+0
   1296                      {
   1297                          return false;
   \   00000098   7080BD08           POPEQ    {R4-R6,PC}
   1298                      }
   1299                      strcpy((char*)output, "false");
   \   0000009C   081086E2           ADD      R1,R6,#+8
   \                     ??print_value_9:
   \   000000A0   1A0000EF           SWI      +26
   1300                      return true;
   \                     ??print_value_10:
   \   000000A4   0100A0E3           MOV      R0,#+1
   \   000000A8   7080BDE8           POP      {R4-R6,PC}
   1301          
   1302                  case cJSON_True:
   1303                      output = ensure(output_buffer, 5);
   \                     ??print_value_2:
   \   000000AC   0510A0E3           MOV      R1,#+5
   \   000000B0   0500A0E1           MOV      R0,R5
   \   000000B4   ........           BL       ensure
   1304                      if (output == NULL)
   \   000000B8   000050E3           CMP      R0,#+0
   1305                      {
   1306                          return false;
   \   000000BC   7080BD08           POPEQ    {R4-R6,PC}
   1307                      }
   1308                      strcpy((char*)output, "true");
   \   000000C0   101086E2           ADD      R1,R6,#+16
   \   000000C4   F5FFFFEA           B        ??print_value_9
   1309                      return true;
   1310          
   1311                  case cJSON_Number:
   1312                      return print_number(item, output_buffer);
   \                     ??print_value_4:
   \   000000C8   0510A0E1           MOV      R1,R5
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   ........           BL       print_number
   \   000000D4   7080BDE8           POP      {R4-R6,PC}
   1313          
   1314                  case cJSON_Raw:
   1315                  {
   1316                      size_t raw_length = 0;
   1317                      if (item->valuestring == NULL)
   \                     ??print_value_8:
   \   000000D8   000050E3           CMP      R0,#+0
   1318                      {
   1319                          return false;
   \   000000DC   7080BD08           POPEQ    {R4-R6,PC}
   1320                      }
   1321          
   1322                      raw_length = strlen(item->valuestring) + sizeof("");
   \   000000E0   1B0000EF           SWI      +27
   \   000000E4   016080E2           ADD      R6,R0,#+1
   1323                      output = ensure(output_buffer, raw_length);
   \   000000E8   0610A0E1           MOV      R1,R6
   \   000000EC   0500A0E1           MOV      R0,R5
   \   000000F0   ........           BL       ensure
   1324                      if (output == NULL)
   \   000000F4   000050E3           CMP      R0,#+0
   1325                      {
   1326                          return false;
   \   000000F8   7080BD08           POPEQ    {R4-R6,PC}
   1327                      }
   1328                      memcpy(output, item->valuestring, raw_length);
   \   000000FC   101094E5           LDR      R1,[R4, #+16]
   \   00000100   0620A0E1           MOV      R2,R6
   \   00000104   1E0100EF           SWI      +286
   1329                      return true;
   \   00000108   E5FFFFEA           B        ??print_value_10
   1330                  }
   1331          
   1332                  case cJSON_String:
   1333                      return print_string(item, output_buffer);
   \                     ??print_value_5:
   \   0000010C   0510A0E1           MOV      R1,R5
   \   00000110   ........           BL       print_string_ptr
   \   00000114   7080BDE8           POP      {R4-R6,PC}
   1334          
   1335                  case cJSON_Array:
   1336                      return print_array(item, output_buffer);
   \                     ??print_value_6:
   \   00000118   0510A0E1           MOV      R1,R5
   \   0000011C   0400A0E1           MOV      R0,R4
   \   00000120   ........           BL       print_array
   \   00000124   7080BDE8           POP      {R4-R6,PC}
   1337          
   1338                  case cJSON_Object:
   1339                      return print_object(item, output_buffer);
   \                     ??print_value_7:
   \   00000128   0510A0E1           MOV      R1,R5
   \   0000012C   0400A0E1           MOV      R0,R4
   \   00000130   ........           BL       print_object
   \   00000134   7080BDE8           POP      {R4-R6,PC}
   1340          
   1341                  default:
   1342                      return false;
   \                     ??print_value_0:
   \   00000138   ........           B        ??Subroutine107_1
   1343              }
   1344          }
   1345          
   1346          /* Build an array from input text. */

   \                                 In segment CODE, align 4, keep-with-next
   1347          static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
   1348          {
   \                     parse_array:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1349              cJSON *head = NULL; /* head of the linked list */
   1350              cJSON *current_item = NULL;
   1351          
   1352              if (input_buffer->depth >= CJSON_NESTING_LIMIT)
   \   0000000C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000010   0070A0E3           MOV      R7,#+0
   \   00000014   0060A0E3           MOV      R6,#+0
   \   00000018   FA0F50E3           CMP      R0,#+1000
   \   0000001C   0000003A           BCC      ??parse_array_0
   1353              {
   1354                  return false; /* to deeply nested */
   \                     ??parse_array_1:
   \   00000020   ........           B        ?Subroutine110
   1355              }
   1356              input_buffer->depth++;
   \                     ??parse_array_0:
   \   00000024   010080E2           ADD      R0,R0,#+1
   \   00000028   0C0085E5           STR      R0,[R5, #+12]
   1357          
   1358              if (buffer_at_offset(input_buffer)[0] != '[')
   \   0000002C   080095E5           LDR      R0,[R5, #+8]
   \   00000030   001095E5           LDR      R1,[R5, #+0]
   \   00000034   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000038   5B0051E3           CMP      R1,#+91
   \   0000003C   F7FFFF1A           BNE      ??parse_array_1
   1359              {
   1360                  /* not an array */
   1361                  goto fail;
   1362              }
   1363          
   1364              input_buffer->offset++;
   \   00000040   010080E2           ADD      R0,R0,#+1
   \   00000044   080085E5           STR      R0,[R5, #+8]
   1365              buffer_skip_whitespace(input_buffer);
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           BL       buffer_skip_whitespace
   1366              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
   \   00000050   000055E3           CMP      R5,#+0
   \   00000054   1400000A           BEQ      ??parse_array_2
   \   00000058   080095E5           LDR      R0,[R5, #+8]
   \   0000005C   041095E5           LDR      R1,[R5, #+4]
   \   00000060   010050E1           CMP      R0,R1
   \   00000064   1000002A           BCS      ??parse_array_2
   \   00000068   001095E5           LDR      R1,[R5, #+0]
   \   0000006C   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000070   5D0051E3           CMP      R1,#+93
   \   00000074   2700000A           BEQ      ??parse_array_3
   1367              {
   1368                  /* empty array */
   1369                  goto success;
   1370              }
   1371          
   1372              /* check if we skipped to the end of the buffer */
   1373              if (cannot_access_at_index(input_buffer, 0))
   1374              {
   1375                  input_buffer->offset--;
   1376                  goto fail;
   1377              }
   1378          
   1379              /* step back to character in front of the first element */
   1380              input_buffer->offset--;
   \   00000078   010040E2           SUB      R0,R0,#+1
   \   0000007C   080085E5           STR      R0,[R5, #+8]
   1381              /* loop through the comma separated array elements */
   1382              do
   1383              {
   1384                  /* allocate next item */
   1385                  cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
   \                     ??parse_array_4:
   \   00000080   100085E2           ADD      R0,R5,#+16
   \   00000084   ........           BL       cJSON_New_Item
   1386                  if (new_item == NULL)
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   2A00000A           BEQ      ??parse_array_5
   1387                  {
   1388                      goto fail; /* allocation failure */
   1389                  }
   1390          
   1391                  /* attach next item to list */
   1392                  if (head == NULL)
   \   00000090   000056E3           CMP      R6,#+0
   \   00000094   00008715           STRNE    R0,[R7, #+0]
   \   00000098   04708015           STRNE    R7,[R0, #+4]
   \   0000009C   0070A011           MOVNE    R7,R0
   1393                  {
   1394                      /* start the linked list */
   1395                      current_item = head = new_item;
   \   000000A0   0060A001           MOVEQ    R6,R0
   \   000000A4   0670A001           MOVEQ    R7,R6
   \   000000A8   030000EA           B        ??parse_array_6
   1396                  }
   \                     ??parse_array_2:
   \   000000AC   080095E5           LDR      R0,[R5, #+8]
   \   000000B0   010040E2           SUB      R0,R0,#+1
   \   000000B4   080085E5           STR      R0,[R5, #+8]
   \   000000B8   D8FFFFEA           B        ??parse_array_1
   1397                  else
   1398                  {
   1399                      /* add to the end and advance */
   1400                      current_item->next = new_item;
   1401                      new_item->prev = current_item;
   1402                      current_item = new_item;
   1403                  }
   1404          
   1405                  /* parse next value */
   1406                  input_buffer->offset++;
   \                     ??parse_array_6:
   \   000000BC   080095E5           LDR      R0,[R5, #+8]
   \   000000C0   010080E2           ADD      R0,R0,#+1
   \   000000C4   080085E5           STR      R0,[R5, #+8]
   1407                  buffer_skip_whitespace(input_buffer);
   \   000000C8   0500A0E1           MOV      R0,R5
   \   000000CC   ........           BL       buffer_skip_whitespace
   1408                  if (!parse_value(current_item, input_buffer))
   \   000000D0   0510A0E1           MOV      R1,R5
   \   000000D4   0700A0E1           MOV      R0,R7
   \   000000D8   ........           BL       parse_value
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   1500000A           BEQ      ??parse_array_5
   1409                  {
   1410                      goto fail; /* failed to parse value */
   1411                  }
   1412                  buffer_skip_whitespace(input_buffer);
   \   000000E4   0500A0E1           MOV      R0,R5
   \   000000E8   ........           BL       buffer_skip_whitespace
   1413              }
   1414              while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
   \   000000EC   080095E5           LDR      R0,[R5, #+8]
   \   000000F0   041095E5           LDR      R1,[R5, #+4]
   \   000000F4   010050E1           CMP      R0,R1
   \   000000F8   0F00002A           BCS      ??parse_array_5
   \   000000FC   001095E5           LDR      R1,[R5, #+0]
   \   00000100   010080E0           ADD      R0,R0,R1
   \   00000104   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000108   2C0051E3           CMP      R1,#+44
   \   0000010C   DBFFFF0A           BEQ      ??parse_array_4
   \   00000110   5D0051E3           CMP      R1,#+93
   \   00000114   0800001A           BNE      ??parse_array_5
   1415          
   1416              if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
   1417              {
   1418                  goto fail; /* expected end of array */
   1419              }
   1420          
   1421          success:
   1422              input_buffer->depth--;
   \                     ??parse_array_3:
   \   00000118   0C0095E5           LDR      R0,[R5, #+12]
   \   0000011C   010040E2           SUB      R0,R0,#+1
   \   00000120   0C0085E5           STR      R0,[R5, #+12]
   1423          
   1424              item->type = cJSON_Array;
   \   00000124   2000A0E3           MOV      R0,#+32
   \   00000128   0C0084E5           STR      R0,[R4, #+12]
   1425              item->child = head;
   \   0000012C   086084E5           STR      R6,[R4, #+8]
   1426          
   1427              input_buffer->offset++;
   \   00000130   080095E5           LDR      R0,[R5, #+8]
   \   00000134   010080E2           ADD      R0,R0,#+1
   \   00000138   ........           B        ?Subroutine109
   1428          
   1429              return true;
   1430          
   1431          fail:
   1432              if (head != NULL)
   \                     ??parse_array_5:
   \   0000013C   000056E3           CMP      R6,#+0
   \   00000140   B6FFFF0A           BEQ      ??parse_array_1
   1433              {
   1434                  cJSON_Delete(head);
   \   00000144   0600A0E1           MOV      R0,R6
   \   00000148   ........           BL       cJSON_Delete
   \   0000014C   B3FFFFEA           B        ??parse_array_1
   1435              }
   1436          
   1437              return false;
   1438          }
   1439          
   1440          /* Render an array to text */

   \                                 In segment CODE, align 4, keep-with-next
   1441          static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
   1442          {
   \                     print_array:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   1443              unsigned char *output_pointer = NULL;
   1444              size_t length = 0;
   1445              cJSON *current_element = item->child;
   \   00000004   085090E5           LDR      R5,[R0, #+8]
   \   00000008   0140B0E1           MOVS     R4,R1
   1446          
   1447              if (output_buffer == NULL)
   1448              {
   1449                  return false;
   \   0000000C   0000A003           MOVEQ    R0,#+0
   \   00000010   F080BD08           POPEQ    {R4-R7,PC}
   1450              }
   1451          
   1452              /* Compose the output array. */
   1453              /* opening square bracket */
   1454              output_pointer = ensure(output_buffer, 1);
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       ensure
   1455              if (output_pointer == NULL)
   \   00000020   000050E3           CMP      R0,#+0
   1456              {
   1457                  return false;
   \   00000024   F080BD08           POPEQ    {R4-R7,PC}
   1458              }
   1459          
   1460              *output_pointer = '[';
   \   00000028   5B10A0E3           MOV      R1,#+91
   \   0000002C   0010C0E5           STRB     R1,[R0, #+0]
   1461              output_buffer->offset++;
   \   00000030   080094E5           LDR      R0,[R4, #+8]
   1462              output_buffer->depth++;
   \   00000034   0060A0E3           MOV      R6,#+0
   \   00000038   010080E2           ADD      R0,R0,#+1
   \   0000003C   080084E5           STR      R0,[R4, #+8]
   \   00000040   0C0094E5           LDR      R0,[R4, #+12]
   \   00000044   010080E2           ADD      R0,R0,#+1
   \   00000048   0C0084E5           STR      R0,[R4, #+12]
   \   0000004C   0A0000EA           B        ??print_array_0
   1463          
   1464              while (current_element != NULL)
   1465              {
   1466                  if (!print_value(current_element, output_buffer))
   1467                  {
   1468                      return false;
   1469                  }
   1470                  update_offset(output_buffer);
   1471                  if (current_element->next)
   1472                  {
   1473                      length = (size_t) (output_buffer->format ? 2 : 1);
   1474                      output_pointer = ensure(output_buffer, length + 1);
   1475                      if (output_pointer == NULL)
   1476                      {
   1477                          return false;
   1478                      }
   1479                      *output_pointer++ = ',';
   \                     ??print_array_1:
   \   00000050   2C10A0E3           MOV      R1,#+44
   \   00000054   ........           STRB     R1,[R0], #+1
   1480                      if(output_buffer->format)
   \   00000058   141094E5           LDR      R1,[R4, #+20]
   \   0000005C   000051E3           CMP      R1,#+0
   1481                      {
   1482                          *output_pointer++ = ' ';
   \   00000060   2010A013           MOVNE    R1,#+32
   \   00000064   ........           STRBNE   R1,[R0], #+1
   1483                      }
   1484                      *output_pointer = '\0';
   \   00000068   0060C0E5           STRB     R6,[R0, #+0]
   1485                      output_buffer->offset += length;
   \   0000006C   080094E5           LDR      R0,[R4, #+8]
   \   00000070   000087E0           ADD      R0,R7,R0
   \   00000074   080084E5           STR      R0,[R4, #+8]
   1486                  }
   1487                  current_element = current_element->next;
   \                     ??print_array_2:
   \   00000078   005095E5           LDR      R5,[R5, #+0]
   \                     ??print_array_0:
   \   0000007C   000055E3           CMP      R5,#+0
   \   00000080   1300000A           BEQ      ??print_array_3
   \   00000084   0410A0E1           MOV      R1,R4
   \   00000088   0500A0E1           MOV      R0,R5
   \   0000008C   ........           BL       print_value
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   F080BD08           POPEQ    {R4-R7,PC}
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       update_offset
   \   000000A0   000095E5           LDR      R0,[R5, #+0]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   F2FFFF0A           BEQ      ??print_array_2
   \   000000AC   140094E5           LDR      R0,[R4, #+20]
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   0270A013           MOVNE    R7,#+2
   \   000000B8   0170A003           MOVEQ    R7,#+1
   \   000000BC   011087E2           ADD      R1,R7,#+1
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       ensure
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   DFFFFF1A           BNE      ??print_array_1
   \   000000D0   F080BDE8           POP      {R4-R7,PC}
   1488              }
   1489          
   1490              output_pointer = ensure(output_buffer, 2);
   \                     ??print_array_3:
   \   000000D4   0210A0E3           MOV      R1,#+2
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       ensure
   1491              if (output_pointer == NULL)
   \   000000E0   000050E3           CMP      R0,#+0
   1492              {
   1493                  return false;
   \   000000E4   F080BD08           POPEQ    {R4-R7,PC}
   1494              }
   1495              *output_pointer++ = ']';
   \   000000E8   5D10A0E3           MOV      R1,#+93
   \   000000EC   ........           STRB     R1,[R0], #+1
   1496              *output_pointer = '\0';
   \   000000F0   0060C0E5           STRB     R6,[R0, #+0]
   1497              output_buffer->depth--;
   \   000000F4   0C0094E5           LDR      R0,[R4, #+12]
   \   000000F8   010040E2           SUB      R0,R0,#+1
   \   000000FC   0C0084E5           STR      R0,[R4, #+12]
   1498          
   1499              return true;
   \   00000100   ........           B        ??Subroutine109_0
   1500          }
   1501          
   1502          /* Build an object from the text. */

   \                                 In segment CODE, align 4, keep-with-next
   1503          static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
   1504          {
   \                     parse_object:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1505              cJSON *head = NULL; /* linked list head */
   1506              cJSON *current_item = NULL;
   1507          
   1508              if (input_buffer->depth >= CJSON_NESTING_LIMIT)
   \   0000000C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000010   0060A0E3           MOV      R6,#+0
   \   00000014   0070A0E3           MOV      R7,#+0
   \   00000018   0680A0E1           MOV      R8,R6
   \   0000001C   FA0F50E3           CMP      R0,#+1000
   \   00000020   0000003A           BCC      ??parse_object_0
   1509              {
   1510                  return false; /* to deeply nested */
   \                     ??parse_object_1:
   \   00000024   ........           B        ?Subroutine112
   1511              }
   1512              input_buffer->depth++;
   \                     ??parse_object_0:
   \   00000028   010080E2           ADD      R0,R0,#+1
   \   0000002C   0C0085E5           STR      R0,[R5, #+12]
   1513          
   1514              if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
   \   00000030   000055E3           CMP      R5,#+0
   \   00000034   FAFFFF0A           BEQ      ??parse_object_1
   \   00000038   080095E5           LDR      R0,[R5, #+8]
   \   0000003C   041095E5           LDR      R1,[R5, #+4]
   \   00000040   010050E1           CMP      R0,R1
   \   00000044   F6FFFF2A           BCS      ??parse_object_1
   \   00000048   001095E5           LDR      R1,[R5, #+0]
   \   0000004C   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000050   7B0051E3           CMP      R1,#+123
   \   00000054   F2FFFF1A           BNE      ??parse_object_1
   1515              {
   1516                  goto fail; /* not an object */
   1517              }
   1518          
   1519              input_buffer->offset++;
   \   00000058   010080E2           ADD      R0,R0,#+1
   \   0000005C   080085E5           STR      R0,[R5, #+8]
   1520              buffer_skip_whitespace(input_buffer);
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   ........           BL       buffer_skip_whitespace
   1521              if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
   \   00000068   080095E5           LDR      R0,[R5, #+8]
   \   0000006C   041095E5           LDR      R1,[R5, #+4]
   \   00000070   010050E1           CMP      R0,R1
   \   00000074   1000002A           BCS      ??parse_object_2
   \   00000078   001095E5           LDR      R1,[R5, #+0]
   \   0000007C   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000080   7D0051E3           CMP      R1,#+125
   \   00000084   3D00000A           BEQ      ??parse_object_3
   1522              {
   1523                  goto success; /* empty object */
   1524              }
   1525          
   1526              /* check if we skipped to the end of the buffer */
   1527              if (cannot_access_at_index(input_buffer, 0))
   1528              {
   1529                  input_buffer->offset--;
   1530                  goto fail;
   1531              }
   1532          
   1533              /* step back to character in front of the first element */
   1534              input_buffer->offset--;
   \   00000088   010040E2           SUB      R0,R0,#+1
   \   0000008C   080085E5           STR      R0,[R5, #+8]
   1535              /* loop through the comma separated array elements */
   1536              do
   1537              {
   1538                  /* allocate next item */
   1539                  cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
   \                     ??parse_object_4:
   \   00000090   100085E2           ADD      R0,R5,#+16
   \   00000094   ........           BL       cJSON_New_Item
   1540                  if (new_item == NULL)
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   4100000A           BEQ      ??parse_object_5
   1541                  {
   1542                      goto fail; /* allocation failure */
   1543                  }
   1544          
   1545                  /* attach next item to list */
   1546                  if (head == NULL)
   \   000000A0   000057E3           CMP      R7,#+0
   \   000000A4   00008815           STRNE    R0,[R8, #+0]
   \   000000A8   04808015           STRNE    R8,[R0, #+4]
   \   000000AC   0080A011           MOVNE    R8,R0
   1547                  {
   1548                      /* start the linked list */
   1549                      current_item = head = new_item;
   \   000000B0   0070A001           MOVEQ    R7,R0
   \   000000B4   0780A001           MOVEQ    R8,R7
   \   000000B8   020000EA           B        ??parse_object_6
   1550                  }
   \                     ??parse_object_2:
   \   000000BC   010040E2           SUB      R0,R0,#+1
   \   000000C0   080085E5           STR      R0,[R5, #+8]
   \   000000C4   D6FFFFEA           B        ??parse_object_1
   1551                  else
   1552                  {
   1553                      /* add to the end and advance */
   1554                      current_item->next = new_item;
   1555                      new_item->prev = current_item;
   1556                      current_item = new_item;
   1557                  }
   1558          
   1559                  /* parse the name of the child */
   1560                  input_buffer->offset++;
   \                     ??parse_object_6:
   \   000000C8   080095E5           LDR      R0,[R5, #+8]
   \   000000CC   010080E2           ADD      R0,R0,#+1
   \   000000D0   080085E5           STR      R0,[R5, #+8]
   1561                  buffer_skip_whitespace(input_buffer);
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   ........           BL       buffer_skip_whitespace
   1562                  if (!parse_string(current_item, input_buffer))
   \   000000DC   0510A0E1           MOV      R1,R5
   \   000000E0   0800A0E1           MOV      R0,R8
   \   000000E4   ........           BL       parse_string
   \   000000E8   000050E3           CMP      R0,#+0
   \   000000EC   2D00000A           BEQ      ??parse_object_5
   1563                  {
   1564                      goto fail; /* faile to parse name */
   1565                  }
   1566                  buffer_skip_whitespace(input_buffer);
   \   000000F0   0500A0E1           MOV      R0,R5
   \   000000F4   ........           BL       buffer_skip_whitespace
   1567          
   1568                  /* swap valuestring and string, because we parsed the name */
   1569                  current_item->string = current_item->valuestring;
   \   000000F8   100088E2           ADD      R0,R8,#+16
   \   000000FC   001090E5           LDR      R1,[R0, #+0]
   \   00000100   101080E5           STR      R1,[R0, #+16]
   1570                  current_item->valuestring = NULL;
   \   00000104   006080E5           STR      R6,[R0, #+0]
   1571          
   1572                  if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
   \   00000108   080095E5           LDR      R0,[R5, #+8]
   \   0000010C   041095E5           LDR      R1,[R5, #+4]
   \   00000110   010050E1           CMP      R0,R1
   \   00000114   2300002A           BCS      ??parse_object_5
   \   00000118   001095E5           LDR      R1,[R5, #+0]
   \   0000011C   0110D0E7           LDRB     R1,[R0, +R1]
   \   00000120   3A0051E3           CMP      R1,#+58
   \   00000124   1F00001A           BNE      ??parse_object_5
   1573                  {
   1574                      goto fail; /* invalid object */
   1575                  }
   1576          
   1577                  /* parse the value */
   1578                  input_buffer->offset++;
   \   00000128   010080E2           ADD      R0,R0,#+1
   \   0000012C   080085E5           STR      R0,[R5, #+8]
   1579                  buffer_skip_whitespace(input_buffer);
   \   00000130   0500A0E1           MOV      R0,R5
   \   00000134   ........           BL       buffer_skip_whitespace
   1580                  if (!parse_value(current_item, input_buffer))
   \   00000138   0510A0E1           MOV      R1,R5
   \   0000013C   0800A0E1           MOV      R0,R8
   \   00000140   ........           BL       parse_value
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   1600000A           BEQ      ??parse_object_5
   1581                  {
   1582                      goto fail; /* failed to parse value */
   1583                  }
   1584                  buffer_skip_whitespace(input_buffer);
   \   0000014C   0500A0E1           MOV      R0,R5
   \   00000150   ........           BL       buffer_skip_whitespace
   1585              }
   1586              while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
   \   00000154   080095E5           LDR      R0,[R5, #+8]
   \   00000158   041095E5           LDR      R1,[R5, #+4]
   \   0000015C   010050E1           CMP      R0,R1
   \   00000160   1000002A           BCS      ??parse_object_5
   \   00000164   001095E5           LDR      R1,[R5, #+0]
   \   00000168   010080E0           ADD      R0,R0,R1
   \   0000016C   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000170   2C0051E3           CMP      R1,#+44
   \   00000174   C5FFFF0A           BEQ      ??parse_object_4
   \   00000178   7D0051E3           CMP      R1,#+125
   \   0000017C   0900001A           BNE      ??parse_object_5
   1587          
   1588              if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
   1589              {
   1590                  goto fail; /* expected end of object */
   1591              }
   1592          
   1593          success:
   1594              input_buffer->depth--;
   \                     ??parse_object_3:
   \   00000180   0C0095E5           LDR      R0,[R5, #+12]
   \   00000184   010040E2           SUB      R0,R0,#+1
   \   00000188   0C0085E5           STR      R0,[R5, #+12]
   1595          
   1596              item->type = cJSON_Object;
   \   0000018C   4000A0E3           MOV      R0,#+64
   \   00000190   0C0084E5           STR      R0,[R4, #+12]
   1597              item->child = head;
   \   00000194   087084E5           STR      R7,[R4, #+8]
   1598          
   1599              input_buffer->offset++;
   \   00000198   080095E5           LDR      R0,[R5, #+8]
   \   0000019C   010080E2           ADD      R0,R0,#+1
   \   000001A0   080085E5           STR      R0,[R5, #+8]
   1600              return true;
   \   000001A4   ........           B        ?Subroutine113
   1601          
   1602          fail:
   1603              if (head != NULL)
   \                     ??parse_object_5:
   \   000001A8   000057E3           CMP      R7,#+0
   \   000001AC   9CFFFF0A           BEQ      ??parse_object_1
   1604              {
   1605                  cJSON_Delete(head);
   \   000001B0   0700A0E1           MOV      R0,R7
   \   000001B4   ........           BL       cJSON_Delete
   \   000001B8   99FFFFEA           B        ??parse_object_1
   1606              }
   1607          
   1608              return false;
   1609          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine113:
   \   00000000   0100A0E3           MOV      R0,#+1
   \   00000004   F081BDE8           POP      {R4-R8,PC}
   1610          
   1611          /* Render an object to text. */

   \                                 In segment CODE, align 4, keep-with-next
   1612          static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
   1613          {
   \                     print_object:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   1614              unsigned char *output_pointer = NULL;
   1615              size_t length = 0;
   1616              cJSON *current_item = item->child;
   \   00000004   086090E5           LDR      R6,[R0, #+8]
   \   00000008   0140B0E1           MOVS     R4,R1
   1617          
   1618              if (output_buffer == NULL)
   1619              {
   1620                  return false;
   \   0000000C   0000A003           MOVEQ    R0,#+0
   \   00000010   F087BD08           POPEQ    {R4-R10,PC}
   1621              }
   1622          
   1623              /* Compose the output: */
   1624              length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
   \   00000014   140094E5           LDR      R0,[R4, #+20]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   02A0A013           MOVNE    R10,#+2
   \   00000020   01A0A003           MOVEQ    R10,#+1
   1625              output_pointer = ensure(output_buffer, length + 1);
   \   00000024   01108AE2           ADD      R1,R10,#+1
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       ensure
   1626              if (output_pointer == NULL)
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   F087BD08           POPEQ    {R4-R10,PC}
   1627              {
   1628                  return false;
   1629              }
   1630          
   1631              *output_pointer++ = '{';
   \   00000038   7B10A0E3           MOV      R1,#+123
   \   0000003C   ........           STRB     R1,[R0], #+1
   1632              output_buffer->depth++;
   \   00000040   0C1094E5           LDR      R1,[R4, #+12]
   1633              if (output_buffer->format)
   \   00000044   0A80A0E3           MOV      R8,#+10
   \   00000048   011081E2           ADD      R1,R1,#+1
   \   0000004C   0C1084E5           STR      R1,[R4, #+12]
   \   00000050   141094E5           LDR      R1,[R4, #+20]
   1634              {
   1635                  *output_pointer++ = '\n';
   1636              }
   1637              output_buffer->offset += length;
   \   00000054   0050A0E3           MOV      R5,#+0
   \   00000058   000051E3           CMP      R1,#+0
   \   0000005C   0080C015           STRBNE   R8,[R0, #+0]
   \   00000060   080094E5           LDR      R0,[R4, #+8]
   \   00000064   0990A0E3           MOV      R9,#+9
   \   00000068   00008AE0           ADD      R0,R10,R0
   \   0000006C   080084E5           STR      R0,[R4, #+8]
   \   00000070   110000EA           B        ??print_object_0
   1638          
   1639              while (current_item)
   1640              {
   1641                  if (output_buffer->format)
   1642                  {
   1643                      size_t i;
   1644                      output_pointer = ensure(output_buffer, output_buffer->depth);
   1645                      if (output_pointer == NULL)
   1646                      {
   1647                          return false;
   1648                      }
   1649                      for (i = 0; i < output_buffer->depth; i++)
   1650                      {
   1651                          *output_pointer++ = '\t';
   1652                      }
   1653                      output_buffer->offset += output_buffer->depth;
   1654                  }
   1655          
   1656                  /* print key */
   1657                  if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
   1658                  {
   1659                      return false;
   1660                  }
   1661                  update_offset(output_buffer);
   1662          
   1663                  length = (size_t) (output_buffer->format ? 2 : 1);
   1664                  output_pointer = ensure(output_buffer, length);
   1665                  if (output_pointer == NULL)
   1666                  {
   1667                      return false;
   1668                  }
   1669                  *output_pointer++ = ':';
   1670                  if (output_buffer->format)
   1671                  {
   1672                      *output_pointer++ = '\t';
   1673                  }
   1674                  output_buffer->offset += length;
   1675          
   1676                  /* print value */
   1677                  if (!print_value(current_item, output_buffer))
   1678                  {
   1679                      return false;
   1680                  }
   1681                  update_offset(output_buffer);
   1682          
   1683                  /* print comma if not last */
   1684                  length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
   \                     ??print_object_1:
   \   00000074   01A080E0           ADD      R10,R0,R1
   1685                  output_pointer = ensure(output_buffer, length + 1);
   \   00000078   01108AE2           ADD      R1,R10,#+1
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   ........           BL       ensure
   1686                  if (output_pointer == NULL)
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   F087BD08           POPEQ    {R4-R10,PC}
   1687                  {
   1688                      return false;
   1689                  }
   1690                  if (current_item->next)
   \   0000008C   001096E5           LDR      R1,[R6, #+0]
   \   00000090   000051E3           CMP      R1,#+0
   1691                  {
   1692                      *output_pointer++ = ',';
   \   00000094   2C10A013           MOVNE    R1,#+44
   \   00000098   ........           STRBNE   R1,[R0], #+1
   1693                  }
   1694          
   1695                  if (output_buffer->format)
   \   0000009C   141094E5           LDR      R1,[R4, #+20]
   \   000000A0   000051E3           CMP      R1,#+0
   1696                  {
   1697                      *output_pointer++ = '\n';
   \   000000A4   ........           STRBNE   R8,[R0], #+1
   1698                  }
   1699                  *output_pointer = '\0';
   \   000000A8   0050C0E5           STRB     R5,[R0, #+0]
   1700                  output_buffer->offset += length;
   \   000000AC   080094E5           LDR      R0,[R4, #+8]
   \   000000B0   00008AE0           ADD      R0,R10,R0
   \   000000B4   080084E5           STR      R0,[R4, #+8]
   1701          
   1702                  current_item = current_item->next;
   \   000000B8   006096E5           LDR      R6,[R6, #+0]
   \                     ??print_object_0:
   \   000000BC   0C1094E5           LDR      R1,[R4, #+12]
   \   000000C0   140094E5           LDR      R0,[R4, #+20]
   \   000000C4   000056E3           CMP      R6,#+0
   \   000000C8   3700000A           BEQ      ??print_object_2
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   0D00000A           BEQ      ??print_object_3
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   ........           BL       ensure
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   F087BD08           POPEQ    {R4-R10,PC}
   \   000000E4   0010A0E3           MOV      R1,#+0
   \   000000E8   010000EA           B        ??print_object_4
   \                     ??print_object_5:
   \   000000EC   ........           STRB     R9,[R0], #+1
   \   000000F0   011081E2           ADD      R1,R1,#+1
   \                     ??print_object_4:
   \   000000F4   0C2094E5           LDR      R2,[R4, #+12]
   \   000000F8   020051E1           CMP      R1,R2
   \   000000FC   FAFFFF3A           BCC      ??print_object_5
   \   00000100   080094E5           LDR      R0,[R4, #+8]
   \   00000104   000082E0           ADD      R0,R2,R0
   \   00000108   080084E5           STR      R0,[R4, #+8]
   \                     ??print_object_3:
   \   0000010C   200096E5           LDR      R0,[R6, #+32]
   \   00000110   0410A0E1           MOV      R1,R4
   \   00000114   ........           BL       print_string_ptr
   \   00000118   000050E3           CMP      R0,#+0
   \   0000011C   F087BD08           POPEQ    {R4-R10,PC}
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       update_offset
   \   00000128   140094E5           LDR      R0,[R4, #+20]
   \   0000012C   000050E3           CMP      R0,#+0
   \   00000130   02A0A013           MOVNE    R10,#+2
   \   00000134   01A0A003           MOVEQ    R10,#+1
   \   00000138   0A10A0E1           MOV      R1,R10
   \   0000013C   0400A0E1           MOV      R0,R4
   \   00000140   ........           BL       ensure
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   F087BD08           POPEQ    {R4-R10,PC}
   \   0000014C   3A10A0E3           MOV      R1,#+58
   \   00000150   ........           STRB     R1,[R0], #+1
   \   00000154   141094E5           LDR      R1,[R4, #+20]
   \   00000158   000051E3           CMP      R1,#+0
   \   0000015C   0090C015           STRBNE   R9,[R0, #+0]
   \   00000160   080094E5           LDR      R0,[R4, #+8]
   \   00000164   0410A0E1           MOV      R1,R4
   \   00000168   00008AE0           ADD      R0,R10,R0
   \   0000016C   080084E5           STR      R0,[R4, #+8]
   \   00000170   0600A0E1           MOV      R0,R6
   \   00000174   ........           BL       print_value
   \   00000178   000050E3           CMP      R0,#+0
   \   0000017C   F087BD08           POPEQ    {R4-R10,PC}
   \   00000180   0400A0E1           MOV      R0,R4
   \   00000184   ........           BL       update_offset
   \   00000188   140094E5           LDR      R0,[R4, #+20]
   \   0000018C   000050E3           CMP      R0,#+0
   \   00000190   000096E5           LDR      R0,[R6, #+0]
   \   00000194   0110A013           MOVNE    R1,#+1
   \   00000198   0010A003           MOVEQ    R1,#+0
   \   0000019C   000050E3           CMP      R0,#+0
   \   000001A0   B3FFFF0A           BEQ      ??print_object_1
   \   000001A4   0100A0E3           MOV      R0,#+1
   \   000001A8   B1FFFFEA           B        ??print_object_1
   1703              }
   1704          
   1705              output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
   \                     ??print_object_2:
   \   000001AC   000050E3           CMP      R0,#+0
   \   000001B0   01108112           ADDNE    R1,R1,#+1
   \   000001B4   0210A003           MOVEQ    R1,#+2
   \   000001B8   0400A0E1           MOV      R0,R4
   \   000001BC   ........           BL       ensure
   1706              if (output_pointer == NULL)
   \   000001C0   000050E3           CMP      R0,#+0
   \   000001C4   F087BD08           POPEQ    {R4-R10,PC}
   1707              {
   1708                  return false;
   1709              }
   1710              if (output_buffer->format)
   \   000001C8   141094E5           LDR      R1,[R4, #+20]
   \   000001CC   000051E3           CMP      R1,#+0
   \   000001D0   0700000A           BEQ      ??print_object_6
   1711              {
   1712                  size_t i;
   1713                  for (i = 0; i < (output_buffer->depth - 1); i++)
   \   000001D4   0010A0E3           MOV      R1,#+0
   \   000001D8   010000EA           B        ??print_object_7
   1714                  {
   1715                      *output_pointer++ = '\t';
   \                     ??print_object_8:
   \   000001DC   ........           STRB     R9,[R0], #+1
   1716                  }
   \   000001E0   011081E2           ADD      R1,R1,#+1
   \                     ??print_object_7:
   \   000001E4   0C2094E5           LDR      R2,[R4, #+12]
   \   000001E8   012042E2           SUB      R2,R2,#+1
   \   000001EC   020051E1           CMP      R1,R2
   \   000001F0   F9FFFF3A           BCC      ??print_object_8
   1717              }
   1718              *output_pointer++ = '}';
   \                     ??print_object_6:
   \   000001F4   7D10A0E3           MOV      R1,#+125
   \   000001F8   ........           STRB     R1,[R0], #+1
   1719              *output_pointer = '\0';
   \   000001FC   0050C0E5           STRB     R5,[R0, #+0]
   1720              output_buffer->depth--;
   \   00000200   0C0094E5           LDR      R0,[R4, #+12]
   \   00000204   010040E2           SUB      R0,R0,#+1
   \   00000208   0C0084E5           STR      R0,[R4, #+12]
   1721          
   1722              return true;
   \   0000020C                      REQUIRE ?Subroutine115
   \   0000020C                      ;; // Fall through to label ?Subroutine115
   1723          }
   1724          
   1725          /* Get Array size/item / object item. */

   \                                 In segment CODE, align 4, keep-with-next
   1726          CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
   1727          {
   1728              cJSON *child = NULL;
   1729              size_t size = 0;
   \                     cJSON_GetArraySize:
   \   00000000   0010A0E3           MOV      R1,#+0
   1730          
   1731              if (array == NULL)
   \   00000004   000050E3           CMP      R0,#+0
   1732              {
   1733                  return 0;
   \   00000008   1EFF2F01           BXEQ     LR
   1734              }
   1735          
   1736              child = array->child;
   \   0000000C   080090E5           LDR      R0,[R0, #+8]
   \   00000010   010000EA           B        ??cJSON_GetArraySize_0
   1737          
   1738              while(child != NULL)
   1739              {
   1740                  size++;
   1741                  child = child->next;
   \                     ??cJSON_GetArraySize_1:
   \   00000014   000090E5           LDR      R0,[R0, #+0]
   \   00000018   011081E2           ADD      R1,R1,#+1
   1742              }
   \                     ??cJSON_GetArraySize_0:
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   FBFFFF1A           BNE      ??cJSON_GetArraySize_1
   1743          
   1744              /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
   1745          
   1746              return (int)size;
   \   00000024                      REQUIRE ?Subroutine103
   \   00000024                      ;; // Fall through to label ?Subroutine103
   1747          }
   1748          

   \                                 In segment CODE, align 4, keep-with-next
   1749          static cJSON* get_array_item(const cJSON *array, size_t index)
   1750          {
   1751              cJSON *current_child = NULL;
   1752          
   1753              if (array == NULL)
   \                     get_array_item:
   \   00000000   000050E3           CMP      R0,#+0
   1754              {
   1755                  return NULL;
   \   00000004   1EFF2F01           BXEQ     LR
   1756              }
   1757          
   1758              current_child = array->child;
   \   00000008   080090E5           LDR      R0,[R0, #+8]
   \   0000000C   010000EA           B        ??get_array_item_0
   1759              while ((current_child != NULL) && (index > 0))
   1760              {
   1761                  index--;
   1762                  current_child = current_child->next;
   \                     ??get_array_item_1:
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   011041E2           SUB      R1,R1,#+1
   1763              }
   \                     ??get_array_item_0:
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   00005113           CMPNE    R1,#+0
   \   00000020   FAFFFF1A           BNE      ??get_array_item_1
   1764          
   1765              return current_child;
   \   00000024   1EFF2FE1           BX       LR               ;; return
   1766          }
   1767          

   \                                 In segment CODE, align 4, keep-with-next
   1768          CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
   1769          {
   1770              if (index < 0)
   \                     cJSON_GetArrayItem:
   \   00000000   000051E3           CMP      R1,#+0
   1771              {
   1772                  return NULL;
   \   00000004   0000A043           MOVMI    R0,#+0
   \   00000008   1EFF2F41           BXMI     LR
   1773              }
   1774          
   1775              return get_array_item(array, (size_t)index);
   \   0000000C   ........           B        get_array_item   ;; tailcall
   1776          }
   1777          

   \                                 In segment CODE, align 4, keep-with-next
   1778          static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
   1779          {
   \                     get_object_item:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   1780              cJSON *current_element = NULL;
   1781          
   1782              if ((object == NULL) || (name == NULL))
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   F081BD08           POPEQ    {R4-R8,PC}
   \   00000010   000054E3           CMP      R4,#+0
   1783              {
   1784                  return NULL;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   F081BD08           POPEQ    {R4-R8,PC}
   1785              }
   1786          
   1787              current_element = object->child;
   \   0000001C   085090E5           LDR      R5,[R0, #+8]
   1788              if (case_sensitive)
   \   00000020   000052E3           CMP      R2,#+0
   \   00000024   0900000A           BEQ      ??get_object_item_0
   1789              {
   1790                  while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
   \                     ??get_object_item_1:
   \   00000028   000055E3           CMP      R5,#+0
   \   0000002C   2200000A           BEQ      ??get_object_item_2
   \   00000030   201095E5           LDR      R1,[R5, #+32]
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   190000EF           SWI      +25
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   1D00000A           BEQ      ??get_object_item_2
   1791                  {
   1792                      current_element = current_element->next;
   \   00000044   005095E5           LDR      R5,[R5, #+0]
   \   00000048   F6FFFFEA           B        ??get_object_item_1
   1793                  }
   1794              }
   1795              else
   1796              {
   1797                  while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
   1798                  {
   1799                      current_element = current_element->next;
   \                     ??get_object_item_3:
   \   0000004C   005095E5           LDR      R5,[R5, #+0]
   1800                  }
   \                     ??get_object_item_0:
   \   00000050   000055E3           CMP      R5,#+0
   \   00000054   1800000A           BEQ      ??get_object_item_2
   \   00000058   206095E5           LDR      R6,[R5, #+32]
   \   0000005C   0470B0E1           MOVS     R7,R4
   \   00000060   00005613           CMPNE    R6,#+0
   \   00000064   F8FFFF0A           BEQ      ??get_object_item_3
   \   00000068   060057E1           CMP      R7,R6
   \   0000006C   0400001A           BNE      ??get_object_item_4
   \   00000070   110000EA           B        ??get_object_item_2
   \                     ??get_object_item_5:
   \   00000074   ........           LDRB     R0,[R7], #+1
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0E00000A           BEQ      ??get_object_item_2
   \   00000080   016086E2           ADD      R6,R6,#+1
   \                     ??get_object_item_4:
   \   00000084   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000088   ........           _BLF     tolower,??tolower??rA
   \   0000008C   0080A0E1           MOV      R8,R0
   \   00000090   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000094   ........           _BLF     tolower,??tolower??rA
   \   00000098   000058E1           CMP      R8,R0
   \   0000009C   F4FFFF0A           BEQ      ??get_object_item_5
   \   000000A0   0000D7E5           LDRB     R0,[R7, #+0]
   \   000000A4   ........           _BLF     tolower,??tolower??rA
   \   000000A8   0070A0E1           MOV      R7,R0
   \   000000AC   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000B0   ........           _BLF     tolower,??tolower??rA
   \   000000B4   000057E0           SUBS     R0,R7,R0
   \   000000B8   E3FFFF1A           BNE      ??get_object_item_3
   1801              }
   1802          
   1803              return current_element;
   \                     ??get_object_item_2:
   \   000000BC                      REQUIRE ?Subroutine114
   \   000000BC                      ;; // Fall through to label ?Subroutine114
   1804          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine114:
   \   00000000   0500A0E1           MOV      R0,R5
   \   00000004   F081BDE8           POP      {R4-R8,PC}       ;; return
   1805          

   \                                 In segment CODE, align 4, keep-with-next
   1806          CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
   1807          {
   1808              return get_object_item(object, string, false);
   \                     cJSON_GetObjectItem:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        get_object_item  ;; tailcall
   1809          }
   1810          

   \                                 In segment CODE, align 4, keep-with-next
   1811          CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
   1812          {
   1813              return get_object_item(object, string, true);
   \                     cJSON_GetObjectItemCaseSensitive:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        get_object_item  ;; tailcall
   1814          }
   1815          

   \                                 In segment CODE, align 4, keep-with-next
   1816          CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
   1817          {
   \                     cJSON_HasObjectItem:
   \   00000000   00402DE9           PUSH     {LR}
   1818              return cJSON_GetObjectItem(object, string) ? 1 : 0;
   \   00000004   ........           BL       cJSON_GetObjectItem
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   0100A013           MOVNE    R0,#+1
   \   00000010   0080BDE8           POP      {PC}             ;; return
   1819          }
   1820          
   1821          /* Utility for array list handling. */

   \                                 In segment CODE, align 4, keep-with-next
   1822          static void suffix_object(cJSON *prev, cJSON *item)
   1823          {
   1824              prev->next = item;
   \                     suffix_object:
   \   00000000   001080E5           STR      R1,[R0, #+0]
   1825              item->prev = prev;
   \   00000004   040081E5           STR      R0,[R1, #+4]
   1826          }
   \   00000008   1EFF2FE1           BX       LR               ;; return
   1827          
   1828          /* Utility for handling references. */

   \                                 In segment CODE, align 4, keep-with-next
   1829          static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
   1830          {
   \                     create_reference:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0100A0E1           MOV      R0,R1
   1831              cJSON *reference = NULL;
   1832              if (item == NULL)
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   0200000A           BEQ      ??create_reference_0
   1833              {
   1834                  return NULL;
   1835              }
   1836          
   1837              reference = cJSON_New_Item(hooks);
   \   00000014   ........           BL       cJSON_New_Item
   \   00000018   0050B0E1           MOVS     R5,R0
   1838              if (reference == NULL)
   \   0000001C   0100001A           BNE      ??create_reference_1
   1839              {
   1840                  return NULL;
   \                     ??create_reference_0:
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   3080BDE8           POP      {R4,R5,PC}
   1841              }
   1842          
   1843              memcpy(reference, item, sizeof(cJSON));
   \                     ??create_reference_1:
   \   00000028   2420A0E3           MOV      R2,#+36
   \   0000002C   0410A0E1           MOV      R1,R4
   \   00000030   1E0100EF           SWI      +286
   1844              reference->string = NULL;
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   200085E5           STR      R0,[R5, #+32]
   1845              reference->type |= cJSON_IsReference;
   \   0000003C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000040   401F81E3           ORR      R1,R1,#0x100
   \   00000044   0C1085E5           STR      R1,[R5, #+12]
   1846              reference->next = reference->prev = NULL;
   \   00000048   040085E5           STR      R0,[R5, #+4]
   \   0000004C   000085E5           STR      R0,[R5, #+0]
   1847              return reference;
   \   00000050   0500A0E1           MOV      R0,R5
   \   00000054   3080BDE8           POP      {R4,R5,PC}       ;; return
   1848          }
   1849          

   \                                 In segment CODE, align 4, keep-with-next
   1850          static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
   1851          {
   \                     add_item_to_array:
   \   00000000   00402DE9           PUSH     {LR}
   1852              cJSON *child = NULL;
   1853          
   1854              if ((item == NULL) || (array == NULL))
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   00005013           CMPNE    R0,#+0
   1855              {
   1856                  return false;
   \   0000000C   0000A003           MOVEQ    R0,#+0
   \   00000010   0080BD08           POPEQ    {PC}
   1857              }
   1858          
   1859              child = array->child;
   \   00000014   082090E5           LDR      R2,[R0, #+8]
   1860          
   1861              if (child == NULL)
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   0200001A           BNE      ??add_item_to_array_0
   1862              {
   1863                  /* list is empty, start new one */
   1864                  array->child = item;
   \   00000020   081080E5           STR      R1,[R0, #+8]
   \   00000024   050000EA           B        ??add_item_to_array_1
   1865              }
   1866              else
   1867              {
   1868                  /* append to the end */
   1869                  while (child->next)
   1870                  {
   1871                      child = child->next;
   \                     ??add_item_to_array_2:
   \   00000028   0020A0E1           MOV      R2,R0
   1872                  }
   \                     ??add_item_to_array_0:
   \   0000002C   000092E5           LDR      R0,[R2, #+0]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   FBFFFF1A           BNE      ??add_item_to_array_2
   1873                  suffix_object(child, item);
   \   00000038   0200A0E1           MOV      R0,R2
   \   0000003C   ........           BL       suffix_object
   1874              }
   1875          
   1876              return true;
   \                     ??add_item_to_array_1:
   \   00000040                      REQUIRE ?Subroutine105
   \   00000040                      ;; // Fall through to label ?Subroutine105
   1877          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine105:
   \   00000000   0100A0E3           MOV      R0,#+1
   \   00000004   0080BDE8           POP      {PC}             ;; return
   1878          
   1879          /* Add item to array/object. */

   \                                 In segment CODE, align 4, keep-with-next
   1880          CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
   1881          {
   1882              add_item_to_array(array, item);
   \                     cJSON_AddItemToArray:
   \   00000000   ........           B        add_item_to_array  ;; tailcall
   1883          }
   1884          
   1885          #if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
   1886              #pragma GCC diagnostic push
   1887          #endif
   1888          #ifdef __GNUC__
   1889          #pragma GCC diagnostic ignored "-Wcast-qual"
   1890          #endif
   1891          /* helper function to cast away const */
   1892          static void* cast_away_const(const void* string)
   1893          {
   1894              return (void*)string;
   1895          }
   1896          #if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
   1897              #pragma GCC diagnostic pop
   1898          #endif
   1899          
   1900          

   \                                 In segment CODE, align 4, keep-with-next
   1901          static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
   1902          {
   \                     add_item_to_object:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   18009DE5           LDR      R0,[SP, #+24]
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0360A0E1           MOV      R6,R3
   1903              char *new_key = NULL;
   1904              int new_type = cJSON_Invalid;
   1905          
   1906              if ((object == NULL) || (string == NULL) || (item == NULL))
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   00005713           CMPNE    R7,#+0
   \   00000020   00005513           CMPNE    R5,#+0
   \   00000024   0000001A           BNE      ??add_item_to_object_0
   1907              {
   1908                  return false;
   \                     ??add_item_to_object_1:
   \   00000028   ........           B        ?Subroutine112
   1909              }
   1910          
   1911              if (constant_key)
   \                     ??add_item_to_object_0:
   \   0000002C   000050E3           CMP      R0,#+0
   1912              {
   1913                  new_key = (char*)cast_away_const(string);
   1914                  new_type = item->type | cJSON_StringIsConst;
   \   00000030   0C009515           LDRNE    R0,[R5, #+12]
   \   00000034   808F8013           ORRNE    R8,R0,#0x200
   \   00000038   0600001A           BNE      ??add_item_to_object_2
   1915              }
   1916              else
   1917              {
   1918                  new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
   \   0000003C   0610A0E1           MOV      R1,R6
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   ........           BL       cJSON_strdup
   \   00000048   0070B0E1           MOVS     R7,R0
   1919                  if (new_key == NULL)
   \   0000004C   F5FFFF0A           BEQ      ??add_item_to_object_1
   1920                  {
   1921                      return false;
   1922                  }
   1923          
   1924                  new_type = item->type & ~cJSON_StringIsConst;
   \   00000050   0C0095E5           LDR      R0,[R5, #+12]
   \   00000054   808FC0E3           BIC      R8,R0,#0x200
   1925              }
   1926          
   1927              if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
   \                     ??add_item_to_object_2:
   \   00000058   0C0095E5           LDR      R0,[R5, #+12]
   \   0000005C   800F10E3           TST      R0,#0x200
   \   00000060   0400001A           BNE      ??add_item_to_object_3
   \   00000064   200095E5           LDR      R0,[R5, #+32]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   0100000A           BEQ      ??add_item_to_object_3
   1928              {
   1929                  hooks->deallocate(item->string);
   \   00000070   041096E5           LDR      R1,[R6, #+4]
   \   00000074   31FF2FE1           BLX      R1
   1930              }
   1931          
   1932              item->string = new_key;
   \                     ??add_item_to_object_3:
   \   00000078   207085E5           STR      R7,[R5, #+32]
   1933              item->type = new_type;
   \   0000007C   0C8085E5           STR      R8,[R5, #+12]
   1934          
   1935              return add_item_to_array(object, item);
   \   00000080   0510A0E1           MOV      R1,R5
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       add_item_to_array
   \   0000008C   F081BDE8           POP      {R4-R8,PC}       ;; return
   1936          }
   1937          

   \                                 In segment CODE, align 4, keep-with-next
   1938          CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
   1939          {
   \                     cJSON_AddItemToObject:
   \   00000000   00402DE9           PUSH     {LR}
   1940              add_item_to_object(object, string, item, &global_hooks, false);
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   ........           B        ?Subroutine118
   1941          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine118:
   \   00000000   08002DE9           PUSH     {R3}
   \   00000004   ........           LDR      R3,??DataTable29  ;; global_hooks
   \   00000008   ........           BL       add_item_to_object
   \   0000000C   0180BDE8           POP      {R0,PC}          ;; return
   1942          
   1943          /* Add an item to an object with constant string as key */

   \                                 In segment CODE, align 4, keep-with-next
   1944          CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
   1945          {
   \                     cJSON_AddItemToObjectCS:
   \   00000000   00402DE9           PUSH     {LR}
   1946              add_item_to_object(object, string, item, &global_hooks, true);
   \   00000004   0130A0E3           MOV      R3,#+1
   \   00000008                      REQUIRE ?Subroutine118
   \   00000008                      ;; // Fall through to label ?Subroutine118
   1947          }
   1948          

   \                                 In segment CODE, align 4, keep-with-next
   1949          CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
   1950          {
   \                     cJSON_AddItemReferenceToArray:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0100A0E1           MOV      R0,R1
   1951              if (array == NULL)
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   1080BD08           POPEQ    {R4,PC}
   1952              {
   1953                  return;
   1954              }
   1955          
   1956              add_item_to_array(array, create_reference(item, &global_hooks));
   \   00000014   ........           LDR      R1,??DataTable29  ;; global_hooks
   \   00000018   ........           BL       create_reference
   \   0000001C   0010A0E1           MOV      R1,R0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       add_item_to_array
   1957          }
   \   00000028   1080BDE8           POP      {R4,PC}          ;; return
   1958          

   \                                 In segment CODE, align 4, keep-with-next
   1959          CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
   1960          {
   \                     cJSON_AddItemReferenceToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0200A0E1           MOV      R0,R2
   1961              if ((object == NULL) || (string == NULL))
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   00005513           CMPNE    R5,#+0
   \   00000018   7080BD08           POPEQ    {R4-R6,PC}
   1962              {
   1963                  return;
   1964              }
   1965          
   1966              add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
   \   0000001C   ........           LDR      R6,??DataTable29  ;; global_hooks
   \   00000020   0610A0E1           MOV      R1,R6
   \   00000024   ........           BL       create_reference
   \   00000028   0020A0E1           MOV      R2,R0
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   01002DE9           PUSH     {R0}
   \   00000034   0630A0E1           MOV      R3,R6
   \   00000038   0510A0E1           MOV      R1,R5
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       add_item_to_object
   1967          }
   \   00000044   04D08DE2           ADD      SP,SP,#+4
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1968          

   \                                 In segment CODE, align 4, keep-with-next
   1969          CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
   1970          {
   \                     cJSON_AddNullToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1971              cJSON *null = cJSON_CreateNull();
   \   0000000C   ........           BL       cJSON_CreateNull
   1972              if (add_item_to_object(object, name, null, &global_hooks, false))
   \   00000010   ........           B        ?Subroutine107
   1973              {
   1974                  return null;
   1975              }
   1976          
   1977              cJSON_Delete(null);
   1978              return NULL;
   1979          }
   1980          

   \                                 In segment CODE, align 4, keep-with-next
   1981          CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
   1982          {
   \                     cJSON_AddTrueToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1983              cJSON *true_item = cJSON_CreateTrue();
   \   0000000C   ........           BL       cJSON_CreateTrue
   1984              if (add_item_to_object(object, name, true_item, &global_hooks, false))
   \   00000010                      REQUIRE ?Subroutine107
   \   00000010                      ;; // Fall through to label ?Subroutine107
   1985              {
   1986                  return true_item;
   1987              }
   1988          
   1989              cJSON_Delete(true_item);
   1990              return NULL;
   1991          }
   1992          

   \                                 In segment CODE, align 4, keep-with-next
   1993          CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
   1994          {
   \                     cJSON_AddFalseToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1995              cJSON *false_item = cJSON_CreateFalse();
   \   0000000C   ........           BL       cJSON_CreateFalse
   1996              if (add_item_to_object(object, name, false_item, &global_hooks, false))
   \   00000010   ........           B        ?Subroutine107
   1997              {
   1998                  return false_item;
   1999              }
   2000          
   2001              cJSON_Delete(false_item);
   2002              return NULL;
   2003          }
   2004          

   \                                 In segment CODE, align 4, keep-with-next
   2005          CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
   2006          {
   \                     cJSON_AddBoolToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0200A0E1           MOV      R0,R2
   2007              cJSON *bool_item = cJSON_CreateBool(boolean);
   \   00000010   ........           BL       cJSON_CreateBool
   2008              if (add_item_to_object(object, name, bool_item, &global_hooks, false))
   \   00000014   ........           B        ?Subroutine107
   2009              {
   2010                  return bool_item;
   2011              }
   2012          
   2013              cJSON_Delete(bool_item);
   2014              return NULL;
   2015          }
   2016          

   \                                 In segment CODE, align 4, keep-with-next
   2017          CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
   2018          {
   \                     cJSON_AddNumberToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   2019              cJSON *number_item = cJSON_CreateNumber(number);
   \   0000000C   0200A0E1           MOV      R0,R2
   \   00000010   0310A0E1           MOV      R1,R3
   \   00000014   ........           BL       cJSON_CreateNumber
   2020              if (add_item_to_object(object, name, number_item, &global_hooks, false))
   \   00000018   ........           B        ?Subroutine107
   2021              {
   2022                  return number_item;
   2023              }
   2024          
   2025              cJSON_Delete(number_item);
   2026              return NULL;
   2027          }
   2028          

   \                                 In segment CODE, align 4, keep-with-next
   2029          CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
   2030          {
   \                     cJSON_AddStringToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0200A0E1           MOV      R0,R2
   2031              cJSON *string_item = cJSON_CreateString(string);
   \   00000010   ........           BL       cJSON_CreateString
   2032              if (add_item_to_object(object, name, string_item, &global_hooks, false))
   \   00000014   ........           B        ?Subroutine107
   2033              {
   2034                  return string_item;
   2035              }
   2036          
   2037              cJSON_Delete(string_item);
   2038              return NULL;
   2039          }
   2040          

   \                                 In segment CODE, align 4, keep-with-next
   2041          CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
   2042          {
   \                     cJSON_AddRawToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0200A0E1           MOV      R0,R2
   2043              cJSON *raw_item = cJSON_CreateRaw(raw);
   \   00000010   ........           BL       cJSON_CreateRaw
   2044              if (add_item_to_object(object, name, raw_item, &global_hooks, false))
   \   00000014   ........           B        ?Subroutine107
   2045              {
   2046                  return raw_item;
   2047              }
   2048          
   2049              cJSON_Delete(raw_item);
   2050              return NULL;
   2051          }
   2052          

   \                                 In segment CODE, align 4, keep-with-next
   2053          CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
   2054          {
   \                     cJSON_AddObjectToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   2055              cJSON *object_item = cJSON_CreateObject();
   \   0000000C   ........           BL       cJSON_CreateObject
   2056              if (add_item_to_object(object, name, object_item, &global_hooks, false))
   \   00000010   ........           B        ?Subroutine107
   2057              {
   2058                  return object_item;
   2059              }
   2060          
   2061              cJSON_Delete(object_item);
   2062              return NULL;
   2063          }
   2064          

   \                                 In segment CODE, align 4, keep-with-next
   2065          CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
   2066          {
   \                     cJSON_AddArrayToObject:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   2067              cJSON *array = cJSON_CreateArray();
   \   0000000C   ........           BL       cJSON_CreateArray
   2068              if (add_item_to_object(object, name, array, &global_hooks, false))
   \   00000010   ........           B        ?Subroutine107
   2069              {
   2070                  return array;
   2071              }
   2072          
   2073              cJSON_Delete(array);
   2074              return NULL;
   2075          }
   2076          

   \                                 In segment CODE, align 4, keep-with-next
   2077          CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
   2078          {
   2079              if ((parent == NULL) || (item == NULL))
   \                     cJSON_DetachItemViaPointer:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1EFF2F01           BXEQ     LR
   \   00000008   000051E3           CMP      R1,#+0
   2080              {
   2081                  return NULL;
   \   0000000C   0000A003           MOVEQ    R0,#+0
   \   00000010   1EFF2F01           BXEQ     LR
   2082              }
   2083          
   2084              if (item->prev != NULL)
   \   00000014   042091E5           LDR      R2,[R1, #+4]
   \   00000018   000052E3           CMP      R2,#+0
   2085              {
   2086                  /* not the first element */
   2087                  item->prev->next = item->next;
   \   0000001C   00309115           LDRNE    R3,[R1, #+0]
   \   00000020   00308215           STRNE    R3,[R2, #+0]
   2088              }
   2089              if (item->next != NULL)
   \   00000024   002091E5           LDR      R2,[R1, #+0]
   \   00000028   000052E3           CMP      R2,#+0
   2090              {
   2091                  /* not the last element */
   2092                  item->next->prev = item->prev;
   \   0000002C   04309115           LDRNE    R3,[R1, #+4]
   \   00000030   04308215           STRNE    R3,[R2, #+4]
   2093              }
   2094          
   2095              if (item == parent->child)
   \   00000034   082090E5           LDR      R2,[R0, #+8]
   \   00000038   020051E1           CMP      R1,R2
   2096              {
   2097                  /* first element */
   2098                  parent->child = item->next;
   \   0000003C   00209105           LDREQ    R2,[R1, #+0]
   \   00000040   08208005           STREQ    R2,[R0, #+8]
   2099              }
   2100              /* make sure the detached item doesn't point anywhere anymore */
   2101              item->prev = NULL;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   040081E5           STR      R0,[R1, #+4]
   2102              item->next = NULL;
   \   0000004C   000081E5           STR      R0,[R1, #+0]
   2103          
   2104              return item;
   \   00000050   ........           B        ?Subroutine103
   2105          }
   2106          

   \                                 In segment CODE, align 4, keep-with-next
   2107          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
   2108          {
   \                     cJSON_DetachItemFromArray:
   \   00000000   10402DE9           PUSH     {R4,LR}
   2109              if (which < 0)
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0040A0E1           MOV      R4,R0
   2110              {
   2111                  return NULL;
   \   0000000C   0000A043           MOVMI    R0,#+0
   \   00000010   1080BD48           POPMI    {R4,PC}
   2112              }
   2113          
   2114              return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
   \   00000014   ........           BL       get_array_item
   \   00000018   ........           B        ?Subroutine119
   2115          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine119:
   \   00000000   0010A0E1           MOV      R1,R0
   \   00000004   0400A0E1           MOV      R0,R4
   \   00000008   1040BDE8           POP      {R4,LR}          ;; Pop
   \   0000000C   ........           B        cJSON_DetachItemViaPointer  ;; tailcall
   2116          

   \                                 In segment CODE, align 4, keep-with-next
   2117          CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
   2118          {
   \                     cJSON_DeleteItemFromArray:
   \   00000000   00402DE9           PUSH     {LR}
   2119              cJSON_Delete(cJSON_DetachItemFromArray(array, which));
   \   00000004   ........           BL       cJSON_DetachItemFromArray
   \   00000008   ........           B        ?Subroutine120
   2120          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine120:
   \   00000000   0040BDE8           POP      {LR}             ;; Pop
   \   00000004   ........           B        cJSON_Delete     ;; tailcall
   2121          

   \                                 In segment CODE, align 4, keep-with-next
   2122          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
   2123          {
   \                     cJSON_DetachItemFromObject:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2124              cJSON *to_detach = cJSON_GetObjectItem(object, string);
   \   00000008   ........           BL       cJSON_GetObjectItem
   2125          
   2126              return cJSON_DetachItemViaPointer(object, to_detach);
   \   0000000C                      REQUIRE ?Subroutine119
   \   0000000C                      ;; // Fall through to label ?Subroutine119
   2127          }
   2128          

   \                                 In segment CODE, align 4, keep-with-next
   2129          CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
   2130          {
   \                     cJSON_DetachItemFromObjectCaseSensitive:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2131              cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
   \   00000008   ........           BL       cJSON_GetObjectItemCaseSensitive
   2132          
   2133              return cJSON_DetachItemViaPointer(object, to_detach);
   \   0000000C   ........           B        ?Subroutine119
   2134          }
   2135          

   \                                 In segment CODE, align 4, keep-with-next
   2136          CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
   2137          {
   \                     cJSON_DeleteItemFromObject:
   \   00000000   00402DE9           PUSH     {LR}
   2138              cJSON_Delete(cJSON_DetachItemFromObject(object, string));
   \   00000004   ........           BL       cJSON_DetachItemFromObject
   2139          }
   \   00000008                      REQUIRE ?Subroutine120
   \   00000008                      ;; // Fall through to label ?Subroutine120
   2140          

   \                                 In segment CODE, align 4, keep-with-next
   2141          CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
   2142          {
   \                     cJSON_DeleteItemFromObjectCaseSensitive:
   \   00000000   00402DE9           PUSH     {LR}
   2143              cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
   \   00000004   ........           BL       cJSON_DetachItemFromObjectCaseSensitive
   \   00000008   ........           B        ?Subroutine120
   2144          }
   2145          
   2146          /* Replace array/object items with new ones. */

   \                                 In segment CODE, align 4, keep-with-next
   2147          CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
   2148          {
   \                     cJSON_InsertItemInArray:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   2149              cJSON *after_inserted = NULL;
   2150          
   2151              if (which < 0)
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   3080BD48           POPMI    {R4,R5,PC}
   2152              {
   2153                  return;
   2154              }
   2155          
   2156              after_inserted = get_array_item(array, (size_t)which);
   \   00000014   ........           BL       get_array_item
   2157              if (after_inserted == NULL)
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0300001A           BNE      ??cJSON_InsertItemInArray_0
   2158              {
   2159                  add_item_to_array(array, newitem);
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   3040BDE8           POP      {R4,R5,LR}       ;; Pop
   \   0000002C   ........           B        add_item_to_array  ;; tailcall
   2160                  return;
   2161              }
   2162          
   2163              newitem->next = after_inserted;
   \                     ??cJSON_InsertItemInArray_0:
   \   00000030   000085E5           STR      R0,[R5, #+0]
   2164              newitem->prev = after_inserted->prev;
   \   00000034   041090E5           LDR      R1,[R0, #+4]
   \   00000038   041085E5           STR      R1,[R5, #+4]
   2165              after_inserted->prev = newitem;
   \   0000003C   045080E5           STR      R5,[R0, #+4]
   2166              if (after_inserted == array->child)
   \   00000040   081094E5           LDR      R1,[R4, #+8]
   \   00000044   010050E1           CMP      R0,R1
   2167              {
   2168                  array->child = newitem;
   \   00000048   08508405           STREQ    R5,[R4, #+8]
   \   0000004C   3080BD08           POPEQ    {R4,R5,PC}
   2169              }
   2170              else
   2171              {
   2172                  newitem->prev->next = newitem;
   \   00000050   040095E5           LDR      R0,[R5, #+4]
   \   00000054   005080E5           STR      R5,[R0, #+0]
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
   2173              }
   2174          }
   2175          

   \                                 In segment CODE, align 4, keep-with-next
   2176          CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
   2177          {
   \                     cJSON_ReplaceItemViaPointer:
   \   00000000   00402DE9           PUSH     {LR}
   2178              if ((parent == NULL) || (replacement == NULL) || (item == NULL))
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0080BD08           POPEQ    {PC}
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   00005113           CMPNE    R1,#+0
   2179              {
   2180                  return false;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   0080BD08           POPEQ    {PC}
   2181              }
   2182          
   2183              if (replacement == item)
   \   0000001C   010052E1           CMP      R2,R1
   \   00000020   0000001A           BNE      ??cJSON_ReplaceItemViaPointer_0
   2184              {
   2185                  return true;
   \                     ??cJSON_ReplaceItemViaPointer_1:
   \   00000024   ........           B        ?Subroutine105
   2186              }
   2187          
   2188              replacement->next = item->next;
   \                     ??cJSON_ReplaceItemViaPointer_0:
   \   00000028   003091E5           LDR      R3,[R1, #+0]
   \   0000002C   003082E5           STR      R3,[R2, #+0]
   2189              replacement->prev = item->prev;
   \   00000030   04C091E5           LDR      R12,[R1, #+4]
   2190          
   2191              if (replacement->next != NULL)
   \   00000034   000053E3           CMP      R3,#+0
   \   00000038   04C082E5           STR      R12,[R2, #+4]
   2192              {
   2193                  replacement->next->prev = replacement;
   \   0000003C   04208315           STRNE    R2,[R3, #+4]
   2194              }
   2195              if (replacement->prev != NULL)
   \   00000040   043092E5           LDR      R3,[R2, #+4]
   \   00000044   000053E3           CMP      R3,#+0
   2196              {
   2197                  replacement->prev->next = replacement;
   \   00000048   00208315           STRNE    R2,[R3, #+0]
   2198              }
   2199              if (parent->child == item)
   \   0000004C   083090E5           LDR      R3,[R0, #+8]
   \   00000050   010053E1           CMP      R3,R1
   2200              {
   2201                  parent->child = replacement;
   \   00000054   08208005           STREQ    R2,[R0, #+8]
   2202              }
   2203          
   2204              item->next = NULL;
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   000081E5           STR      R0,[R1, #+0]
   2205              item->prev = NULL;
   \   00000060   040081E5           STR      R0,[R1, #+4]
   2206              cJSON_Delete(item);
   \   00000064   0100A0E1           MOV      R0,R1
   \   00000068   ........           BL       cJSON_Delete
   \   0000006C   ECFFFFEA           B        ??cJSON_ReplaceItemViaPointer_1
   2207          
   2208              return true;
   2209          }
   2210          

   \                                 In segment CODE, align 4, keep-with-next
   2211          CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
   2212          {
   \                     cJSON_ReplaceItemInArray:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   2213              if (which < 0)
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   3080BD48           POPMI    {R4,R5,PC}
   2214              {
   2215                  return;
   2216              }
   2217          
   2218              cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
   \   00000014   ........           BL       get_array_item
   \   00000018   0520A0E1           MOV      R2,R5
   \   0000001C   0010A0E1           MOV      R1,R0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       cJSON_ReplaceItemViaPointer
   2219          }
   \   00000028   3080BDE8           POP      {R4,R5,PC}       ;; return
   2220          

   \                                 In segment CODE, align 4, keep-with-next
   2221          static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
   2222          {
   \                     replace_item_in_object:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   2223              if ((replacement == NULL) || (string == NULL))
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   00005513           CMPNE    R5,#+0
   2224              {
   2225                  return false;
   \   0000001C   0000A003           MOVEQ    R0,#+0
   \   00000020   F080BD08           POPEQ    {R4-R7,PC}
   2226              }
   2227          
   2228              /* replace the name in the replacement */
   2229              if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
   \   00000024   0C0096E5           LDR      R0,[R6, #+12]
   \   00000028   800F10E3           TST      R0,#0x200
   \   0000002C   0300001A           BNE      ??replace_item_in_object_0
   \   00000030   200096E5           LDR      R0,[R6, #+32]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0000000A           BEQ      ??replace_item_in_object_0
   2230              {
   2231                  cJSON_free(replacement->string);
   \   0000003C   ........           BL       cJSON_free
   2232              }
   2233              replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
   \                     ??replace_item_in_object_0:
   \   00000040   ........           LDR      R1,??DataTable29  ;; global_hooks
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   ........           BL       cJSON_strdup
   \   0000004C   200086E5           STR      R0,[R6, #+32]
   2234              replacement->type &= ~cJSON_StringIsConst;
   \   00000050   0C0096E5           LDR      R0,[R6, #+12]
   2235          
   2236              cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
   \   00000054   0720A0E1           MOV      R2,R7
   \   00000058   800FC0E3           BIC      R0,R0,#0x200
   \   0000005C   0C0086E5           STR      R0,[R6, #+12]
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       get_object_item
   \   0000006C   0010A0E1           MOV      R1,R0
   \   00000070   0620A0E1           MOV      R2,R6
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       cJSON_ReplaceItemViaPointer
   2237          
   2238              return true;
   \   0000007C   ........           B        ??Subroutine109_0
   2239          }
   2240          

   \                                 In segment CODE, align 4, keep-with-next
   2241          CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
   2242          {
   2243              replace_item_in_object(object, string, newitem, false);
   \                     cJSON_ReplaceItemInObject:
   \   00000000   0030A0E3           MOV      R3,#+0
   \   00000004   ........           B        replace_item_in_object  ;; tailcall
   2244          }
   2245          

   \                                 In segment CODE, align 4, keep-with-next
   2246          CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
   2247          {
   2248              replace_item_in_object(object, string, newitem, true);
   \                     cJSON_ReplaceItemInObjectCaseSensitive:
   \   00000000   0130A0E3           MOV      R3,#+1
   \   00000004   ........           B        replace_item_in_object  ;; tailcall
   2249          }
   2250          
   2251          /* Create basic types: */

   \                                 In segment CODE, align 4, keep-with-next
   2252          CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
   2253          {
   2254              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateNull:
   \   00000000   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2255              if(item)
   \   0000000C   000050E3           CMP      R0,#+0
   2256              {
   2257                  item->type = cJSON_NULL;
   \   00000010   0410A013           MOVNE    R1,#+4
   \   00000014   ........           B        ?Subroutine106
   2258              }
   2259          
   2260              return item;
   2261          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine106:
   \   00000000   0C108015           STRNE    R1,[R0, #+12]
   \   00000004   0080BDE8           POP      {PC}             ;; return
   2262          

   \                                 In segment CODE, align 4, keep-with-next
   2263          CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
   2264          {
   2265              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateTrue:
   \   00000000   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2266              if(item)
   \   0000000C   000050E3           CMP      R0,#+0
   2267              {
   2268                  item->type = cJSON_True;
   \   00000010   0210A013           MOVNE    R1,#+2
   \   00000014                      REQUIRE ?Subroutine106
   \   00000014                      ;; // Fall through to label ?Subroutine106
   2269              }
   2270          
   2271              return item;
   2272          }
   2273          

   \                                 In segment CODE, align 4, keep-with-next
   2274          CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
   2275          {
   2276              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateFalse:
   \   00000000   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2277              if(item)
   \   0000000C   000050E3           CMP      R0,#+0
   2278              {
   2279                  item->type = cJSON_False;
   \   00000010   0110A013           MOVNE    R1,#+1
   \   00000014   ........           B        ?Subroutine106
   2280              }
   2281          
   2282              return item;
   2283          }
   2284          

   \                                 In segment CODE, align 4, keep-with-next
   2285          CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool b)
   2286          {
   \                     cJSON_CreateBool:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2287              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   0000000C   ........           BL       cJSON_New_Item
   2288              if(item)
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1080BD08           POPEQ    {R4,PC}
   2289              {
   2290                  item->type = b ? cJSON_True : cJSON_False;
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   0210A013           MOVNE    R1,#+2
   \   00000020   0110A003           MOVEQ    R1,#+1
   \   00000024   0C1080E5           STR      R1,[R0, #+12]
   2291              }
   2292          
   2293              return item;
   \   00000028   1080BDE8           POP      {R4,PC}          ;; return
   2294          }
   2295          

   \                                 In segment CODE, align 4, keep-with-next
   2296          CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
   2297          {
   \                     cJSON_CreateNumber:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2298              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   ........           BL       cJSON_New_Item
   \   00000014   0060B0E1           MOVS     R6,R0
   2299              if(item)
   \   00000018   1A00000A           BEQ      ??cJSON_CreateNumber_0
   2300              {
   2301                  item->type = cJSON_Number;
   \   0000001C   0800A0E3           MOV      R0,#+8
   \   00000020   0C0086E5           STR      R0,[R6, #+12]
   2302                  item->valuedouble = num;
   \   00000024   184086E5           STR      R4,[R6, #+24]
   \   00000028   1C5086E5           STR      R5,[R6, #+28]
   2303          
   2304                  /* use saturation in case of overflow */
   2305                  if (num >= INT_MAX)
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   C024A0E3           MOV      R2,#-1073741824
   \   00000038   FF2582E3           ORR      R2,R2,#0x3FC00000
   \   0000003C   B034E0E3           MVN      R3,#-1342177280
   \   00000040   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000044   ........           _BLF     __dGreaterEqual,??__dGreaterEqual??rA
   \   00000048   000050E3           CMP      R0,#+0
   2306                  {
   2307                      item->valueint = INT_MAX;
   \   0000004C   8004E013           MVNNE    R0,#-2147483648
   \   00000050   0B00001A           BNE      ??cJSON_CreateNumber_1
   2308                  }
   2309                  else if (num <= (double)INT_MIN)
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   0510A0E1           MOV      R1,R5
   \   0000005C   0120E0E3           MVN      R2,#+1
   \   00000060   C035E0E3           MVN      R3,#+805306368
   \   00000064   E236C3E3           BIC      R3,R3,#0xE200000
   \   00000068   ........           _BLF     __dLess,??__dLess??rA
   \   0000006C   000050E3           CMP      R0,#+0
   2310                  {
   2311                      item->valueint = INT_MIN;
   \   00000070   8004A013           MOVNE    R0,#-2147483648
   \   00000074   0200001A           BNE      ??cJSON_CreateNumber_1
   2312                  }
   2313                  else
   2314                  {
   2315                      item->valueint = (int)num;
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   0510A0E1           MOV      R1,R5
   \   00000080   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \                     ??cJSON_CreateNumber_1:
   \   00000084   140086E5           STR      R0,[R6, #+20]
   2316                  }
   2317              }
   2318          
   2319              return item;
   \                     ??cJSON_CreateNumber_0:
   \   00000088   ........           B        ?Subroutine108
   2320          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine108:
   \   00000000   0600A0E1           MOV      R0,R6
   \   00000004   7080BDE8           POP      {R4-R6,PC}       ;; return
   2321          

   \                                 In segment CODE, align 4, keep-with-next
   2322          CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
   2323          {
   \                     cJSON_CreateString:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   2324              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000004   ........           LDR      R5,??DataTable29  ;; global_hooks
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           BL       cJSON_New_Item
   \   00000014   0060B0E1           MOVS     R6,R0
   2325              if(item)
   \   00000018   0900000A           BEQ      ??cJSON_CreateString_0
   2326              {
   2327                  item->type = cJSON_String;
   \   0000001C   1000A0E3           MOV      R0,#+16
   \   00000020   0C0086E5           STR      R0,[R6, #+12]
   2328                  item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       cJSON_strdup
   \   00000030   100086E5           STR      R0,[R6, #+16]
   2329                  if(!item->valuestring)
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0100001A           BNE      ??cJSON_CreateString_0
   2330                  {
   2331                      cJSON_Delete(item);
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   ........           B        ??Subroutine107_0
   2332                      return NULL;
   2333                  }
   2334              }
   2335          
   2336              return item;
   \                     ??cJSON_CreateString_0:
   \   00000044                      REQUIRE ?Subroutine108
   \   00000044                      ;; // Fall through to label ?Subroutine108
   2337          }
   2338          

   \                                 In segment CODE, align 4, keep-with-next
   2339          CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
   2340          {
   \                     cJSON_CreateStringReference:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2341              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   0000000C   ........           BL       cJSON_New_Item
   2342              if (item != NULL)
   \   00000010   000050E3           CMP      R0,#+0
   2343              {
   2344                  item->type = cJSON_String | cJSON_IsReference;
   \   00000014   441FA013           MOVNE    R1,#+272
   \   00000018   0C108015           STRNE    R1,[R0, #+12]
   2345                  item->valuestring = (char*)cast_away_const(string);
   \   0000001C   10408015           STRNE    R4,[R0, #+16]
   2346              }
   2347          
   2348              return item;
   \   00000020   1080BDE8           POP      {R4,PC}          ;; return
   2349          }
   2350          

   \                                 In segment CODE, align 4, keep-with-next
   2351          CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
   2352          {
   \                     cJSON_CreateObjectReference:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2353              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   0000000C   ........           BL       cJSON_New_Item
   2354              if (item != NULL) {
   \   00000010   000050E3           CMP      R0,#+0
   2355                  item->type = cJSON_Object | cJSON_IsReference;
   \   00000014   501FA013           MOVNE    R1,#+320
   \   00000018   ........           B        ?Subroutine104
   2356                  item->child = (cJSON*)cast_away_const(child);
   2357              }
   2358          
   2359              return item;
   2360          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine104:
   \   00000000   0C108015           STRNE    R1,[R0, #+12]
   \   00000004   08408015           STRNE    R4,[R0, #+8]
   \   00000008   1080BDE8           POP      {R4,PC}          ;; return
   2361          

   \                                 In segment CODE, align 4, keep-with-next
   2362          CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
   \                     cJSON_CreateArrayReference:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   2363              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000008   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   0000000C   ........           BL       cJSON_New_Item
   2364              if (item != NULL) {
   \   00000010   000050E3           CMP      R0,#+0
   2365                  item->type = cJSON_Array | cJSON_IsReference;
   \   00000014   481FA013           MOVNE    R1,#+288
   \   00000018                      REQUIRE ?Subroutine104
   \   00000018                      ;; // Fall through to label ?Subroutine104
   2366                  item->child = (cJSON*)cast_away_const(child);
   2367              }
   2368          
   2369              return item;
   2370          }
   2371          

   \                                 In segment CODE, align 4, keep-with-next
   2372          CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
   2373          {
   \                     cJSON_CreateRaw:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   2374              cJSON *item = cJSON_New_Item(&global_hooks);
   \   00000004   ........           LDR      R5,??DataTable29  ;; global_hooks
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           BL       cJSON_New_Item
   \   00000014   0060B0E1           MOVS     R6,R0
   2375              if(item)
   \   00000018   0900000A           BEQ      ??cJSON_CreateRaw_0
   2376              {
   2377                  item->type = cJSON_Raw;
   \   0000001C   8000A0E3           MOV      R0,#+128
   \   00000020   0C0086E5           STR      R0,[R6, #+12]
   2378                  item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       cJSON_strdup
   \   00000030   100086E5           STR      R0,[R6, #+16]
   2379                  if(!item->valuestring)
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0100001A           BNE      ??cJSON_CreateRaw_0
   2380                  {
   2381                      cJSON_Delete(item);
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   ........           B        ??Subroutine107_0
   2382                      return NULL;
   2383                  }
   2384              }
   2385          
   2386              return item;
   \                     ??cJSON_CreateRaw_0:
   \   00000044   ........           B        ?Subroutine108
   2387          }
   2388          

   \                                 In segment CODE, align 4, keep-with-next
   2389          CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
   2390          {
   2391              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateArray:
   \   00000000   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2392              if(item)
   \   0000000C   000050E3           CMP      R0,#+0
   2393              {
   2394                  item->type=cJSON_Array;
   \   00000010   2010A013           MOVNE    R1,#+32
   \   00000014   ........           B        ?Subroutine106
   2395              }
   2396          
   2397              return item;
   2398          }
   2399          

   \                                 In segment CODE, align 4, keep-with-next
   2400          CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
   2401          {
   2402              cJSON *item = cJSON_New_Item(&global_hooks);
   \                     cJSON_CreateObject:
   \   00000000   ........           LDR      R0,??DataTable29  ;; global_hooks
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           BL       cJSON_New_Item
   2403              if (item)
   \   0000000C   000050E3           CMP      R0,#+0
   2404              {
   2405                  item->type = cJSON_Object;
   \   00000010   4010A013           MOVNE    R1,#+64
   \   00000014   ........           B        ?Subroutine106
   2406              }
   2407          
   2408              return item;
   2409          }
   2410          
   2411          /* Create Arrays: */

   \                                 In segment CODE, align 4, keep-with-next
   2412          CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
   2413          {
   \                     cJSON_CreateIntArray:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   2414              size_t i = 0;
   2415              cJSON *n = NULL;
   2416              cJSON *p = NULL;
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0070A0E3           MOV      R7,#+0
   2417              cJSON *a = NULL;
   2418          
   2419              if ((count < 0) || (numbers == NULL))
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   0100004A           BMI      ??cJSON_CreateIntArray_0
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0000001A           BNE      ??cJSON_CreateIntArray_1
   2420              {
   2421                  return NULL;
   \                     ??cJSON_CreateIntArray_0:
   \   00000024   ........           B        ?Subroutine117
   2422              }
   2423          
   2424              a = cJSON_CreateArray();
   \                     ??cJSON_CreateIntArray_1:
   \   00000028   ........           BL       cJSON_CreateArray
   \   0000002C   0080B0E1           MOVS     R8,R0
   2425              for(i = 0; a && (i < (size_t)count); i++)
   \   00000030   0500001A           BNE      ??cJSON_CreateIntArray_2
   2426              {
   2427                  n = cJSON_CreateNumber(numbers[i]);
   2428                  if (!n)
   2429                  {
   2430                      cJSON_Delete(a);
   2431                      return NULL;
   2432                  }
   2433                  if(!i)
   2434                  {
   2435                      a->child = n;
   2436                  }
   2437                  else
   2438                  {
   2439                      suffix_object(p, n);
   2440                  }
   2441                  p = n;
   2442              }
   2443          
   2444              return a;
   \                     ??cJSON_CreateIntArray_3:
   \   00000034   ........           B        ?Subroutine116
   \                     ??cJSON_CreateIntArray_4:
   \   00000038   0910A0E1           MOV      R1,R9
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       suffix_object
   \                     ??cJSON_CreateIntArray_5:
   \   00000044   0970A0E1           MOV      R7,R9
   \   00000048   014084E2           ADD      R4,R4,#+1
   \                     ??cJSON_CreateIntArray_2:
   \   0000004C   060054E1           CMP      R4,R6
   \   00000050   F7FFFF2A           BCS      ??cJSON_CreateIntArray_3
   \   00000054   040195E7           LDR      R0,[R5, +R4, LSL #+2]
   \   00000058   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   0000005C   ........           BL       cJSON_CreateNumber
   \   00000060   0090B0E1           MOVS     R9,R0
   \   00000064   0200001A           BNE      ??cJSON_CreateIntArray_6
   \   00000068   0800A0E1           MOV      R0,R8
   \   0000006C   ........           BL       cJSON_Delete
   \   00000070   EBFFFFEA           B        ??cJSON_CreateIntArray_0
   \                     ??cJSON_CreateIntArray_6:
   \   00000074   000054E3           CMP      R4,#+0
   \   00000078   EEFFFF1A           BNE      ??cJSON_CreateIntArray_4
   \   0000007C   089088E5           STR      R9,[R8, #+8]
   \   00000080   EFFFFFEA           B        ??cJSON_CreateIntArray_5
   2445          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine117:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   F083BDE8           POP      {R4-R9,PC}

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine116:
   \   00000000   0800A0E1           MOV      R0,R8
   \   00000004   F083BDE8           POP      {R4-R9,PC}       ;; return
   2446          

   \                                 In segment CODE, align 4, keep-with-next
   2447          CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
   2448          {
   \                     cJSON_CreateFloatArray:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   2449              size_t i = 0;
   2450              cJSON *n = NULL;
   2451              cJSON *p = NULL;
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0070A0E3           MOV      R7,#+0
   2452              cJSON *a = NULL;
   2453          
   2454              if ((count < 0) || (numbers == NULL))
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   0100004A           BMI      ??cJSON_CreateFloatArray_0
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0000001A           BNE      ??cJSON_CreateFloatArray_1
   2455              {
   2456                  return NULL;
   \                     ??cJSON_CreateFloatArray_0:
   \   00000024   ........           B        ?Subroutine117
   2457              }
   2458          
   2459              a = cJSON_CreateArray();
   \                     ??cJSON_CreateFloatArray_1:
   \   00000028   ........           BL       cJSON_CreateArray
   \   0000002C   0080B0E1           MOVS     R8,R0
   2460          
   2461              for(i = 0; a && (i < (size_t)count); i++)
   \   00000030   0500001A           BNE      ??cJSON_CreateFloatArray_2
   2462              {
   2463                  n = cJSON_CreateNumber((double)numbers[i]);
   2464                  if(!n)
   2465                  {
   2466                      cJSON_Delete(a);
   2467                      return NULL;
   2468                  }
   2469                  if(!i)
   2470                  {
   2471                      a->child = n;
   2472                  }
   2473                  else
   2474                  {
   2475                      suffix_object(p, n);
   2476                  }
   2477                  p = n;
   2478              }
   2479          
   2480              return a;
   \                     ??cJSON_CreateFloatArray_3:
   \   00000034   ........           B        ?Subroutine116
   \                     ??cJSON_CreateFloatArray_4:
   \   00000038   0910A0E1           MOV      R1,R9
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       suffix_object
   \                     ??cJSON_CreateFloatArray_5:
   \   00000044   0970A0E1           MOV      R7,R9
   \   00000048   014084E2           ADD      R4,R4,#+1
   \                     ??cJSON_CreateFloatArray_2:
   \   0000004C   060054E1           CMP      R4,R6
   \   00000050   F7FFFF2A           BCS      ??cJSON_CreateFloatArray_3
   \   00000054   040195E7           LDR      R0,[R5, +R4, LSL #+2]
   \   00000058   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   0000005C   ........           BL       cJSON_CreateNumber
   \   00000060   0090B0E1           MOVS     R9,R0
   \   00000064   0200001A           BNE      ??cJSON_CreateFloatArray_6
   \   00000068   0800A0E1           MOV      R0,R8
   \   0000006C   ........           BL       cJSON_Delete
   \   00000070   EBFFFFEA           B        ??cJSON_CreateFloatArray_0
   \                     ??cJSON_CreateFloatArray_6:
   \   00000074   000054E3           CMP      R4,#+0
   \   00000078   EEFFFF1A           BNE      ??cJSON_CreateFloatArray_4
   \   0000007C   089088E5           STR      R9,[R8, #+8]
   \   00000080   EFFFFFEA           B        ??cJSON_CreateFloatArray_5
   2481          }
   2482          

   \                                 In segment CODE, align 4, keep-with-next
   2483          CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
   2484          {
   \                     cJSON_CreateDoubleArray:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
   2485              size_t i = 0;
   2486              cJSON *n = NULL;
   2487              cJSON *p = NULL;
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0070A0E3           MOV      R7,#+0
   2488              cJSON *a = NULL;
   2489          
   2490              if ((count < 0) || (numbers == NULL))
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   0100004A           BMI      ??cJSON_CreateDoubleArray_0
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0000001A           BNE      ??cJSON_CreateDoubleArray_1
   2491              {
   2492                  return NULL;
   \                     ??cJSON_CreateDoubleArray_0:
   \   00000024   ........           B        ?Subroutine117
   2493              }
   2494          
   2495              a = cJSON_CreateArray();
   \                     ??cJSON_CreateDoubleArray_1:
   \   00000028   ........           BL       cJSON_CreateArray
   \   0000002C   0080B0E1           MOVS     R8,R0
   2496          
   2497              for(i = 0;a && (i < (size_t)count); i++)
   \   00000030   0500001A           BNE      ??cJSON_CreateDoubleArray_2
   2498              {
   2499                  n = cJSON_CreateNumber(numbers[i]);
   2500                  if(!n)
   2501                  {
   2502                      cJSON_Delete(a);
   2503                      return NULL;
   2504                  }
   2505                  if(!i)
   2506                  {
   2507                      a->child = n;
   2508                  }
   2509                  else
   2510                  {
   2511                      suffix_object(p, n);
   2512                  }
   2513                  p = n;
   2514              }
   2515          
   2516              return a;
   \                     ??cJSON_CreateDoubleArray_3:
   \   00000034   ........           B        ?Subroutine116
   \                     ??cJSON_CreateDoubleArray_4:
   \   00000038   0910A0E1           MOV      R1,R9
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       suffix_object
   \                     ??cJSON_CreateDoubleArray_5:
   \   00000044   0970A0E1           MOV      R7,R9
   \   00000048   014084E2           ADD      R4,R4,#+1
   \                     ??cJSON_CreateDoubleArray_2:
   \   0000004C   060054E1           CMP      R4,R6
   \   00000050   F7FFFF2A           BCS      ??cJSON_CreateDoubleArray_3
   \   00000054   840185E0           ADD      R0,R5,R4, LSL #+3
   \   00000058   030090E8           LDM      R0,{R0,R1}
   \   0000005C   ........           BL       cJSON_CreateNumber
   \   00000060   0090B0E1           MOVS     R9,R0
   \   00000064   0200001A           BNE      ??cJSON_CreateDoubleArray_6
   \   00000068   0800A0E1           MOV      R0,R8
   \   0000006C   ........           BL       cJSON_Delete
   \   00000070   EBFFFFEA           B        ??cJSON_CreateDoubleArray_0
   \                     ??cJSON_CreateDoubleArray_6:
   \   00000074   000054E3           CMP      R4,#+0
   \   00000078   EEFFFF1A           BNE      ??cJSON_CreateDoubleArray_4
   \   0000007C   089088E5           STR      R9,[R8, #+8]
   \   00000080   EFFFFFEA           B        ??cJSON_CreateDoubleArray_5
   2517          }
   2518          

   \                                 In segment CODE, align 4, keep-with-next
   2519          CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
   2520          {
   \                     cJSON_CreateStringArray:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   2521              size_t i = 0;
   2522              cJSON *n = NULL;
   2523              cJSON *p = NULL;
   \   0000000C   0060A0E3           MOV      R6,#+0
   \   00000010   0070A0E3           MOV      R7,#+0
   2524              cJSON *a = NULL;
   2525          
   2526              if ((count < 0) || (strings == NULL))
   \   00000014   000055E3           CMP      R5,#+0
   \   00000018   0100004A           BMI      ??cJSON_CreateStringArray_0
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   0000001A           BNE      ??cJSON_CreateStringArray_1
   2527              {
   2528                  return NULL;
   \                     ??cJSON_CreateStringArray_0:
   \   00000024   ........           B        ?Subroutine117
   2529              }
   2530          
   2531              a = cJSON_CreateArray();
   \                     ??cJSON_CreateStringArray_1:
   \   00000028   ........           BL       cJSON_CreateArray
   \   0000002C   0080B0E1           MOVS     R8,R0
   2532          
   2533              for (i = 0; a && (i < (size_t)count); i++)
   \   00000030   0500001A           BNE      ??cJSON_CreateStringArray_2
   2534              {
   2535                  n = cJSON_CreateString(strings[i]);
   2536                  if(!n)
   2537                  {
   2538                      cJSON_Delete(a);
   2539                      return NULL;
   2540                  }
   2541                  if(!i)
   2542                  {
   2543                      a->child = n;
   2544                  }
   2545                  else
   2546                  {
   2547                      suffix_object(p,n);
   2548                  }
   2549                  p = n;
   2550              }
   2551          
   2552              return a;
   \                     ??cJSON_CreateStringArray_3:
   \   00000034   ........           B        ?Subroutine116
   \                     ??cJSON_CreateStringArray_4:
   \   00000038   0910A0E1           MOV      R1,R9
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       suffix_object
   \                     ??cJSON_CreateStringArray_5:
   \   00000044   0970A0E1           MOV      R7,R9
   \   00000048   016086E2           ADD      R6,R6,#+1
   \                     ??cJSON_CreateStringArray_2:
   \   0000004C   050056E1           CMP      R6,R5
   \   00000050   F7FFFF2A           BCS      ??cJSON_CreateStringArray_3
   \   00000054   060194E7           LDR      R0,[R4, +R6, LSL #+2]
   \   00000058   ........           BL       cJSON_CreateString
   \   0000005C   0090B0E1           MOVS     R9,R0
   \   00000060   0200001A           BNE      ??cJSON_CreateStringArray_6
   \   00000064   0800A0E1           MOV      R0,R8
   \   00000068   ........           BL       cJSON_Delete
   \   0000006C   ECFFFFEA           B        ??cJSON_CreateStringArray_0
   \                     ??cJSON_CreateStringArray_6:
   \   00000070   000056E3           CMP      R6,#+0
   \   00000074   EFFFFF1A           BNE      ??cJSON_CreateStringArray_4
   \   00000078   089088E5           STR      R9,[R8, #+8]
   \   0000007C   F0FFFFEA           B        ??cJSON_CreateStringArray_5
   2553          }
   2554          
   2555          /* Duplication */

   \                                 In segment CODE, align 4, keep-with-next
   2556          CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
   2557          {
   \                     cJSON_Duplicate:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0060A0E1           MOV      R6,R0
   \   00000008   0170A0E1           MOV      R7,R1
   2558              cJSON *newitem = NULL;
   2559              cJSON *child = NULL;
   2560              cJSON *next = NULL;
   \   0000000C   0040A0E3           MOV      R4,#+0
   2561              cJSON *newchild = NULL;
   2562          
   2563              /* Bail on bad ptr */
   2564              if (!item)
   \   00000010   000056E3           CMP      R6,#+0
   \   00000014   3500000A           BEQ      ??cJSON_Duplicate_0
   2565              {
   2566                  goto fail;
   2567              }
   2568              /* Create new item */
   2569              newitem = cJSON_New_Item(&global_hooks);
   \   00000018   ........           LDR      R8,??DataTable29  ;; global_hooks
   \   0000001C   0800A0E1           MOV      R0,R8
   \   00000020   ........           BL       cJSON_New_Item
   \   00000024   0050B0E1           MOVS     R5,R0
   2570              if (!newitem)
   \   00000028   3000000A           BEQ      ??cJSON_Duplicate_0
   2571              {
   2572                  goto fail;
   2573              }
   2574              /* Copy over all vars */
   2575              newitem->type = item->type & (~cJSON_IsReference);
   \   0000002C   0C0096E5           LDR      R0,[R6, #+12]
   \   00000030   400FC0E3           BIC      R0,R0,#0x100
   \   00000034   0C0085E5           STR      R0,[R5, #+12]
   2576              newitem->valueint = item->valueint;
   \   00000038   140096E5           LDR      R0,[R6, #+20]
   \   0000003C   140085E5           STR      R0,[R5, #+20]
   2577              newitem->valuedouble = item->valuedouble;
   \   00000040   180096E5           LDR      R0,[R6, #+24]
   \   00000044   1C1096E5           LDR      R1,[R6, #+28]
   \   00000048   180085E5           STR      R0,[R5, #+24]
   \   0000004C   1C1085E5           STR      R1,[R5, #+28]
   2578              if (item->valuestring)
   \   00000050   100096E5           LDR      R0,[R6, #+16]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0400000A           BEQ      ??cJSON_Duplicate_1
   2579              {
   2580                  newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
   \   0000005C   0810A0E1           MOV      R1,R8
   \   00000060   ........           BL       cJSON_strdup
   \   00000064   100085E5           STR      R0,[R5, #+16]
   2581                  if (!newitem->valuestring)
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   1D00000A           BEQ      ??cJSON_Duplicate_2
   2582                  {
   2583                      goto fail;
   2584                  }
   2585              }
   2586              if (item->string)
   \                     ??cJSON_Duplicate_1:
   \   00000070   200096E5           LDR      R0,[R6, #+32]
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0700000A           BEQ      ??cJSON_Duplicate_3
   2587              {
   2588                  newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
   \   0000007C   0C1096E5           LDR      R1,[R6, #+12]
   \   00000080   800F11E3           TST      R1,#0x200
   \   00000084   0100001A           BNE      ??cJSON_Duplicate_4
   \   00000088   0810A0E1           MOV      R1,R8
   \   0000008C   ........           BL       cJSON_strdup
   \                     ??cJSON_Duplicate_4:
   \   00000090   200085E5           STR      R0,[R5, #+32]
   2589                  if (!newitem->string)
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   1200000A           BEQ      ??cJSON_Duplicate_2
   2590                  {
   2591                      goto fail;
   2592                  }
   2593              }
   2594              /* If non-recursive, then we're done! */
   2595              if (!recurse)
   \                     ??cJSON_Duplicate_3:
   \   0000009C   000057E3           CMP      R7,#+0
   \   000000A0   0000001A           BNE      ??cJSON_Duplicate_5
   2596              {
   2597                  return newitem;
   \                     ??cJSON_Duplicate_6:
   \   000000A4   ........           B        ?Subroutine114
   2598              }
   2599              /* Walk the ->next chain for the child. */
   2600              child = item->child;
   \                     ??cJSON_Duplicate_5:
   \   000000A8   086096E5           LDR      R6,[R6, #+8]
   \   000000AC   010000EA           B        ??cJSON_Duplicate_7
   2601              while (child != NULL)
   2602              {
   2603                  newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
   2604                  if (!newchild)
   2605                  {
   2606                      goto fail;
   2607                  }
   2608                  if (next != NULL)
   2609                  {
   2610                      /* If newitem->child already set, then crosswire ->prev and ->next and move on */
   2611                      next->next = newchild;
   2612                      newchild->prev = next;
   2613                      next = newchild;
   2614                  }
   2615                  else
   2616                  {
   2617                      /* Set newitem->child and move to it */
   2618                      newitem->child = newchild;
   2619                      next = newchild;
   2620                  }
   2621                  child = child->next;
   \                     ??cJSON_Duplicate_8:
   \   000000B0   006096E5           LDR      R6,[R6, #+0]
   \   000000B4   0040A0E1           MOV      R4,R0
   \                     ??cJSON_Duplicate_7:
   \   000000B8   000056E3           CMP      R6,#+0
   \   000000BC   F8FFFF0A           BEQ      ??cJSON_Duplicate_6
   \   000000C0   0110A0E3           MOV      R1,#+1
   \   000000C4   0600A0E1           MOV      R0,R6
   \   000000C8   CCFFFFEB           BL       cJSON_Duplicate
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   0400000A           BEQ      ??cJSON_Duplicate_2
   \   000000D4   000054E3           CMP      R4,#+0
   \   000000D8   08008505           STREQ    R0,[R5, #+8]
   \   000000DC   00008415           STRNE    R0,[R4, #+0]
   \   000000E0   04408015           STRNE    R4,[R0, #+4]
   \   000000E4   F1FFFFEA           B        ??cJSON_Duplicate_8
   2622              }
   2623          
   2624              return newitem;
   2625          
   2626          fail:
   2627              if (newitem != NULL)
   2628              {
   2629                  cJSON_Delete(newitem);
   \                     ??cJSON_Duplicate_2:
   \   000000E8   0500A0E1           MOV      R0,R5
   \   000000EC   ........           BL       cJSON_Delete
   2630              }
   2631          
   2632              return NULL;
   \                     ??cJSON_Duplicate_0:
   \   000000F0   ........           B        ?Subroutine112
   2633          }
   2634          

   \                                 In segment CODE, align 4, keep-with-next
   2635          CJSON_PUBLIC(void) cJSON_Minify(char *json)
   2636          {
   2637              unsigned char *into = (unsigned char*)json;
   \                     cJSON_Minify:
   \   00000000   0010B0E1           MOVS     R1,R0
   2638          
   2639              if (json == NULL)
   \   00000004   0100001A           BNE      ??cJSON_Minify_0
   \   00000008   1EFF2FE1           BX       LR
   2640              {
   2641                  return;
   2642              }
   2643          
   2644              while (*json)
   2645              {
   2646                  if (*json == ' ')
   2647                  {
   2648                      json++;
   \                     ??cJSON_Minify_1:
   \   0000000C   010080E2           ADD      R0,R0,#+1
   2649                  }
   \                     ??cJSON_Minify_0:
   \   00000010   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   2F00000A           BEQ      ??cJSON_Minify_2
   \   0000001C   200052E3           CMP      R2,#+32
   2650                  else if (*json == '\t')
   \   00000020   09005213           CMPNE    R2,#+9
   2651                  {
   2652                      /* Whitespace characters. */
   2653                      json++;
   2654                  }
   2655                  else if (*json == '\r')
   \   00000024   0D005213           CMPNE    R2,#+13
   2656                  {
   2657                      json++;
   2658                  }
   2659                  else if (*json=='\n')
   \   00000028   0A005213           CMPNE    R2,#+10
   \   0000002C   F6FFFF0A           BEQ      ??cJSON_Minify_1
   2660                  {
   2661                      json++;
   2662                  }
   2663                  else if ((*json == '/') && (json[1] == '/'))
   \   00000030   2F0052E3           CMP      R2,#+47
   \   00000034   0120D005           LDRBEQ   R2,[R0, #+1]
   \   00000038   2F005203           CMPEQ    R2,#+47
   \   0000003C   0500001A           BNE      ??cJSON_Minify_3
   2664                  {
   2665                      /* double-slash comments, to end of line. */
   2666                      while (*json && (*json != '\n'))
   \                     ??cJSON_Minify_4:
   \   00000040   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000044   000052E3           CMP      R2,#+0
   \   00000048   0A005213           CMPNE    R2,#+10
   \   0000004C   EFFFFF0A           BEQ      ??cJSON_Minify_0
   2667                      {
   2668                          json++;
   \   00000050   010080E2           ADD      R0,R0,#+1
   \   00000054   F9FFFFEA           B        ??cJSON_Minify_4
   2669                      }
   2670                  }
   2671                  else if ((*json == '/') && (json[1] == '*'))
   \                     ??cJSON_Minify_3:
   \   00000058   0020D0E5           LDRB     R2,[R0, #+0]
   \   0000005C   2F0052E3           CMP      R2,#+47
   \   00000060   0120D005           LDRBEQ   R2,[R0, #+1]
   \   00000064   2A005203           CMPEQ    R2,#+42
   \   00000068   0600000A           BEQ      ??cJSON_Minify_5
   2672                  {
   2673                      /* multiline comments. */
   2674                      while (*json && !((*json == '*') && (json[1] == '/')))
   2675                      {
   2676                          json++;
   2677                      }
   2678                      json += 2;
   2679                  }
   2680                  else if (*json == '\"')
   \   0000006C   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000070   220052E3           CMP      R2,#+34
   \   00000074   ........           LDRB     R2,[R0], #+1
   \   00000078   ........           STRB     R2,[R1], #+1
   \   0000007C   E3FFFF1A           BNE      ??cJSON_Minify_0
   2681                  {
   2682                      /* string literals, which are \" sensitive. */
   2683                      *into++ = (unsigned char)*json++;
   \   00000080   0E0000EA           B        ??cJSON_Minify_6
   \                     ??cJSON_Minify_7:
   \   00000084   010080E2           ADD      R0,R0,#+1
   \                     ??cJSON_Minify_5:
   \   00000088   0020D0E5           LDRB     R2,[R0, #+0]
   \   0000008C   000052E3           CMP      R2,#+0
   \   00000090   0300000A           BEQ      ??cJSON_Minify_8
   \   00000094   2A0052E3           CMP      R2,#+42
   \   00000098   0120D005           LDRBEQ   R2,[R0, #+1]
   \   0000009C   2F005203           CMPEQ    R2,#+47
   \   000000A0   F7FFFF1A           BNE      ??cJSON_Minify_7
   \                     ??cJSON_Minify_8:
   \   000000A4   020080E2           ADD      R0,R0,#+2
   \   000000A8   D8FFFFEA           B        ??cJSON_Minify_0
   2684                      while (*json && (*json != '\"'))
   2685                      {
   2686                          if (*json == '\\')
   \                     ??cJSON_Minify_9:
   \   000000AC   5C0052E3           CMP      R2,#+92
   2687                          {
   2688                              *into++ = (unsigned char)*json++;
   \   000000B0   ........           STRBEQ   R2,[R1], #+1
   \   000000B4   01008002           ADDEQ    R0,R0,#+1
   2689                          }
   2690                          *into++ = (unsigned char)*json++;
   \   000000B8   ........           LDRB     R2,[R0], #+1
   \   000000BC   ........           STRB     R2,[R1], #+1
   2691                      }
   \                     ??cJSON_Minify_6:
   \   000000C0   0020D0E5           LDRB     R2,[R0, #+0]
   \   000000C4   000052E3           CMP      R2,#+0
   \   000000C8   22005213           CMPNE    R2,#+34
   \   000000CC   F6FFFF1A           BNE      ??cJSON_Minify_9
   2692                      *into++ = (unsigned char)*json++;
   \   000000D0   ........           LDRB     R2,[R0], #+1
   \   000000D4   ........           STRB     R2,[R1], #+1
   \   000000D8   CCFFFFEA           B        ??cJSON_Minify_0
   2693                  }
   2694                  else
   2695                  {
   2696                      /* All other characters. */
   2697                      *into++ = (unsigned char)*json++;
   2698                  }
   2699              }
   2700          
   2701              /* and null-terminate. */
   2702              *into = '\0';
   \                     ??cJSON_Minify_2:
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   0000C1E5           STRB     R0,[R1, #+0]
   2703          }
   \   000000E4   1EFF2FE1           BX       LR               ;; return
   2704          

   \                                 In segment CODE, align 4, keep-with-next
   2705          CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
   2706          {
   2707              if (item == NULL)
   \                     cJSON_IsInvalid:
   \   00000000   000050E3           CMP      R0,#+0
   2708              {
   2709                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2710              }
   2711          
   2712              return (item->type & 0xFF) == cJSON_Invalid;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   000CB0E1           LSLS     R0,R0,#+24
   \   00000010   ........           B        ?Subroutine102
   2713          }
   2714          

   \                                 In segment CODE, align 4, keep-with-next
   2715          CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
   2716          {
   2717              if (item == NULL)
   \                     cJSON_IsFalse:
   \   00000000   000050E3           CMP      R0,#+0
   2718              {
   2719                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2720              }
   2721          
   2722              return (item->type & 0xFF) == cJSON_False;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   010050E3           CMP      R0,#+1
   \   00000014   ........           B        ??Subroutine102_0
   2723          }
   2724          

   \                                 In segment CODE, align 4, keep-with-next
   2725          CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
   2726          {
   2727              if (item == NULL)
   \                     cJSON_IsTrue:
   \   00000000   000050E3           CMP      R0,#+0
   2728              {
   2729                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2730              }
   2731          
   2732              return (item->type & 0xff) == cJSON_True;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   020050E3           CMP      R0,#+2
   \   00000014                      REQUIRE ?Subroutine102
   \   00000014                      ;; // Fall through to label ?Subroutine102
   2733          }
   2734          
   2735          

   \                                 In segment CODE, align 4, keep-with-next
   2736          CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
   2737          {
   2738              if (item == NULL)
   \                     cJSON_IsBool:
   \   00000000   000050E3           CMP      R0,#+0
   2739              {
   2740                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2741              }
   2742          
   2743              return (item->type & (cJSON_True | cJSON_False)) != 0;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   030010E3           TST      R0,#0x3
   \   00000010   0100A013           MOVNE    R0,#+1
   \   00000014   1EFF2F11           BXNE     LR
   \   00000018   ........           B        ??Subroutine102_1
   2744          }

   \                                 In segment CODE, align 4, keep-with-next
   2745          CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
   2746          {
   2747              if (item == NULL)
   \                     cJSON_IsNull:
   \   00000000   000050E3           CMP      R0,#+0
   2748              {
   2749                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2750              }
   2751          
   2752              return (item->type & 0xFF) == cJSON_NULL;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   040050E3           CMP      R0,#+4
   \   00000014   ........           B        ?Subroutine102
   2753          }
   2754          

   \                                 In segment CODE, align 4, keep-with-next
   2755          CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
   2756          {
   2757              if (item == NULL)
   \                     cJSON_IsNumber:
   \   00000000   000050E3           CMP      R0,#+0
   2758              {
   2759                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2760              }
   2761          
   2762              return (item->type & 0xFF) == cJSON_Number;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   080050E3           CMP      R0,#+8
   \   00000014   ........           B        ?Subroutine102
   2763          }
   2764          

   \                                 In segment CODE, align 4, keep-with-next
   2765          CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
   2766          {
   2767              if (item == NULL)
   \                     cJSON_IsString:
   \   00000000   000050E3           CMP      R0,#+0
   2768              {
   2769                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2770              }
   2771          
   2772              return (item->type & 0xFF) == cJSON_String;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   100050E3           CMP      R0,#+16
   \   00000014   ........           B        ?Subroutine102
   2773          }
   2774          

   \                                 In segment CODE, align 4, keep-with-next
   2775          CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
   2776          {
   2777              if (item == NULL)
   \                     cJSON_IsArray:
   \   00000000   000050E3           CMP      R0,#+0
   2778              {
   2779                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2780              }
   2781          
   2782              return (item->type & 0xFF) == cJSON_Array;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   200050E3           CMP      R0,#+32
   \   00000014   ........           B        ?Subroutine102
   2783          }
   2784          

   \                                 In segment CODE, align 4, keep-with-next
   2785          CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
   2786          {
   2787              if (item == NULL)
   \                     cJSON_IsObject:
   \   00000000   000050E3           CMP      R0,#+0
   2788              {
   2789                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2790              }
   2791          
   2792              return (item->type & 0xFF) == cJSON_Object;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   400050E3           CMP      R0,#+64
   \   00000014   ........           B        ?Subroutine102
   2793          }
   2794          

   \                                 In segment CODE, align 4, keep-with-next
   2795          CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
   2796          {
   2797              if (item == NULL)
   \                     cJSON_IsRaw:
   \   00000000   000050E3           CMP      R0,#+0
   2798              {
   2799                  return false;
   \   00000004   1EFF2F01           BXEQ     LR
   2800              }
   2801          
   2802              return (item->type & 0xFF) == cJSON_Raw;
   \   00000008   0C0090E5           LDR      R0,[R0, #+12]
   \   0000000C   FF0000E2           AND      R0,R0,#0xFF
   \   00000010   800050E3           CMP      R0,#+128
   \   00000014   ........           B        ?Subroutine102
   2803          }
   2804          

   \                                 In segment CODE, align 4, keep-with-next
   2805          CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
   2806          {
   \                     cJSON_Compare:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   2807              if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   00005413           CMPNE    R4,#+0
   \   00000018   1700000A           BEQ      ??cJSON_Compare_0
   \   0000001C   0C7095E5           LDR      R7,[R5, #+12]
   \   00000020   0C1094E5           LDR      R1,[R4, #+12]
   \   00000024   FF0007E2           AND      R0,R7,#0xFF
   \   00000028   FF1001E2           AND      R1,R1,#0xFF
   \   0000002C   010050E1           CMP      R0,R1
   \   00000030   1100001A           BNE      ??cJSON_Compare_0
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   ........           BL       cJSON_IsInvalid
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0D00001A           BNE      ??cJSON_Compare_0
   2808              {
   2809                  return false;
   2810              }
   2811          
   2812              /* check if type is valid */
   2813              switch (a->type & 0xFF)
   \   00000044   FF0007E2           AND      R0,R7,#0xFF
   \   00000048   010040E2           SUB      R0,R0,#+1
   \   0000004C   010050E3           CMP      R0,#+1
   \   00000050   0600009A           BLS      ??cJSON_Compare_1
   \   00000054   030050E2           SUBS     R0,R0,#+3
   \   00000058   04005012           SUBSNE   R0,R0,#+4
   \   0000005C   08005012           SUBSNE   R0,R0,#+8
   \   00000060   10005012           SUBSNE   R0,R0,#+16
   \   00000064   20005012           SUBSNE   R0,R0,#+32
   \   00000068   40005012           SUBSNE   R0,R0,#+64
   \   0000006C   0200001A           BNE      ??cJSON_Compare_0
   2814              {
   2815                  case cJSON_False:
   2816                  case cJSON_True:
   2817                  case cJSON_NULL:
   2818                  case cJSON_Number:
   2819                  case cJSON_String:
   2820                  case cJSON_Raw:
   2821                  case cJSON_Array:
   2822                  case cJSON_Object:
   2823                      break;
   2824          
   2825                  default:
   2826                      return false;
   2827              }
   2828          
   2829              /* identical objects are equal */
   2830              if (a == b)
   \                     ??cJSON_Compare_1:
   \   00000070   040055E1           CMP      R5,R4
   \   00000074   0100001A           BNE      ??cJSON_Compare_2
   2831              {
   2832                  return true;
   \   00000078   120000EA           B        ??cJSON_Compare_3
   2833              }
   \                     ??cJSON_Compare_0:
   \   0000007C   ........           B        ?Subroutine112
   2834          
   2835              switch (a->type & 0xFF)
   \                     ??cJSON_Compare_2:
   \   00000080   088095E5           LDR      R8,[R5, #+8]
   \   00000084   FF7007E2           AND      R7,R7,#0xFF
   \   00000088   017047E2           SUB      R7,R7,#+1
   \   0000008C   010057E3           CMP      R7,#+1
   \   00000090   0C00009A           BLS      ??cJSON_Compare_3
   \   00000094   037057E2           SUBS     R7,R7,#+3
   \   00000098   0A00000A           BEQ      ??cJSON_Compare_3
   \   0000009C   047057E2           SUBS     R7,R7,#+4
   \   000000A0   0900000A           BEQ      ??cJSON_Compare_4
   \   000000A4   087057E2           SUBS     R7,R7,#+8
   \   000000A8   0F00000A           BEQ      ??cJSON_Compare_5
   \   000000AC   107057E2           SUBS     R7,R7,#+16
   \   000000B0   1800000A           BEQ      ??cJSON_Compare_6
   \   000000B4   207057E2           SUBS     R7,R7,#+32
   \   000000B8   2800000A           BEQ      ??cJSON_Compare_7
   \   000000BC   407057E2           SUBS     R7,R7,#+64
   \   000000C0   0900000A           BEQ      ??cJSON_Compare_5
   \   000000C4   ECFFFFEA           B        ??cJSON_Compare_0
   2836              {
   2837                  /* in these cases and equal type is enough */
   2838                  case cJSON_False:
   2839                  case cJSON_True:
   2840                  case cJSON_NULL:
   2841                      return true;
   \                     ??cJSON_Compare_3:
   \   000000C8   ........           B        ?Subroutine113
   2842          
   2843                  case cJSON_Number:
   2844                      if (a->valuedouble == b->valuedouble)
   \                     ??cJSON_Compare_4:
   \   000000CC   180095E5           LDR      R0,[R5, #+24]
   \   000000D0   1C1095E5           LDR      R1,[R5, #+28]
   \   000000D4   182094E5           LDR      R2,[R4, #+24]
   \   000000D8   1C3094E5           LDR      R3,[R4, #+28]
   \   000000DC   ........           _BLF     __dEqual,??__dEqual??rA
   \   000000E0   000050E3           CMP      R0,#+0
   2845                      {
   2846                          return true;
   \   000000E4   0100A013           MOVNE    R0,#+1
   2847                      }
   2848                      return false;
   \   000000E8   F081BDE8           POP      {R4-R8,PC}
   2849          
   2850                  case cJSON_String:
   2851                  case cJSON_Raw:
   2852                      if ((a->valuestring == NULL) || (b->valuestring == NULL))
   \                     ??cJSON_Compare_5:
   \   000000EC   100095E5           LDR      R0,[R5, #+16]
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   F081BD08           POPEQ    {R4-R8,PC}
   \   000000F8   101094E5           LDR      R1,[R4, #+16]
   \   000000FC   000051E3           CMP      R1,#+0
   2853                      {
   2854                          return false;
   \   00000100   0000A003           MOVEQ    R0,#+0
   \   00000104   F081BD08           POPEQ    {R4-R8,PC}
   2855                      }
   2856                      if (strcmp(a->valuestring, b->valuestring) == 0)
   \   00000108   190000EF           SWI      +25
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   D9FFFF1A           BNE      ??cJSON_Compare_0
   2857                      {
   2858                          return true;
   \   00000114   EBFFFFEA           B        ??cJSON_Compare_3
   2859                      }
   2860          
   2861                      return false;
   2862          
   2863                  case cJSON_Array:
   2864                  {
   2865                      cJSON *a_element = a->child;
   2866                      cJSON *b_element = b->child;
   \                     ??cJSON_Compare_6:
   \   00000118   084094E5           LDR      R4,[R4, #+8]
   \   0000011C   010000EA           B        ??cJSON_Compare_8
   2867          
   2868                      for (; (a_element != NULL) && (b_element != NULL);)
   2869                      {
   2870                          if (!cJSON_Compare(a_element, b_element, case_sensitive))
   2871                          {
   2872                              return false;
   2873                          }
   2874          
   2875                          a_element = a_element->next;
   \                     ??cJSON_Compare_9:
   \   00000120   008098E5           LDR      R8,[R8, #+0]
   2876                          b_element = b_element->next;
   \   00000124   004094E5           LDR      R4,[R4, #+0]
   \                     ??cJSON_Compare_8:
   \   00000128   000058E3           CMP      R8,#+0
   \   0000012C   00005413           CMPNE    R4,#+0
   \   00000130   0600000A           BEQ      ??cJSON_Compare_10
   \   00000134   0620A0E1           MOV      R2,R6
   \   00000138   0410A0E1           MOV      R1,R4
   \   0000013C   0800A0E1           MOV      R0,R8
   \   00000140   AEFFFFEB           BL       cJSON_Compare
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   F4FFFF1A           BNE      ??cJSON_Compare_9
   \   0000014C   F081BDE8           POP      {R4-R8,PC}
   2877                      }
   2878          
   2879                      /* one of the arrays is longer than the other */
   2880                      if (a_element != b_element) {
   \                     ??cJSON_Compare_10:
   \   00000150   040058E1           CMP      R8,R4
   \   00000154   DBFFFF0A           BEQ      ??cJSON_Compare_3
   2881                          return false;
   \   00000158   C7FFFFEA           B        ??cJSON_Compare_0
   2882                      }
   2883          
   2884                      return true;
   2885                  }
   2886          
   2887                  case cJSON_Object:
   2888                  {
   2889                      cJSON *a_element = NULL;
   2890                      cJSON *b_element = NULL;
   2891                      cJSON_ArrayForEach(a_element, a)
   \                     ??cJSON_Compare_11:
   \   0000015C   008098E5           LDR      R8,[R8, #+0]
   \                     ??cJSON_Compare_7:
   \   00000160   000058E3           CMP      R8,#+0
   \   00000164   0C00000A           BEQ      ??cJSON_Compare_12
   2892                      {
   2893                          /* TODO This has O(n^2) runtime, which is horrible! */
   2894                          b_element = get_object_item(b, a_element->string, case_sensitive);
   \   00000168   201098E5           LDR      R1,[R8, #+32]
   \   0000016C   0620A0E1           MOV      R2,R6
   \   00000170   0400A0E1           MOV      R0,R4
   \   00000174   ........           BL       get_object_item
   \   00000178   0070B0E1           MOVS     R7,R0
   2895                          if (b_element == NULL)
   \   0000017C   BEFFFF0A           BEQ      ??cJSON_Compare_0
   2896                          {
   2897                              return false;
   2898                          }
   2899          
   2900                          if (!cJSON_Compare(a_element, b_element, case_sensitive))
   \   00000180   0620A0E1           MOV      R2,R6
   \   00000184   0010A0E1           MOV      R1,R0
   \   00000188   0800A0E1           MOV      R0,R8
   \   0000018C   9BFFFFEB           BL       cJSON_Compare
   \   00000190   000050E3           CMP      R0,#+0
   \   00000194   F0FFFF1A           BNE      ??cJSON_Compare_11
   2901                          {
   2902                              return false;
   \   00000198   F081BDE8           POP      {R4-R8,PC}
   2903                          }
   2904                      }
   \                     ??cJSON_Compare_12:
   \   0000019C   087094E5           LDR      R7,[R4, #+8]
   \   000001A0   000000EA           B        ??cJSON_Compare_13
   2905          
   2906                      /* doing this twice, once on a and b to prevent true comparison if a subset of b
   2907                       * TODO: Do this the proper way, this is just a fix for now */
   2908                      cJSON_ArrayForEach(b_element, b)
   \                     ??cJSON_Compare_14:
   \   000001A4   007097E5           LDR      R7,[R7, #+0]
   \                     ??cJSON_Compare_13:
   \   000001A8   000057E3           CMP      R7,#+0
   \   000001AC   C5FFFF0A           BEQ      ??cJSON_Compare_3
   2909                      {
   2910                          a_element = get_object_item(a, b_element->string, case_sensitive);
   \   000001B0   201097E5           LDR      R1,[R7, #+32]
   \   000001B4   0620A0E1           MOV      R2,R6
   \   000001B8   0500A0E1           MOV      R0,R5
   \   000001BC   ........           BL       get_object_item
   \   000001C0   0080B0E1           MOVS     R8,R0
   2911                          if (a_element == NULL)
   \   000001C4   ACFFFF0A           BEQ      ??cJSON_Compare_0
   2912                          {
   2913                              return false;
   2914                          }
   2915          
   2916                          if (!cJSON_Compare(b_element, a_element, case_sensitive))
   \   000001C8   0620A0E1           MOV      R2,R6
   \   000001CC   0010A0E1           MOV      R1,R0
   \   000001D0   0700A0E1           MOV      R0,R7
   \   000001D4   89FFFFEB           BL       cJSON_Compare
   \   000001D8   000050E3           CMP      R0,#+0
   \   000001DC   F0FFFF1A           BNE      ??cJSON_Compare_14
   2917                          {
   2918                              return false;
   \   000001E0   F081BDE8           POP      {R4-R8,PC}
   2919                          }
   2920                      }
   2921          
   2922                      return true;
   2923                  }
   2924          
   2925                  default:
   2926                      return false;
   2927              }
   2928          }
   2929          

   \                                 In segment CODE, align 4, keep-with-next
   2930          CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
   2931          {
   2932              return global_hooks.allocate(size);
   \                     cJSON_malloc:
   \   00000000   ........           LDR      R1,??DataTable29  ;; global_hooks
   \   00000004   001091E5           LDR      R1,[R1, #+0]
   \   00000008   01F0A0E1           MOV      PC,R1            ;; tailcall
   2933          }
   2934          

   \                                 In segment CODE, align 4, keep-with-next
   2935          CJSON_PUBLIC(void) cJSON_free(void *object)
   2936          {
   2937              global_hooks.deallocate(object);
   \                     cJSON_free:
   \   00000000   04109FE5           LDR      R1,??cJSON_free_0  ;; global_hooks + 4
   \   00000004   001091E5           LDR      R1,[R1, #+0]
   \   00000008   01F0A0E1           MOV      PC,R1            ;; tailcall
   \                     ??cJSON_free_0:
   \   0000000C   ........           DC32     global_hooks + 4
   2938          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     global_hooks

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     global_hooks

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     `?<Constant "null">`

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   ........           DC32     global_hooks

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for global_hooks>`:
   \   00000000   ............       DC32 internal_malloc, internal_free, internal_realloc
   \              ............
   \                     `?<Initializer for global_error>`:
   \   0000000C   000000000000       DC32 0H, 0
   \              0000        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%i.%i.%i">`:
   \   00000000   25692E25692E       DC8 "%i.%i.%i"
   \              256900      
   \   00000009   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   222200             DC8 "\"\""

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "u%04x">`:
   \   00000000   752530347800       DC8 "u%04x"
   \   00000006   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   EFBBBF00           DC8 "\357\273\277"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   000000000000       DC32 0H, 0, 0, 0, 0H, 0H, 0H
   \              000000000000
   \              000000000000
   \              000000000000
   \              00000000    

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   000000000000       DC32 0H, 0, 0, 0, 0, 0, 0H, 0H, 0H
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   000000000000       DC32 0H, 0, 0, 0, 0, 0, 0H, 0H, 0H
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     add_item_to_array                  4
     add_item_to_object                24
     buffer_skip_whitespace             0
     cJSON_AddArrayToObject            20
     cJSON_AddBoolToObject             20
     cJSON_AddFalseToObject            20
     cJSON_AddItemReferenceToArray      8
     cJSON_AddItemReferenceToObject    20
     cJSON_AddItemToArray               4
     cJSON_AddItemToObject              8
     cJSON_AddItemToObjectCS            8
     cJSON_AddNullToObject             20
     cJSON_AddNumberToObject           20
     cJSON_AddObjectToObject           20
     cJSON_AddRawToObject              20
     cJSON_AddStringToObject           20
     cJSON_AddTrueToObject             20
     cJSON_Compare                     24
     cJSON_CreateArray                  4
     cJSON_CreateArrayReference         8
     cJSON_CreateBool                   8
     cJSON_CreateDoubleArray           28
     cJSON_CreateFalse                  4
     cJSON_CreateFloatArray            28
     cJSON_CreateIntArray              28
     cJSON_CreateNull                   4
     cJSON_CreateNumber                16
     cJSON_CreateObject                 4
     cJSON_CreateObjectReference        8
     cJSON_CreateRaw                   16
     cJSON_CreateString                16
     cJSON_CreateStringArray           28
     cJSON_CreateStringReference        8
     cJSON_CreateTrue                   4
     cJSON_Delete                      16
     cJSON_DeleteItemFromArray          4
     cJSON_DeleteItemFromObject         4
     cJSON_DeleteItemFromObjectCaseSensitive
                                        4
     cJSON_DetachItemFromArray          8
     cJSON_DetachItemFromObject         8
     cJSON_DetachItemFromObjectCaseSensitive
                                        8
     cJSON_DetachItemViaPointer         0
     cJSON_Duplicate                   24
     cJSON_GetArrayItem                 4
     cJSON_GetArraySize                 0
     cJSON_GetErrorPtr                  0
     cJSON_GetObjectItem                4
     cJSON_GetObjectItemCaseSensitive
                                        4
     cJSON_GetStringValue               8
     cJSON_HasObjectItem                4
     cJSON_InitHooks                   12
     cJSON_InsertItemInArray           12
     cJSON_IsArray                      0
     cJSON_IsBool                       0
     cJSON_IsFalse                      0
     cJSON_IsInvalid                    0
     cJSON_IsNull                       0
     cJSON_IsNumber                     0
     cJSON_IsObject                     0
     cJSON_IsRaw                        0
     cJSON_IsString                     0
     cJSON_IsTrue                       0
     cJSON_Minify                       0
     cJSON_New_Item                     8
     cJSON_Parse                        4
     cJSON_ParseWithOpts               56
     cJSON_Print                        4
     cJSON_PrintBuffered               56
     cJSON_PrintPreallocated           48
     cJSON_PrintUnformatted             4
     cJSON_ReplaceItemInArray          12
     cJSON_ReplaceItemInObject          4
     cJSON_ReplaceItemInObjectCaseSensitive
                                        4
     cJSON_ReplaceItemViaPointer        4
     cJSON_SetNumberHelper             16
     cJSON_Version                     12
     cJSON_free                         4
     cJSON_malloc                       4
     cJSON_strdup                      16
     create_reference                  12
     ensure                            16
     get_array_item                     0
     get_object_item                   24
     internal_free                      4
     internal_malloc                    4
     internal_realloc                   4
     parse_array                       20
     parse_hex4                         0
     parse_number                      88
     parse_object                      24
     parse_string                      40
     parse_value                       20
     print                             60
     print_array                       20
     print_number                      60
     print_object                      32
     print_string_ptr                  32
     print_value                       16
     replace_item_in_object            20
     suffix_object                      0
     update_offset                      8
     utf16_literal_to_utf8             24


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     ?<Constant "null">               44
     cJSON_GetErrorPtr                20
     cJSON_GetStringValue             28
     cJSON_Version                    52
     version                          16
     internal_malloc                  12
     internal_free                    12
     internal_realloc                 12
     global_hooks                     20
     cJSON_strdup                     72
     ?Subroutine107                   60
     cJSON_InitHooks                 128
     cJSON_New_Item                   48
     cJSON_Delete                    140
     parse_number                    352
     cJSON_SetNumberHelper           128
     ensure                          244
     update_offset                    48
     print_number                    288
     ?Subroutine111                    8
     parse_hex4                      108
     ?Subroutine103                    8
     ?Subroutine102                   16
     utf16_literal_to_utf8           308
     ?Subroutine112                    8
     parse_string                    504
     print_string_ptr                424
     ?Subroutine115                    8
     buffer_skip_whitespace           72
     cJSON_ParseWithOpts             376
     cJSON_Parse                      12
     print                           288
     cJSON_Print                      12
     cJSON_PrintUnformatted           12
     cJSON_PrintBuffered             160
     cJSON_PrintPreallocated         116
     parse_value                     372
     ?Subroutine110                    8
     ?Subroutine109                   12
     print_value                     316
     parse_array                     336
     print_array                     260
     parse_object                    444
     ?Subroutine113                    8
     print_object                    524
     cJSON_GetArraySize               36
     get_array_item                   40
     cJSON_GetArrayItem               16
     get_object_item                 188
     ?Subroutine114                    8
     cJSON_GetObjectItem               8
     cJSON_GetObjectItemCaseSensitive
                                       8
     cJSON_HasObjectItem              20
     suffix_object                    12
     create_reference                 88
     add_item_to_array                64
     ?Subroutine105                    8
     cJSON_AddItemToArray              4
     add_item_to_object              144
     cJSON_AddItemToObject            12
     ?Subroutine118                   16
     cJSON_AddItemToObjectCS           8
     cJSON_AddItemReferenceToArray    44
     cJSON_AddItemReferenceToObject   76
     cJSON_AddNullToObject            20
     cJSON_AddTrueToObject            16
     cJSON_AddFalseToObject           20
     cJSON_AddBoolToObject            24
     cJSON_AddNumberToObject          28
     cJSON_AddStringToObject          24
     cJSON_AddRawToObject             24
     cJSON_AddObjectToObject          20
     cJSON_AddArrayToObject           20
     cJSON_DetachItemViaPointer       84
     cJSON_DetachItemFromArray        28
     ?Subroutine119                   16
     cJSON_DeleteItemFromArray        12
     ?Subroutine120                    8
     cJSON_DetachItemFromObject       12
     cJSON_DetachItemFromObjectCaseSensitive
                                      16
     cJSON_DeleteItemFromObject        8
     cJSON_DeleteItemFromObjectCaseSensitive
                                      12
     cJSON_InsertItemInArray          92
     cJSON_ReplaceItemViaPointer     112
     cJSON_ReplaceItemInArray         44
     replace_item_in_object          128
     cJSON_ReplaceItemInObject         8
     cJSON_ReplaceItemInObjectCaseSensitive
                                       8
     cJSON_CreateNull                 24
     ?Subroutine106                    8
     cJSON_CreateTrue                 20
     cJSON_CreateFalse                24
     cJSON_CreateBool                 44
     cJSON_CreateNumber              140
     ?Subroutine108                    8
     cJSON_CreateString               68
     cJSON_CreateStringReference      36
     cJSON_CreateObjectReference      28
     ?Subroutine104                   12
     cJSON_CreateArrayReference       24
     cJSON_CreateRaw                  72
     cJSON_CreateArray                24
     cJSON_CreateObject               24
     cJSON_CreateIntArray            132
     ?Subroutine117                    8
     ?Subroutine116                    8
     cJSON_CreateFloatArray          132
     cJSON_CreateDoubleArray         132
     cJSON_CreateStringArray         128
     cJSON_Duplicate                 244
     cJSON_Minify                    232
     cJSON_IsInvalid                  20
     cJSON_IsFalse                    24
     cJSON_IsTrue                     20
     cJSON_IsBool                     28
     cJSON_IsNull                     24
     cJSON_IsNumber                   24
     cJSON_IsString                   24
     cJSON_IsArray                    24
     cJSON_IsObject                   24
     cJSON_IsRaw                      24
     cJSON_Compare                   484
     cJSON_malloc                     12
     cJSON_free                       16
     ??DataTable2                      4
     ??DataTable8                      4
     ??DataTable10                     4
     ??DataTable29                     4
     ?<Initializer for global_hooks>
                                      20
     ?<Constant "%i.%i.%i">           12
     ?<Constant "\"\"">                3
     ?<Constant "u%04x">               8
     ?<Constant "\357\273\277">        4
     ?<Constant {(unsigned char const *)0, 0, 0, 0,
                                      28
     ?<Constant {(unsigned char *)0, 0, 0, 0, 0, 0,
                                      36
     ?<Constant {(unsigned char *)0, 0, 0, 0, 0, 0,_1
                                      36
      Others                         552

 
 10 812 bytes in segment CODE
    171 bytes in segment DATA_C
     20 bytes in segment DATA_I
     20 bytes in segment DATA_ID
     16 bytes in segment DATA_Z
     24 bytes in segment INITTAB
 
 10 284 bytes of CODE  memory (+ 552 bytes shared)
    191 bytes of CONST memory
     36 bytes of DATA  memory

Errors: none
Warnings: none
