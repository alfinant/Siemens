##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    21/Oct/2018  18:38:06 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\undifined_functions.c                         #
#    Command line    =  E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\undifined_functions.c -D NEWSGOLD -lCN        #
#                       E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\List\ -la                         #
#                       E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\List\ --diag_suppress Pe301 -o    #
#                       E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\Obj\ -z9 --cpu_mode arm --endian  #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --dlib_config                          #
#                       E:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I E:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\List\undifined_functions.lst      #
#    Object file     =  E:\Users\alfinant\Documents\Siemens\alfinant\src_iar #
#                       \cJSON\Release_NSG\Obj\undifined_functions.r79       #
#                                                                            #
#                                                                            #
##############################################################################

E:\Users\alfinant\Documents\Siemens\alfinant\src_iar\cJSON\undifined_functions.c
      1          #include <siemens\swilib.h>
      2          

   \                                 In segment CODE, align 4, keep-with-next
      3          int tolower(int ch)//îáüÿâëåí â ctype.h 
      4          {
      5          switch(ch) 
   \                     tolower:
   \   00000000   411040E2           SUB      R1,R0,#+65
   \   00000004   190051E3           CMP      R1,#+25
   \   00000008   1EFF2F81           BXHI     LR
   \   0000000C   012F8FE2           ADR      R2,??tolower_0
   \   00000010   0120D2E7           LDRB     R2,[R2, R1]
   \   00000014   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??tolower_0:
   \   00000018   06080A0C           DC8      +6,+8,+10,+12
   \   0000001C   0E101214           DC8      +14,+16,+18,+20
   \   00000020   16181A1C           DC8      +22,+24,+26,+28
   \   00000024   1E202224           DC8      +30,+32,+34,+36
   \   00000028   26282A2C           DC8      +38,+40,+42,+44
   \   0000002C   2E303234           DC8      +46,+48,+50,+52
   \   00000030   36380000           DC8      +54,+56,+0,+0
      6          { 
      7              case 'A': return 'a'; 
   \                     ??tolower_1:
   \   00000034   6100A0E3           MOV      R0,#+97
   \   00000038   1EFF2FE1           BX       LR
      8              case 'B': return 'b';
   \                     ??tolower_2:
   \   0000003C   6200A0E3           MOV      R0,#+98
   \   00000040   1EFF2FE1           BX       LR
      9              case 'C': return 'c';
   \                     ??tolower_3:
   \   00000044   6300A0E3           MOV      R0,#+99
   \   00000048   1EFF2FE1           BX       LR
     10              case 'D': return 'd';
   \                     ??tolower_4:
   \   0000004C   6400A0E3           MOV      R0,#+100
   \   00000050   1EFF2FE1           BX       LR
     11              case 'E': return 'e';
   \                     ??tolower_5:
   \   00000054   6500A0E3           MOV      R0,#+101
   \   00000058   1EFF2FE1           BX       LR
     12              case 'F': return 'f';
   \                     ??tolower_6:
   \   0000005C   6600A0E3           MOV      R0,#+102
   \   00000060   1EFF2FE1           BX       LR
     13              case 'G': return 'g';
   \                     ??tolower_7:
   \   00000064   6700A0E3           MOV      R0,#+103
   \   00000068   1EFF2FE1           BX       LR
     14              case 'H': return 'h';
   \                     ??tolower_8:
   \   0000006C   6800A0E3           MOV      R0,#+104
   \   00000070   1EFF2FE1           BX       LR
     15              case 'I': return 'i';
   \                     ??tolower_9:
   \   00000074   6900A0E3           MOV      R0,#+105
   \   00000078   1EFF2FE1           BX       LR
     16              case 'J': return 'j';
   \                     ??tolower_10:
   \   0000007C   6A00A0E3           MOV      R0,#+106
   \   00000080   1EFF2FE1           BX       LR
     17              case 'K': return 'k';
   \                     ??tolower_11:
   \   00000084   6B00A0E3           MOV      R0,#+107
   \   00000088   1EFF2FE1           BX       LR
     18              case 'L': return 'l';
   \                     ??tolower_12:
   \   0000008C   6C00A0E3           MOV      R0,#+108
   \   00000090   1EFF2FE1           BX       LR
     19              case 'M': return 'm';
   \                     ??tolower_13:
   \   00000094   6D00A0E3           MOV      R0,#+109
   \   00000098   1EFF2FE1           BX       LR
     20              case 'N': return 'n';
   \                     ??tolower_14:
   \   0000009C   6E00A0E3           MOV      R0,#+110
   \   000000A0   1EFF2FE1           BX       LR
     21              case 'O': return 'o';
   \                     ??tolower_15:
   \   000000A4   6F00A0E3           MOV      R0,#+111
   \   000000A8   1EFF2FE1           BX       LR
     22              case 'P': return 'p';
   \                     ??tolower_16:
   \   000000AC   7000A0E3           MOV      R0,#+112
   \   000000B0   1EFF2FE1           BX       LR
     23              case 'Q': return 'q';
   \                     ??tolower_17:
   \   000000B4   7100A0E3           MOV      R0,#+113
   \   000000B8   1EFF2FE1           BX       LR
     24              case 'R': return 'r';
   \                     ??tolower_18:
   \   000000BC   7200A0E3           MOV      R0,#+114
   \   000000C0   1EFF2FE1           BX       LR
     25              case 'S': return 's';
   \                     ??tolower_19:
   \   000000C4   7300A0E3           MOV      R0,#+115
   \   000000C8   1EFF2FE1           BX       LR
     26              case 'T': return 't';
   \                     ??tolower_20:
   \   000000CC   7400A0E3           MOV      R0,#+116
   \   000000D0   1EFF2FE1           BX       LR
     27              case 'U': return 'u';
   \                     ??tolower_21:
   \   000000D4   7500A0E3           MOV      R0,#+117
   \   000000D8   1EFF2FE1           BX       LR
     28              case 'V': return 'v';
   \                     ??tolower_22:
   \   000000DC   7600A0E3           MOV      R0,#+118
   \   000000E0   1EFF2FE1           BX       LR
     29              case 'W': return 'w'; 
   \                     ??tolower_23:
   \   000000E4   7700A0E3           MOV      R0,#+119
   \   000000E8   1EFF2FE1           BX       LR
     30              case 'X': return 'x'; 
   \                     ??tolower_24:
   \   000000EC   7800A0E3           MOV      R0,#+120
   \   000000F0   1EFF2FE1           BX       LR
     31              case 'Y': return 'y'; 
   \                     ??tolower_25:
   \   000000F4   7900A0E3           MOV      R0,#+121
   \   000000F8   1EFF2FE1           BX       LR
     32              case 'Z': return 'z';
   \                     ??tolower_26:
   \   000000FC   7A00A0E3           MOV      R0,#+122
     33          }; 
     34          return ch; 
   \                     ??tolower_27:
   \   00000100   1EFF2FE1           BX       LR               ;; return
     35          }
     36          

   \                                 In segment CODE, align 4, keep-with-next
     37          double strtod(const char* s, char** endptr)
     38          {
   \                     strtod:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   01A0A0E1           MOV      R10,R1
     39              register const char*  p     = s;
   \   0000000C   0080A0E1           MOV      R8,R0
     40              register long double  value = 0.L;
   \   00000010   0060A0E3           MOV      R6,#+0
   \   00000014   0070A0E3           MOV      R7,#+0
     41              int                   sign  = +1;
   \   00000018   0190A0E3           MOV      R9,#+1
   \   0000001C   000000EA           B        ??strtod_0
     42              long double           factor;
     43              unsigned int          expo;
     44          
     45              while (*p==' ')
     46                  p++;
   \                     ??strtod_1:
   \   00000020   018088E2           ADD      R8,R8,#+1
   \                     ??strtod_0:
   \   00000024   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000028   200050E3           CMP      R0,#+32
   \   0000002C   FBFFFF0A           BEQ      ??strtod_1
     47          
     48              switch (*p) {
   \   00000030   2B0050E2           SUBS     R0,R0,#+43
   \   00000034   0200000A           BEQ      ??strtod_2
   \   00000038   020050E2           SUBS     R0,R0,#+2
   \   0000003C   0100001A           BNE      ??strtod_3
     49              case '-': sign = -1;
   \   00000040   0690E0E1           MVN      R9,R6
     50              case '+': p++;
   \                     ??strtod_2:
   \   00000044   018088E2           ADD      R8,R8,#+1
     51              default : break;
     52              }
     53          
     54              while ( (unsigned int)(*p - '0') < 10u )
   \                     ??strtod_3:
   \   00000048   0000D8E5           LDRB     R0,[R8, #+0]
   \   0000004C   30B040E2           SUB      R11,R0,#+48
   \   00000050   0A005BE3           CMP      R11,#+10
   \   00000054   0F00002A           BCS      ??strtod_4
     55                  value = value*10 + (*p++ - '0');
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   4014A0E3           MOV      R1,#+1073741824
   \   00000060   901981E3           ORR      R1,R1,#0x240000
   \   00000064   0620A0E1           MOV      R2,R6
   \   00000068   0730A0E1           MOV      R3,R7
   \   0000006C   ........           _BLF     __dMul,??__dMul??rA
   \   00000070   0040A0E1           MOV      R4,R0
   \   00000074   0150A0E1           MOV      R5,R1
   \   00000078   0B00A0E1           MOV      R0,R11
   \   0000007C   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000080   0420A0E1           MOV      R2,R4
   \   00000084   0530A0E1           MOV      R3,R5
   \   00000088   ........           _BLF     __dAdd,??__dAdd??rA
   \   0000008C   0060A0E1           MOV      R6,R0
   \   00000090   0170A0E1           MOV      R7,R1
   \   00000094   EAFFFFEA           B        ??strtod_2
     56          
     57              if ( *p == '.' ) {
   \                     ??strtod_4:
   \   00000098   2E0050E3           CMP      R0,#+46
   \   0000009C   1A00001A           BNE      ??strtod_5
     58                  factor = 1.;
   \   000000A0   0040A0E3           MOV      R4,#+0
   \   000000A4   C055A0E3           MOV      R5,#+805306368
   \   000000A8   FF5685E3           ORR      R5,R5,#0xFF00000
     59          
     60                  p++;
   \   000000AC   018088E2           ADD      R8,R8,#+1
   \   000000B0   110000EA           B        ??strtod_6
     61                  while ( (unsigned int)(*p - '0') < 10u ) {
     62                      factor *= 0.1;
   \                     ??strtod_7:
   \   000000B4   34019FE5           LDR      R0,??strtod_8    ;; 0xffffffff9999999a
   \   000000B8   34119FE5           LDR      R1,??strtod_8+0x4  ;; 0x3fb99999
   \   000000BC   0420A0E1           MOV      R2,R4
   \   000000C0   0530A0E1           MOV      R3,R5
   \   000000C4   ........           _BLF     __dMul,??__dMul??rA
   \   000000C8   0040A0E1           MOV      R4,R0
     63                      value  += (*p++ - '0') * factor;
   \   000000CC   ........           LDRB     R0,[R8], #+1
   \   000000D0   0150A0E1           MOV      R5,R1
   \   000000D4   300040E2           SUB      R0,R0,#+48
   \   000000D8   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   000000DC   0420A0E1           MOV      R2,R4
   \   000000E0   0530A0E1           MOV      R3,R5
   \   000000E4   ........           _BLF     __dMul,??__dMul??rA
   \   000000E8   0620A0E1           MOV      R2,R6
   \   000000EC   0730A0E1           MOV      R3,R7
   \   000000F0   ........           _BLF     __dAdd,??__dAdd??rA
   \   000000F4   0060A0E1           MOV      R6,R0
   \   000000F8   0170A0E1           MOV      R7,R1
     64                  }
   \                     ??strtod_6:
   \   000000FC   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000100   300040E2           SUB      R0,R0,#+48
   \   00000104   0A0050E3           CMP      R0,#+10
   \   00000108   E9FFFF3A           BCC      ??strtod_7
     65              }
     66          
     67              if ( (*p | 32) == 'e' ) {
   \                     ??strtod_5:
   \   0000010C   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000110   200080E3           ORR      R0,R0,#0x20
   \   00000114   650050E3           CMP      R0,#+101
   \   00000118   2C00001A           BNE      ??strtod_9
     68                  expo   = 0;
     69                  factor = 10.L;
     70          
     71                  switch (*++p) {                 // ja hier weiß ich nicht, was mindestens nach einem 'E' folgenden MUSS.
   \   0000011C   0100F8E5           LDRB     R0,[R8, #+1]!
   \   00000120   00B0A0E3           MOV      R11,#+0
   \   00000124   0040A0E3           MOV      R4,#+0
   \   00000128   4054A0E3           MOV      R5,#+1073741824
   \   0000012C   905985E3           ORR      R5,R5,#0x240000
   \   00000130   2B0050E2           SUBS     R0,R0,#+43
   \   00000134   0700000A           BEQ      ??strtod_10
   \   00000138   020050E2           SUBS     R0,R0,#+2
   \   0000013C   0300000A           BEQ      ??strtod_11
   \   00000140   030040E2           SUB      R0,R0,#+3
   \   00000144   090050E3           CMP      R0,#+9
   \   00000148   0300009A           BLS      ??strtod_12
   \   0000014C   090000EA           B        ??strtod_13
     72                  case '-': factor = 0.1;
   \                     ??strtod_11:
   \   00000150   98409FE5           LDR      R4,??strtod_8    ;; 0xffffffff9999999a
   \   00000154   98509FE5           LDR      R5,??strtod_8+0x4  ;; 0x3fb99999
     73                  case '+': p++;
   \                     ??strtod_10:
   \   00000158   018088E2           ADD      R8,R8,#+1
   \                     ??strtod_12:
   \   0000015C   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000160   300040E2           SUB      R0,R0,#+48
   \   00000164   0A0050E3           CMP      R0,#+10
   \   00000168   0D00002A           BCS      ??strtod_14
     74                            break;
     75                  case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
     76                            break;
     77                  default : value = 0.L;
     78                            p     = s;
     79                            goto done;
     80                  }
     81          
     82                  while ( (unsigned int)(*p - '0') < 10u )
     83                      expo = 10 * expo + (*p++ - '0');
   \   0000016C   0A10A0E3           MOV      R1,#+10
   \   00000170   910B2BE0           MLA      R11,R1,R11,R0
   \   00000174   F7FFFFEA           B        ??strtod_10
   \                     ??strtod_13:
   \   00000178   04809DE5           LDR      R8,[SP, #+4]
   \   0000017C   0060A0E3           MOV      R6,#+0
   \   00000180   0470A0E1           MOV      R7,R4
   \   00000184   110000EA           B        ??strtod_9
     84          
     85                  while ( 1 ) {
     86                      if ( expo & 1 )
     87                          value *= factor;
     88                      if ( (expo >>= 1) == 0 )
     89                          break;
     90                      factor *= factor;
   \                     ??strtod_15:
   \   00000188   0420A0E1           MOV      R2,R4
   \   0000018C   0530A0E1           MOV      R3,R5
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   0510A0E1           MOV      R1,R5
   \   00000198   ........           _BLF     __dMul,??__dMul??rA
   \   0000019C   0040A0E1           MOV      R4,R0
   \   000001A0   0150A0E1           MOV      R5,R1
   \                     ??strtod_14:
   \   000001A4   01001BE3           TST      R11,#0x1
   \   000001A8   0600000A           BEQ      ??strtod_16
   \   000001AC   0420A0E1           MOV      R2,R4
   \   000001B0   0530A0E1           MOV      R3,R5
   \   000001B4   0600A0E1           MOV      R0,R6
   \   000001B8   0710A0E1           MOV      R1,R7
   \   000001BC   ........           _BLF     __dMul,??__dMul??rA
   \   000001C0   0060A0E1           MOV      R6,R0
   \   000001C4   0170A0E1           MOV      R7,R1
   \                     ??strtod_16:
   \   000001C8   ABB0B0E1           LSRS     R11,R11,#+1
   \   000001CC   EDFFFF1A           BNE      ??strtod_15
     91                  }
     92              }
     93          
     94          done:
     95              if ( endptr != NULL )
   \                     ??strtod_9:
   \   000001D0   00005AE3           CMP      R10,#+0
     96                  *endptr = (char*)p;
   \   000001D4   00808A15           STRNE    R8,[R10, #+0]
     97          
     98              return value * sign;
   \   000001D8   0900A0E1           MOV      R0,R9
   \   000001DC   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   000001E0   0620A0E1           MOV      R2,R6
   \   000001E4   0730A0E1           MOV      R3,R7
   \   000001E8   ........           _BLF     __dMul,??__dMul??rA
   \   000001EC   FC8FBDE8           POP      {R2-R11,PC}      ;; return
   \                     ??strtod_8:
   \   000001F0   9A999999           DC32     0xffffffff9999999a
   \   000001F4   9999B93F           DC32     0x3fb99999
     99          }
    100          
    101          
    102          

   Maximum stack usage in bytes:

     Function CSTACK
     -------- ------
     strtod      44
     tolower      0


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     tolower         260
     strtod          504
      Others          44

 
 808 bytes in segment CODE
 
 764 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: none
