##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    08/Jun/2017  22:38:20 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\Users\alfinant\Documents\Siemens\alfinant\CarCont #
#                       rol2\main.c                                          #
#    Command line    =  E:\Users\alfinant\Documents\Siemens\alfinant\CarCont #
#                       rol2\main.c -D X75 -D SGOLD -lC                      #
#                       E:\Users\alfinant\Documents\Siemens\alfinant\CarCont #
#                       rol2\Release_SGOLDX75\List\ -o                       #
#                       E:\Users\alfinant\Documents\Siemens\alfinant\CarCont #
#                       rol2\Release_SGOLDX75\Obj\ -s9 --cpu_mode arm        #
#                       --endian little --cpu ARM926EJ-S --stack_align 4     #
#                       --interwork -e --fpu None -I                         #
#                       E:\Users\alfinant\Documents\Siemens\IAR\ARM\INC\     #
#                       --inline_threshold=2                                 #
#    List file       =  E:\Users\alfinant\Documents\Siemens\alfinant\CarCont #
#                       rol2\Release_SGOLDX75\List\main.lst                  #
#    Object file     =  E:\Users\alfinant\Documents\Siemens\alfinant\CarCont #
#                       rol2\Release_SGOLDX75\Obj\main.r79                   #
#                                                                            #
#                                                                            #
##############################################################################

E:\Users\alfinant\Documents\Siemens\alfinant\CarControl2\main.c
      1          #include "../inc/swilib.h"

  typedef unsigned int size_t; 
                       ^
"E:\Users\alfinant\Documents\Siemens\alfinant\inc\sha.h",31  Warning[Pe301]: 
          typedef name has already been declared (with same type)
      2          #include "../inc/strings.h"
      3          #include "conf_loader.h"
      4          #include "carcontrol_ipc.h"
      5          #include "connector.h"

   \                                 In segment DATA_AN, at 0xf4300000
   \   GPIO_TypeDef __data GPIO
   \                     GPIO:
   \   00000000                      DS8 212

   \                                 In segment DATA_AN, at 0xf4000000
   \   CAPCOM_TypeDef __data CCU0
   \                     CCU0:
   \   00000000                      DS8 256

   \                                 In segment DATA_AN, at 0xf4100000
   \   CAPCOM_TypeDef __data CCU1
   \                     CCU1:
   \   00000000                      DS8 256

   \                                 In segment DATA_Z, align 4, align-sorted
   \   uint32_t __data connector[8]
   \                     connector:
   \   00000000                      DS8 32
   \   uint32_t __data save_connector[7]
   \                     save_connector:
   \   00000020                      DS8 28

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void InitConnectorMap()
   \                     InitConnectorMap:
   \   00000000   ........           LDR      R0,??DataTable6  ;; connector
   \   00000004   F014A0E3           MOV      R1,#-268435456
   \   00000008   431681E3           ORR      R1,R1,#0x4300000
   \   0000000C   502081E2           ADD      R2,R1,#+80
   \   00000010   042080E5           STR      R2,[R0, #+4]
   \   00000014   4C2081E2           ADD      R2,R1,#+76
   \   00000018   082080E5           STR      R2,[R0, #+8]
   \   0000001C   582081E2           ADD      R2,R1,#+88
   \   00000020   0C2080E5           STR      R2,[R0, #+12]
   \   00000024   542081E2           ADD      R2,R1,#+84
   \   00000028   102080E5           STR      R2,[R0, #+16]
   \   0000002C   5C1081E2           ADD      R1,R1,#+92
   \   00000030   141080E5           STR      R1,[R0, #+20]
   \   00000034   0610A0E3           MOV      R1,#+6
   \   00000038   181080E5           STR      R1,[R0, #+24]
   \   0000003C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void InitPinSafe(uint8_t, int)
   \                     InitPinSafe:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   080050E3           CMP      R0,#+8
   \   00000008   7080BD28           POPCS    {R4-R6,PC}
   \   0000000C   ........           LDR      R12,??DataTable6  ;; connector
   \   00000010   0030A0E1           MOV      R3,R0
   \   00000014   03419CE7           LDR      R4,[R12, +R3, LSL #+2]
   \   00000018   0420B0E1           MOVS     R2,R4
   \   0000001C   7080BD08           POPEQ    {R4-R6,PC}
   \   00000020   03C18CE0           ADD      R12,R12,R3, LSL #+2
   \   00000024   060054E3           CMP      R4,#+6
   \   00000028   0A00001A           BNE      ??InitPinSafe_0
   \   0000002C   000051E3           CMP      R1,#+0
   \   00000030   7080BD08           POPEQ    {R4-R6,PC}
   \   00000034   0100A0E3           MOV      R0,#+1
   \   00000038   01002DE9           PUSH     {R0}
   \   0000003C   20109CE5           LDR      R1,[R12, #+32]
   \   00000040   0030A0E3           MOV      R3,#+0
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   1000A0E3           MOV      R0,#+16
   \   0000004C   ........           _BLF     i2c_pmu_read,??i2c_pmu_read??rA
   \   00000050   04D08DE2           ADD      SP,SP,#+4
   \   00000054   7080BDE8           POP      {R4-R6,PC}
   \                     ??InitPinSafe_0:
   \   00000058   F434A0E3           MOV      R3,#-201326592
   \   0000005C   404DE0E3           MVN      R4,#+4096
   \   00000060   405983E3           ORR      R5,R3,#0x100000
   \   00000064   406FA0E3           MOV      R6,#+256
   \   00000068   010050E2           SUBS     R0,R0,#+1
   \   0000006C   0600000A           BEQ      ??InitPinSafe_1
   \   00000070   020050E2           SUBS     R0,R0,#+2
   \   00000074   0900000A           BEQ      ??InitPinSafe_2
   \   00000078   010050E2           SUBS     R0,R0,#+1
   \   0000007C   0C00000A           BEQ      ??InitPinSafe_3
   \   00000080   010050E2           SUBS     R0,R0,#+1
   \   00000084   0F00000A           BEQ      ??InitPinSafe_4
   \   00000088   120000EA           B        ??InitPinSafe_5
   \                     ??InitPinSafe_1:
   \   0000008C   006083E5           STR      R6,[R3, #+0]
   \   00000090   EC0093E5           LDR      R0,[R3, #+236]
   \   00000094   000004E0           AND      R0,R4,R0
   \   00000098   EC0083E5           STR      R0,[R3, #+236]
   \   0000009C   0D0000EA           B        ??InitPinSafe_5
   \                     ??InitPinSafe_2:
   \   000000A0   006085E5           STR      R6,[R5, #+0]
   \   000000A4   EC0095E5           LDR      R0,[R5, #+236]
   \   000000A8   000004E0           AND      R0,R4,R0
   \   000000AC   EC0085E5           STR      R0,[R5, #+236]
   \   000000B0   080000EA           B        ??InitPinSafe_5
   \                     ??InitPinSafe_3:
   \   000000B4   006083E5           STR      R6,[R3, #+0]
   \   000000B8   DC0093E5           LDR      R0,[R3, #+220]
   \   000000BC   000004E0           AND      R0,R4,R0
   \   000000C0   DC0083E5           STR      R0,[R3, #+220]
   \   000000C4   030000EA           B        ??InitPinSafe_5
   \                     ??InitPinSafe_4:
   \   000000C8   006085E5           STR      R6,[R5, #+0]
   \   000000CC   DC0095E5           LDR      R0,[R5, #+220]
   \   000000D0   000004E0           AND      R0,R4,R0
   \   000000D4   DC0085E5           STR      R0,[R5, #+220]
   \                     ??InitPinSafe_5:
   \   000000D8   000051E3           CMP      R1,#+0
   \   000000DC   00009215           LDRNE    R0,[R2, #+0]
   \   000000E0   20008C15           STRNE    R0,[R12, #+32]
   \   000000E4   000092E5           LDR      R0,[R2, #+0]
   \   000000E8   800C80E3           ORR      R0,R0,#0x8000
   \   000000EC   000082E5           STR      R0,[R2, #+0]
   \   000000F0   810CA0E3           MOV      R0,#+33024
   \   000000F4   000082E5           STR      R0,[R2, #+0]
   \   000000F8   7080BDE8           POP      {R4-R6,PC}       ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void RestorePin(uint8_t)
   \                     RestorePin:
   \   00000000   ........           LDR      R2,??DataTable6  ;; connector
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   013192E7           LDR      R3,[R2, +R1, LSL #+2]
   \   00000010   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000014   201091E5           LDR      R1,[R1, #+32]
   \   00000018   000051E3           CMP      R1,#+0
   \   0000001C   0080BD08           POPEQ    {PC}
   \   00000020   060053E3           CMP      R3,#+6
   \   00000024   0700001A           BNE      ??RestorePin_0
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   01002DE9           PUSH     {R0}
   \   00000030   0030A0E3           MOV      R3,#+0
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   1000A0E3           MOV      R0,#+16
   \   0000003C   ........           _BLF     i2c_pmu_write,??i2c_pmu_write??rA
   \   00000040   04D08DE2           ADD      SP,SP,#+4
   \   00000044   0080BDE8           POP      {PC}
   \                     ??RestorePin_0:
   \   00000048   001083E5           STR      R1,[R3, #+0]
   \   0000004C   F414A0E3           MOV      R1,#-201326592
   \   00000050   402981E3           ORR      R2,R1,#0x100000
   \   00000054   403FA0E3           MOV      R3,#+256
   \   00000058   010050E2           SUBS     R0,R0,#+1
   \   0000005C   0600000A           BEQ      ??RestorePin_1
   \   00000060   020050E2           SUBS     R0,R0,#+2
   \   00000064   0C00000A           BEQ      ??RestorePin_2
   \   00000068   010050E2           SUBS     R0,R0,#+1
   \   0000006C   1200000A           BEQ      ??RestorePin_3
   \   00000070   010050E2           SUBS     R0,R0,#+1
   \   00000074   1800000A           BEQ      ??RestorePin_4
   \   00000078   0080BDE8           POP      {PC}
   \                     ??RestorePin_1:
   \   0000007C   003081E5           STR      R3,[R1, #+0]
   \   00000080   EC0091E5           LDR      R0,[R1, #+236]
   \   00000084   400C80E3           ORR      R0,R0,#0x4000
   \   00000088   EC0081E5           STR      R0,[R1, #+236]
   \   0000008C   EC0091E5           LDR      R0,[R1, #+236]
   \   00000090   400D80E3           ORR      R0,R0,#0x1000
   \   00000094   EC0081E5           STR      R0,[R1, #+236]
   \   00000098   0080BDE8           POP      {PC}
   \                     ??RestorePin_2:
   \   0000009C   003082E5           STR      R3,[R2, #+0]
   \   000000A0   EC0092E5           LDR      R0,[R2, #+236]
   \   000000A4   400C80E3           ORR      R0,R0,#0x4000
   \   000000A8   EC0082E5           STR      R0,[R2, #+236]
   \   000000AC   EC0092E5           LDR      R0,[R2, #+236]
   \   000000B0   400D80E3           ORR      R0,R0,#0x1000
   \   000000B4   EC0082E5           STR      R0,[R2, #+236]
   \   000000B8   0080BDE8           POP      {PC}
   \                     ??RestorePin_3:
   \   000000BC   003081E5           STR      R3,[R1, #+0]
   \   000000C0   DC0091E5           LDR      R0,[R1, #+220]
   \   000000C4   400C80E3           ORR      R0,R0,#0x4000
   \   000000C8   DC0081E5           STR      R0,[R1, #+220]
   \   000000CC   DC0091E5           LDR      R0,[R1, #+220]
   \   000000D0   400D80E3           ORR      R0,R0,#0x1000
   \   000000D4   DC0081E5           STR      R0,[R1, #+220]
   \   000000D8   0080BDE8           POP      {PC}
   \                     ??RestorePin_4:
   \   000000DC   003082E5           STR      R3,[R2, #+0]
   \   000000E0   DC0092E5           LDR      R0,[R2, #+220]
   \   000000E4   400C80E3           ORR      R0,R0,#0x4000
   \   000000E8   DC0082E5           STR      R0,[R2, #+220]
   \   000000EC   DC0092E5           LDR      R0,[R2, #+220]
   \   000000F0   400D80E3           ORR      R0,R0,#0x1000
   \   000000F4   DC0082E5           STR      R0,[R2, #+220]
   \   000000F8   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void pinSetIO(uint8_t, int, int)
   \                     pinSetIO:
   \   00000000   ........           LDR      R3,??DataTable6  ;; connector
   \   00000004   00C193E7           LDR      R12,[R3, +R0, LSL #+2]
   \   00000008   000183E0           ADD      R0,R3,R0, LSL #+2
   \   0000000C   200090E5           LDR      R0,[R0, #+32]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1EFF2F01           BXEQ     LR
   \   00000018   00009CE5           LDR      R0,[R12, #+0]
   \   0000001C   011282E1           ORR      R1,R2,R1, LSL #+4
   \   00000020   800C80E3           ORR      R0,R0,#0x8000
   \   00000024   00008CE5           STR      R0,[R12, #+0]
   \   00000028   00009CE5           LDR      R0,[R12, #+0]
   \   0000002C   000081E1           ORR      R0,R1,R0
   \   00000030   00008CE5           STR      R0,[R12, #+0]
   \   00000034   00009CE5           LDR      R0,[R12, #+0]
   \   00000038   800CC0E3           BIC      R0,R0,#0x8000
   \   0000003C   00008CE5           STR      R0,[R12, #+0]
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void pinMode(uint8_t, uint8_t)
   \                     pinMode:
   \   00000000   ........           LDR      R2,??DataTable6  ;; connector
   \   00000004   000192E7           LDR      R0,[R2, +R0, LSL #+2]
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   1EFF2F01           BXEQ     LR
   \   00000010   000051E3           CMP      R1,#+0
   \   00000014   0500001A           BNE      ??pinMode_0
   \   00000018   001090E5           LDR      R1,[R0, #+0]
   \   0000001C   801C81E3           ORR      R1,R1,#0x8000
   \   00000020   001080E5           STR      R1,[R0, #+0]
   \   00000024   001090E5           LDR      R1,[R0, #+0]
   \   00000028   841CC1E3           BIC      R1,R1,#0x8400
   \   0000002C   090000EA           B        ??pinMode_1
   \                     ??pinMode_0:
   \   00000030   010051E3           CMP      R1,#+1
   \   00000034   1EFF2F11           BXNE     LR
   \   00000038   001090E5           LDR      R1,[R0, #+0]
   \   0000003C   801C81E3           ORR      R1,R1,#0x8000
   \   00000040   001080E5           STR      R1,[R0, #+0]
   \   00000044   001090E5           LDR      R1,[R0, #+0]
   \   00000048   401E81E3           ORR      R1,R1,#0x400
   \   0000004C   001080E5           STR      R1,[R0, #+0]
   \   00000050   001090E5           LDR      R1,[R0, #+0]
   \   00000054   801CC1E3           BIC      R1,R1,#0x8000
   \                     ??pinMode_1:
   \   00000058   001080E5           STR      R1,[R0, #+0]
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void digitalWrite(uint8_t, uint8_t)
   \                     digitalWrite:
   \   00000000   ........           LDR      R2,??DataTable6  ;; connector
   \   00000004   000192E7           LDR      R0,[R2, +R0, LSL #+2]
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   1EFF2F01           BXEQ     LR
   \   00000010   010051E3           CMP      R1,#+1
   \   00000014   0800001A           BNE      ??digitalWrite_0
   \   00000018   001090E5           LDR      R1,[R0, #+0]
   \   0000001C   801C81E3           ORR      R1,R1,#0x8000
   \   00000020   001080E5           STR      R1,[R0, #+0]
   \   00000024   001090E5           LDR      R1,[R0, #+0]
   \   00000028   801F81E3           ORR      R1,R1,#0x200
   \   0000002C   001080E5           STR      R1,[R0, #+0]
   \   00000030   001090E5           LDR      R1,[R0, #+0]
   \   00000034   801CC1E3           BIC      R1,R1,#0x8000
   \   00000038   060000EA           B        ??digitalWrite_1
   \                     ??digitalWrite_0:
   \   0000003C   000051E3           CMP      R1,#+0
   \   00000040   1EFF2F11           BXNE     LR
   \   00000044   001090E5           LDR      R1,[R0, #+0]
   \   00000048   801C81E3           ORR      R1,R1,#0x8000
   \   0000004C   001080E5           STR      R1,[R0, #+0]
   \   00000050   001090E5           LDR      R1,[R0, #+0]
   \   00000054   821CC1E3           BIC      R1,R1,#0x8200
   \                     ??digitalWrite_1:
   \   00000058   001080E5           STR      R1,[R0, #+0]
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs int digitalRead(uint8_t)
   \                     digitalRead:
   \   00000000   ........           LDR      R2,??DataTable6  ;; connector
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   000192E7           LDR      R0,[R2, +R0, LSL #+2]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   00009015           LDRNE    R0,[R0, #+0]
   \   00000014   800F0012           ANDNE    R0,R0,#0x200
   \   00000018   A014A011           LSRNE    R1,R0,#+9
   \   0000001C   0100A0E1           MOV      R0,R1
   \   00000020   1EFF2FE1           BX       LR               ;; return
      6          #include "meas.h"
      7          #include "sms.h"
      8          
      9          extern const char MYNUMBER[];
     10          extern const char MAGICWORD[];
     11          
     12          //здесь происходит перехват входящих sms сообщений

   \                                 In segment CODE, align 4, keep-with-next
     13          void my_sms_simif_sm(void)  
     14          {
   \                     my_sms_simif_sm:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
     15            SMS *mysms=NULL; 
     16            char *s;
     17            GBS_MSG msg;
     18            
     19            GBS_ReceiveMessage(&msg);
   \   00000008   0D00A0E1           MOV      R0,SP
   \   0000000C   010100EF           SWI      +257
     20            
     21            if(msg.msg==0x69)
   \   00000010   F200DDE1           LDRSH    R0,[SP, #+2]
   \   00000014   690050E3           CMP      R0,#+105
   \   00000018   2900001A           BNE      ??my_sms_simif_sm_0
     22            {
     23              if(mysms=UnpackTPDU((TPDU*)((char*)msg.data0 + 0x28)))
   \   0000001C   08009DE5           LDR      R0,[SP, #+8]
   \   00000020   280080E2           ADD      R0,R0,#+40
   \   00000024   ........           _BLF     UnpackTPDU,??UnpackTPDU??rA
   \   00000028   0040B0E1           MOVS     R4,R0
   \   0000002C   2400000A           BEQ      ??my_sms_simif_sm_0
     24              { 
     25                if (strcmp_nocase(mysms->number, MYNUMBER)==0) s=mysms->text;
   \   00000030   ........           LDR      R1,??DataTable23  ;; MYNUMBER
   \   00000034   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   1000001A           BNE      ??my_sms_simif_sm_1
   \   00000040   3C5084E2           ADD      R5,R4,#+60
     26                else
     27                { //если номер левый, проверяем наличие волшебного слова
     28                  if(s=strchr(mysms->text, ' '))
     29                  {
     30                    *s=0;
     31                    s++;
     32                    if(strcmp_nocase(mysms->text, MAGICWORD) !=0) s=NULL;
     33                  }
     34                     if(!s)
     35                     {
     36                       mfree(mysms);
     37                       mysms=NULL;
     38                     }
     39                }
     40                if(mysms)
     41                { extern void CheckCmd(char *cmd, SMS *sms);
     42                  SUBPROC((void *)CheckCmd, s, mysms);
   \                     ??my_sms_simif_sm_2:
   \   00000044   8C009FE5           LDR      R0,??my_sms_simif_sm_3  ;; CheckCmd
   \   00000048   0420A0E1           MOV      R2,R4
   \   0000004C   0510A0E1           MOV      R1,R5
   \   00000050   710100EF           SWI      +369
     43                  //подтвержаем что сообщение успешно получено       
     44                  GBS_AcceptMessage();
   \   00000054   020100EF           SWI      +258
     45                  GBS_SendMessage(SMS_TLT_SM, 0x66, 0, 0, 0);
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   01002DE9           PUSH     {R0}
   \   00000060   0030A0E3           MOV      R3,#+0
   \   00000064   0020A0E1           MOV      R2,R0
   \   00000068   6610A0E3           MOV      R1,#+102
   \   0000006C   7300A0E3           MOV      R0,#+115
   \   00000070   400C80E3           ORR      R0,R0,#0x4000
   \   00000074   000100EF           SWI      +256
   \   00000078   04D08DE2           ADD      SP,SP,#+4
   \   0000007C   0000A0E1           NOP              
   \   00000080   3F80BDE8           POP      {R0-R5,PC}
     46                }
   \                     ??my_sms_simif_sm_1:
   \   00000084   2010A0E3           MOV      R1,#+32
   \   00000088   3C0084E2           ADD      R0,R4,#+60
   \   0000008C   180000EF           SWI      +24
   \   00000090   0050B0E1           MOVS     R5,R0
   \   00000094   0600000A           BEQ      ??my_sms_simif_sm_4
   \   00000098   3C109FE5           LDR      R1,??my_sms_simif_sm_3+0x4  ;; MAGICWORD
   \   0000009C   0000A0E3           MOV      R0,#+0
   \   000000A0   ........           STRB     R0,[R5], #+1
   \   000000A4   3C0084E2           ADD      R0,R4,#+60
   \   000000A8   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0100001A           BNE      ??my_sms_simif_sm_5
   \                     ??my_sms_simif_sm_4:
   \   000000B4   000055E3           CMP      R5,#+0
   \   000000B8   E1FFFF1A           BNE      ??my_sms_simif_sm_2
   \                     ??my_sms_simif_sm_5:
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   150000EF           SWI      +21
     47              }
     48            }
     49            
     50            if(!mysms) sms_simif_sm();
   \                     ??my_sms_simif_sm_0:
   \   000000C4   ........           LDR      R0,??DataTable35  ;; sms_simif_sm
   \   000000C8   000090E5           LDR      R0,[R0, #+0]
   \   000000CC   30FF2FE1           BLX      R0
     51            __asm("NOP"); // во избежании генерации инструкции MOV PC,Rn
   \   000000D0   0000A0E1           NOP              
     52          }
   \   000000D4   3F80BDE8           POP      {R0-R5,PC}       ;; return
   \                     ??my_sms_simif_sm_3:
   \   000000D8   ........           DC32     CheckCmd
   \   000000DC   ........           DC32     MAGICWORD
     53          
     54          /******************************************************************************/
     55          

   \                                 In segment DATA_C, align 4, align-sorted
     56          const int minus11=-11;
   \                     minus11:
   \   00000000   F5FFFFFF           DC32 -11

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "CarControl:\\n\\355\\340\\361\\362\\360\\`:
   \   00000000   436172436F6E       DC8 "CarControl:\012\355\340\361\362\360\356\351\352\350 \356\341\355\356\342\353\345\355\373!"
   \              74726F6C3A0A
   \              EDE0F1F2F0EE
   \              E9EAE820EEE1
   \              EDEEE2EBE5ED
   \              FB2100      
   \   00000021   000000             DC8 0, 0, 0
     57          const char ipc_my_name[32]=IPC_CARCONTROL_NAME;
   \                     ipc_my_name:
   \   00000024   434152434F4E       DC8 "CARCONTROL"
   \              54524F4C00  
   \   0000002F   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              000000      
     58          IPC_REQ ipc;
     59          
     60          extern const char LOGFILE[];
     61          
     62          typedef struct
     63          {
     64            CSM_RAM csm;
     65          }MAIN_CSM;
     66          
     67          int maincsm_id;
     68          
     69          //Illumination by BoBa 19.04.2007
     70          ///////////

   \                                 In segment DATA_C, align 4, align-sorted
     71          /*extern*/ const unsigned int ILL_DISP_RECV=30;
   \                     ILL_DISP_RECV:
   \   00000000   1E000000           DC32 30

   \                                 In segment DATA_C, align 4, align-sorted
     72          /*extern*/ const unsigned int ILL_KEYS_RECV=30;
   \                     ILL_KEYS_RECV:
   \   00000000   1E000000           DC32 30

   \                                 In segment DATA_C, align 4, align-sorted
     73          /*extern*/ const unsigned int ILL_DYNL_RECV=100;
   \                     ILL_DYNL_RECV:
   \   00000000   64000000           DC32 100

   \                                 In segment DATA_C, align 4, align-sorted
     74          /*extern*/ const unsigned int ILL_DISP_SEND;
   \                     ILL_DISP_SEND:
   \   00000000   00000000           DC8 0, 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
     75          /*extern*/ const unsigned int ILL_RECV_TMR=3;
   \                     ILL_RECV_TMR:
   \   00000000   03000000           DC32 3

   \                                 In segment DATA_C, align 4, align-sorted
     76          /*extern*/ const unsigned int ILL_RECV_FADE=256;
   \                     ILL_RECV_FADE:
   \   00000000   00010000           DC32 256

   \                                 In segment DATA_C, align 4, align-sorted
     77          /*extern*/ const unsigned int ILL_OFF_FADE=256;
   \                     ILL_OFF_FADE:
   \   00000000   00010000           DC32 256

   \                                 In segment DATA_C, align 4, align-sorted
     78          /*extern*/ const int SLI_State=1;
   \                     SLI_State:
   \   00000000   01000000           DC32 1
     79          
     80          GBSTMR tmr_illumination;
     81           
     82          #pragma swi_number=0x0036
     83          __swi __arm void SLI_SetState(unsigned char state);
     84          

   \                                 In segment CODE, align 4, keep-with-next
     85          void IlluminationOff(){
   \                     IlluminationOff:
   \   00000000   00402DE9           PUSH     {LR}
     86            SetIllumination(0,1,0,ILL_OFF_FADE);
   \   00000004   403FA0E3           MOV      R3,#+256
   \   00000008   0020A0E3           MOV      R2,#+0
   \   0000000C   0110A0E3           MOV      R1,#+1
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   080000EF           SWI      +8
     87            SetIllumination(1,1,0,ILL_OFF_FADE);
   \   00000018   403FA0E3           MOV      R3,#+256
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0110A0E3           MOV      R1,#+1
   \   00000024   0100A0E1           MOV      R0,R1
   \   00000028   080000EF           SWI      +8
     88            SetIllumination(2,1,0,ILL_OFF_FADE);
   \   0000002C   403FA0E3           MOV      R3,#+256
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   0110A0E3           MOV      R1,#+1
   \   00000038   0200A0E3           MOV      R0,#+2
   \   0000003C   080000EF           SWI      +8
     89            #ifdef ELKA
     90            if(SLI_State) SLI_SetState(0);
     91            #endif
     92          }
   \   00000040   0080BDE8           POP      {PC}             ;; return
     93          

   \                                 In segment CODE, align 4, keep-with-next
     94          void IlluminationOn(const int disp, const int key, int dynlight,const int tmr, const int fade){
   \                     IlluminationOn:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   1C809DE5           LDR      R8,[SP, #+28]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0370B0E1           MOVS     R7,R3
     95            if(!tmr) return;
   \   00000018   F083BD08           POPEQ    {R4-R9,PC}
     96            GBS_DelTimer(&tmr_illumination);
   \   0000001C   ........           LDR      R9,??DataTable40  ;; ipc
   \   00000020   400089E2           ADD      R0,R9,#+64
   \   00000024   8C0100EF           SWI      +396
     97            SetIllumination(0,1,disp,fade);
   \   00000028   0830A0E1           MOV      R3,R8
   \   0000002C   0428A0E1           MOV      R2,R4, LSL #+16
   \   00000030   2228A0E1           MOV      R2,R2, LSR #+16
   \   00000034   0110A0E3           MOV      R1,#+1
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   080000EF           SWI      +8
     98            SetIllumination(1,1,key,fade);
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0528A0E1           MOV      R2,R5, LSL #+16
   \   00000048   2228A0E1           MOV      R2,R2, LSR #+16
   \   0000004C   0110A0E3           MOV      R1,#+1
   \   00000050   0100A0E3           MOV      R0,#+1
   \   00000054   080000EF           SWI      +8
     99            SetIllumination(2,1,dynlight,fade);
   \   00000058   0830A0E1           MOV      R3,R8
   \   0000005C   0628A0E1           MOV      R2,R6, LSL #+16
   \   00000060   2228A0E1           MOV      R2,R2, LSR #+16
   \   00000064   0110A0E3           MOV      R1,#+1
   \   00000068   0200A0E3           MOV      R0,#+2
   \   0000006C   080000EF           SWI      +8
    100            #ifdef ELKA
    101            if(SLI_State) SLI_SetState(SLI_State);
    102            #endif 
    103            GBS_StartTimerProc(&tmr_illumination,tmr*225,IlluminationOff);
   \   00000070   10209FE5           LDR      R2,??IlluminationOn_0  ;; IlluminationOff
   \   00000074   E100A0E3           MOV      R0,#+225
   \   00000078   900701E0           MUL      R1,R0,R7
   \   0000007C   400089E2           ADD      R0,R9,#+64
   \   00000080   4D0000EF           SWI      +77
    104          }
   \   00000084   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??IlluminationOn_0:
   \   00000088   ........           DC32     IlluminationOff
    105          //==============================================================================
    106          
    107          GBSTMR tmr_blink;
    108          int blink_n;
    109          

   \                                 In segment CODE, align 4, keep-with-next
    110          void tmr_blink_proc()
    111          {
   \                     tmr_blink_proc:
   \   00000000   10402DE9           PUSH     {R4,LR}
    112            if(blink_n & 1)
   \   00000004   ........           LDR      R4,??DataTable40  ;; ipc
   \   00000008   100094E5           LDR      R0,[R4, #+16]
   \   0000000C   010010E3           TST      R0,#0x1
   \   00000010   1100000A           BEQ      ??tmr_blink_proc_0
    113            {
    114              GBS_DelTimer(&tmr_blink);
   \   00000014   500084E2           ADD      R0,R4,#+80
   \   00000018   8C0100EF           SWI      +396
    115              if(blink_n > 1) SetIllumination(0,1,0,0);
   \   0000001C   100094E5           LDR      R0,[R4, #+16]
   \   00000020   020050E3           CMP      R0,#+2
   \   00000024   040000BA           BLT      ??tmr_blink_proc_1
   \   00000028   0030A0E3           MOV      R3,#+0
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   0110A0E3           MOV      R1,#+1
   \   00000034   0200A0E1           MOV      R0,R2
   \   00000038   080000EF           SWI      +8
    116              SetIllumination(1,1,0,0);
   \                     ??tmr_blink_proc_1:
   \   0000003C   0030A0E3           MOV      R3,#+0
   \   00000040   0020A0E3           MOV      R2,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   0100A0E1           MOV      R0,R1
   \   0000004C   080000EF           SWI      +8
    117              SetIllumination(2,1,0,0);
   \   00000050   0030A0E3           MOV      R3,#+0
   \   00000054   0320A0E1           MOV      R2,R3
   \   00000058   0B0000EA           B        ??tmr_blink_proc_2
    118              #ifdef ELKA
    119              if(SLI_State) SLI_SetState(0);
    120              #endif
    121            }
    122            else
    123            {
    124              SetIllumination(0,1,50,0);
   \                     ??tmr_blink_proc_0:
   \   0000005C   0030A0E3           MOV      R3,#+0
   \   00000060   3220A0E3           MOV      R2,#+50
   \   00000064   0110A0E3           MOV      R1,#+1
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   080000EF           SWI      +8
    125              SetIllumination(1,1,50,0);
   \   00000070   0030A0E3           MOV      R3,#+0
   \   00000074   3220A0E3           MOV      R2,#+50
   \   00000078   0110A0E3           MOV      R1,#+1
   \   0000007C   0100A0E1           MOV      R0,R1
   \   00000080   080000EF           SWI      +8
    126              SetIllumination(2,1,100,0);
   \   00000084   0030A0E3           MOV      R3,#+0
   \   00000088   6420A0E3           MOV      R2,#+100
   \                     ??tmr_blink_proc_2:
   \   0000008C   0110A0E3           MOV      R1,#+1
   \   00000090   0200A0E3           MOV      R0,#+2
   \   00000094   080000EF           SWI      +8
    127              #ifdef ELKA
    128              if(SLI_State) SLI_SetState(1);
    129              #endif  
    130            }
    131          
    132            blink_n--;
   \   00000098   100094E5           LDR      R0,[R4, #+16]
   \   0000009C   010040E2           SUB      R0,R0,#+1
   \   000000A0   100084E5           STR      R0,[R4, #+16]
    133            if(blink_n > 0)
   \   000000A4   010050E3           CMP      R0,#+1
   \   000000A8   1080BDB8           POPLT    {R4,PC}
    134            {
    135              if(blink_n & 1) GBS_StartTimerProc(&tmr_blink, 125, tmr_blink_proc);
   \   000000AC   ........           LDR      R2,??DataTable13  ;; tmr_blink_proc
   \   000000B0   010010E3           TST      R0,#0x1
   \   000000B4   0100000A           BEQ      ??tmr_blink_proc_3
   \   000000B8   7D10A0E3           MOV      R1,#+125
   \   000000BC   000000EA           B        ??tmr_blink_proc_4
    136              else GBS_StartTimerProc(&tmr_blink, 50, tmr_blink_proc);
   \                     ??tmr_blink_proc_3:
   \   000000C0   3210A0E3           MOV      R1,#+50
   \                     ??tmr_blink_proc_4:
   \   000000C4   500084E2           ADD      R0,R4,#+80
   \   000000C8   4D0000EF           SWI      +77
    137            }
    138            
    139          }
   \   000000CC   1080BDE8           POP      {R4,PC}          ;; return
    140          

   \                                 In segment CODE, align 4, keep-with-next
    141          void Blink(int n)
    142          {
   \                     Blink:
   \   00000000   10402DE9           PUSH     {R4,LR}
    143            blink_n=n+(n-1);
   \   00000004   ........           LDR      R4,??DataTable40  ;; ipc
   \   00000008   8000A0E1           LSL      R0,R0,#+1
   \   0000000C   010040E2           SUB      R0,R0,#+1
   \   00000010   100084E5           STR      R0,[R4, #+16]
    144            GBS_DelTimer(&tmr_blink);
   \   00000014   500084E2           ADD      R0,R4,#+80
   \   00000018   8C0100EF           SWI      +396
    145            SetIllumination(0,1,50,0); //display
   \   0000001C   0030A0E3           MOV      R3,#+0
   \   00000020   3220A0E3           MOV      R2,#+50
   \   00000024   0110A0E3           MOV      R1,#+1
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   080000EF           SWI      +8
    146            SetIllumination(1,1,50,0); //key
   \   00000030   0030A0E3           MOV      R3,#+0
   \   00000034   3220A0E3           MOV      R2,#+50
   \   00000038   0110A0E3           MOV      R1,#+1
   \   0000003C   0100A0E1           MOV      R0,R1
   \   00000040   080000EF           SWI      +8
    147            SetIllumination(2,1,100,0); //dynlight
   \   00000044   0030A0E3           MOV      R3,#+0
   \   00000048   6420A0E3           MOV      R2,#+100
   \   0000004C   0110A0E3           MOV      R1,#+1
   \   00000050   0200A0E3           MOV      R0,#+2
   \   00000054   080000EF           SWI      +8
    148            #ifdef ELKA
    149            if(SLI_State) SLI_SetState(1);
    150            #endif
    151            GBS_StartTimerProc(&tmr_blink, 50, tmr_blink_proc);
   \   00000058   ........           LDR      R2,??DataTable13  ;; tmr_blink_proc
   \   0000005C   3210A0E3           MOV      R1,#+50
   \   00000060   500084E2           ADD      R0,R4,#+80
   \   00000064   4D0000EF           SWI      +77
    152          }
   \   00000068   1080BDE8           POP      {R4,PC}          ;; return
    153          
    154          //by KreN 27.09.2007
    155          //============================ воспроизведение звука ===========================
    156          extern const char DIR[];
    157          extern const int soundEnabled;
    158          extern const int sndVolume;

   \                                 In segment DATA_Z, align 4, align-sorted
    159          char *sndLock;
   \                     sndLock:
   \   00000000                      DS8 4
    160          char *sndUnlock;
   \                     sndUnlock:
   \   00000004                      DS8 4
    161          

   \                                 In segment CODE, align 4, keep-with-next
    162          int Play(const char *fname)
    163          {
   \                     Play:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   CCD04DE2           SUB      SP,SP,#+204
   \   00000008   0060A0E1           MOV      R6,R0
    164            if (!IsCalling() && soundEnabled)
   \   0000000C   6E0000EF           SWI      +110
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   4500001A           BNE      ??Play_0
   \   00000018   1C019FE5           LDR      R0,??Play_1      ;; soundEnabled
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   4100000A           BEQ      ??Play_0
    165            {
    166              FSTATS fstats;
    167              unsigned int err;
    168              if (GetFileStats(fname,&fstats,&err)!=-1)
   \   00000028   0D20A0E1           MOV      R2,SP
   \   0000002C   A4108DE2           ADD      R1,SP,#+164
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   840000EF           SWI      +132
   \   00000038   010070E3           CMN      R0,#+1
   \   0000003C   3800000A           BEQ      ??Play_2
    169              {
    170                PLAYFILE_OPT _sfo1;
    171                WSHDR* sndPath=AllocWS(128);
   \   00000040   8000A0E3           MOV      R0,#+128
   \   00000044   250100EF           SWI      +293
   \   00000048   0040A0E1           MOV      R4,R0
    172                WSHDR* sndFName=AllocWS(128);
   \   0000004C   8000A0E3           MOV      R0,#+128
   \   00000050   250100EF           SWI      +293
   \   00000054   0050A0E1           MOV      R5,R0
    173                char s[128];
    174                const char *p=strrchr(fname,'\\')+1;
   \   00000058   5C10A0E3           MOV      R1,#+92
   \   0000005C   0600A0E1           MOV      R0,R6
   \   00000060   170100EF           SWI      +279
   \   00000064   017080E2           ADD      R7,R0,#+1
    175                str_2ws(sndFName,p,128);
   \   00000068   8020A0E3           MOV      R2,#+128
   \   0000006C   0710A0E1           MOV      R1,R7
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   6C0100EF           SWI      +364
    176                strncpy(s,fname,p-fname);
   \   00000078   067047E0           SUB      R7,R7,R6
   \   0000007C   0720A0E1           MOV      R2,R7
   \   00000080   0610A0E1           MOV      R1,R6
   \   00000084   24008DE2           ADD      R0,SP,#+36
   \   00000088   160100EF           SWI      +278
    177                s[p-fname]='\0';
   \   0000008C   0060A0E3           MOV      R6,#+0
   \   00000090   24008DE2           ADD      R0,SP,#+36
   \   00000094   0060C7E7           STRB     R6,[R7, +R0]
    178                str_2ws(sndPath,s,128);
   \   00000098   8020A0E3           MOV      R2,#+128
   \   0000009C   24108DE2           ADD      R1,SP,#+36
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   6C0100EF           SWI      +364
    179          
    180                zeromem(&_sfo1,sizeof(PLAYFILE_OPT));
   \   000000A8   2010A0E3           MOV      R1,#+32
   \   000000AC   04008DE2           ADD      R0,SP,#+4
   \   000000B0   1D0100EF           SWI      +285
    181                _sfo1.repeat_num=1;
    182                _sfo1.time_between_play=0;
    183                _sfo1.play_first=0;
    184                _sfo1.volume=sndVolume;
   \   000000B4   84209FE5           LDR      R2,??Play_1+0x4  ;; sndVolume
   \   000000B8   0100A0E3           MOV      R0,#+1
   \   000000BC   B400CDE1           STRH     R0,[SP, #+4]
   \   000000C0   08608DE5           STR      R6,[SP, #+8]
   \   000000C4   0C608DE5           STR      R6,[SP, #+12]
   \   000000C8   002092E5           LDR      R2,[R2, #+0]
   \   000000CC   10208DE5           STR      R2,[SP, #+16]
    185          #ifdef NEWSGOLD
    186                _sfo1.unk6=1;
    187                _sfo1.unk7=1;
    188                _sfo1.unk9=2;
    189                PlayFile(0x10, sndPath, sndFName, GBS_GetCurCepid(), MSG_PLAYFILE_REPORT, &_sfo1);
    190          #else
    191          #ifdef X75
    192                _sfo1.unk4=0x80000000;
   \   000000D0   8024A0E3           MOV      R2,#-2147483648
   \   000000D4   14208DE5           STR      R2,[SP, #+20]
    193                _sfo1.unk5=1;
   \   000000D8   18008DE5           STR      R0,[SP, #+24]
    194                PlayFile(0xC, sndPath, sndFName, 0,GBS_GetCurCepid(), MSG_PLAYFILE_REPORT, &_sfo1);
   \   000000DC   450100EF           SWI      +325
   \   000000E0   04108DE2           ADD      R1,SP,#+4
   \   000000E4   02002DE9           PUSH     {R1}
   \   000000E8   0030A0E3           MOV      R3,#+0
   \   000000EC   0520A0E1           MOV      R2,R5
   \   000000F0   5D1FA0E3           MOV      R1,#+372
   \   000000F4   02002DE9           PUSH     {R1}
   \   000000F8   01002DE9           PUSH     {R0}
   \   000000FC   0410A0E1           MOV      R1,R4
   \   00000100   0C00A0E3           MOV      R0,#+12
   \   00000104   4A0000EF           SWI      +74
    195          #else
    196                _sfo1.unk5=1;
    197                PlayFile(0xC, sndPath, sndFName, GBS_GetCurCepid(), MSG_PLAYFILE_REPORT, &_sfo1);
    198          #endif
    199          #endif
    200                FreeWS(sndPath);
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   290100EF           SWI      +297
    201                FreeWS(sndFName);
   \   00000110   0500A0E1           MOV      R0,R5
   \   00000114   290100EF           SWI      +297
    202                return 1;
   \   00000118   0100A0E3           MOV      R0,#+1
   \   0000011C   0CD08DE2           ADD      SP,SP,#+12
   \   00000120   000000EA           B        ??Play_3
    203              }else return 0;
   \                     ??Play_2:
   \   00000124   0000A0E3           MOV      R0,#+0
   \                     ??Play_3:
   \   00000128   CCD08DE2           ADD      SP,SP,#+204
   \   0000012C   F080BDE8           POP      {R4-R7,PC}
    204            }else return 2; 
   \                     ??Play_0:
   \   00000130   0200A0E3           MOV      R0,#+2
   \   00000134   CCD08DE2           ADD      SP,SP,#+204
   \   00000138   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??Play_1:
   \   0000013C   ........           DC32     soundEnabled
   \   00000140   ........           DC32     sndVolume
    205          }
    206          //==============================================================================
    207          #define  SHORT 0
    208          #define  LONG  1
    209          #define  DOUBLESHORT 2
    210          #define  LONG_AND_SHORT 3
    211          
    212          extern const char lock_word[];
    213          extern const char unlock_word[];
    214          extern const char start_word[];
    215          extern const char stop_word[];
    216          extern const char trunk_word[];
    217          extern const char search_word[];
    218          extern const char panicOn_word[];
    219          extern const char panicOff_word[];
    220          
    221          extern const int lock_t;
    222          extern const int lock_key1;
    223          extern const int lock_key2;
    224          extern const int lock_delay;
    225          
    226          extern const int unlock_t;
    227          extern const int unlock_key1;
    228          extern const int unlock_key2;
    229          extern const int unlock_delay;
    230          
    231          extern const int start_t;
    232          extern const int start_key1;
    233          extern const int start_key2;
    234          extern const int start_delay;
    235          
    236          extern const int stop_t;
    237          extern const int stop_key1;
    238          extern const int stop_key2;
    239          extern const int stop_delay;
    240          
    241          extern const int trunk_t;
    242          extern const int trunk_key1;
    243          extern const int trunk_key2;
    244          extern const int trunk_delay;
    245          
    246          extern const int search_t;
    247          extern const int search_key1;
    248          extern const int search_key2;
    249          extern const int search_delay;
    250          
    251          extern const int panicOn_t;
    252          extern const int panicOn_key1;
    253          extern const int panicOn_key2;
    254          extern const int panicOn_delay;
    255          
    256          extern const int panicOff_t;
    257          extern const int panicOff_key1;
    258          extern const int panicOff_key2;
    259          extern const int panicOff_delay;
    260          
    261          int keytab[]={0, TX, RX, CTS, RTS};
    262          
    263          GBSTMR tmr_key;
    264          int type,pin1,pin2,n,delay;
    265          

   \                                 In segment CODE, align 4, keep-with-next
    266          void tmr_key_proc()
    267          {
   \                     tmr_key_proc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    268            if(digitalRead(pin1) || digitalRead(pin2))
   \   00000004   ........           LDR      R4,??DataTable40  ;; ipc
   \   00000008   2C5094E5           LDR      R5,[R4, #+44]
   \   0000000C   FF0005E2           AND      R0,R5,#0xFF
   \   00000010   ........           BL       digitalRead
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0400001A           BNE      ??tmr_key_proc_0
   \   0000001C   300094E5           LDR      R0,[R4, #+48]
   \   00000020   FF0000E2           AND      R0,R0,#0xFF
   \   00000024   ........           BL       digitalRead
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0700000A           BEQ      ??tmr_key_proc_1
    269            {
    270              pinMode(pin1, INPUT);
   \                     ??tmr_key_proc_0:
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   FF0005E2           AND      R0,R5,#0xFF
   \   00000038   ........           BL       pinMode
    271              pinMode(pin2, INPUT);
   \   0000003C   300094E5           LDR      R0,[R4, #+48]
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   FF0000E2           AND      R0,R0,#0xFF
   \   00000048   ........           BL       pinMode
   \   0000004C   0E0000EA           B        ??tmr_key_proc_2
    272            }
    273            else
    274            {
    275              pinMode(pin1, OUTPUT);
   \                     ??tmr_key_proc_1:
   \   00000050   0110A0E3           MOV      R1,#+1
   \   00000054   FF0005E2           AND      R0,R5,#0xFF
   \   00000058   ........           BL       pinMode
    276              digitalWrite(pin1, HIGH);
   \   0000005C   2C0094E5           LDR      R0,[R4, #+44]
   \   00000060   0110A0E3           MOV      R1,#+1
   \   00000064   FF0000E2           AND      R0,R0,#0xFF
   \   00000068   ........           BL       digitalWrite
    277              pinMode(pin2, OUTPUT);
   \   0000006C   300094E5           LDR      R0,[R4, #+48]
   \   00000070   0110A0E3           MOV      R1,#+1
   \   00000074   FF0000E2           AND      R0,R0,#0xFF
   \   00000078   ........           BL       pinMode
    278              digitalWrite(pin2, HIGH);
   \   0000007C   300094E5           LDR      R0,[R4, #+48]
   \   00000080   0110A0E3           MOV      R1,#+1
   \   00000084   FF0000E2           AND      R0,R0,#0xFF
   \   00000088   ........           BL       digitalWrite
    279            }
    280             
    281            if(type==LONG_AND_SHORT)
   \                     ??tmr_key_proc_2:
   \   0000008C   280094E5           LDR      R0,[R4, #+40]
   \   00000090   305094E5           LDR      R5,[R4, #+48]
   \   00000094   030050E3           CMP      R0,#+3
   \   00000098   0200001A           BNE      ??tmr_key_proc_3
    282            {
    283              if(pin2) pin1=0;   
   \   0000009C   000055E3           CMP      R5,#+0
   \   000000A0   0000A013           MOVNE    R0,#+0
   \   000000A4   2C008415           STRNE    R0,[R4, #+44]
    284            }
    285            
    286            n--;
   \                     ??tmr_key_proc_3:
   \   000000A8   340094E5           LDR      R0,[R4, #+52]
   \   000000AC   010040E2           SUB      R0,R0,#+1
   \   000000B0   340084E5           STR      R0,[R4, #+52]
    287            if(n > 0)
   \   000000B4   010050E3           CMP      R0,#+1
   \   000000B8   7080BDB8           POPLT    {R4-R6,PC}
    288            {  
    289              if(digitalRead(pin1) == 0 && digitalRead(pin2) == 0 ) GBS_StartTimerProc(&tmr_key, (delay*225)/2, tmr_key_proc);//пауза
   \   000000BC   2C0094E5           LDR      R0,[R4, #+44]
   \   000000C0   ........           LDR      R6,??DataTable17  ;; tmr_key_proc
   \   000000C4   FF0000E2           AND      R0,R0,#0xFF
   \   000000C8   ........           BL       digitalRead
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   0A00001A           BNE      ??tmr_key_proc_4
   \   000000D4   FF0005E2           AND      R0,R5,#0xFF
   \   000000D8   ........           BL       digitalRead
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   0600001A           BNE      ??tmr_key_proc_4
   \   000000E4   380094E5           LDR      R0,[R4, #+56]
   \   000000E8   E110A0E3           MOV      R1,#+225
   \   000000EC   910000E0           MUL      R0,R1,R0
   \   000000F0   0620A0E1           MOV      R2,R6
   \   000000F4   A00F80E0           ADD      R0,R0,R0, LSR #+31
   \   000000F8   C010A0E1           ASR      R1,R0,#+1
   \   000000FC   010000EA           B        ??tmr_key_proc_5
    290              else
    291                GBS_StartTimerProc(&tmr_key, 10, tmr_key_proc);
   \                     ??tmr_key_proc_4:
   \   00000100   0620A0E1           MOV      R2,R6
   \   00000104   0A10A0E3           MOV      R1,#+10
   \                     ??tmr_key_proc_5:
   \   00000108   600084E2           ADD      R0,R4,#+96
   \   0000010C   4D0000EF           SWI      +77
    292            }
    293          }
   \   00000110   7080BDE8           POP      {R4-R6,PC}       ;; return
    294          

   \                                 In segment CODE, align 4, keep-with-next
    295          void keyPress(int _type, int _key1, int _key2, int _delay)
    296          {
   \                     keyPress:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    297            type=_type;
   \   00000004   ........           LDR      R4,??DataTable40  ;; ipc
   \   00000008   280084E5           STR      R0,[R4, #+40]
    298            pin1=keytab[_key1];
   \   0000000C   010184E0           ADD      R0,R4,R1, LSL #+2
   \   00000010   140090E5           LDR      R0,[R0, #+20]
    299            pin2=keytab[_key2];  
   \   00000014   021184E0           ADD      R1,R4,R2, LSL #+2
    300            delay=_delay;
    301            n=1;
    302            if(type==DOUBLESHORT || type==LONG_AND_SHORT) n=2;
   \   00000018   282094E5           LDR      R2,[R4, #+40]
   \   0000001C   2C0084E5           STR      R0,[R4, #+44]
   \   00000020   141091E5           LDR      R1,[R1, #+20]
   \   00000024   383084E5           STR      R3,[R4, #+56]
   \   00000028   301084E5           STR      R1,[R4, #+48]
   \   0000002C   0110A0E3           MOV      R1,#+1
   \   00000030   020052E3           CMP      R2,#+2
   \   00000034   03005213           CMPNE    R2,#+3
   \   00000038   0210A003           MOVEQ    R1,#+2
    303              
    304            n=n+(n-1);
   \   0000003C   8110A0E1           LSL      R1,R1,#+1
   \   00000040   011041E2           SUB      R1,R1,#+1
   \   00000044   341084E5           STR      R1,[R4, #+52]
    305            
    306            if(n > 0)
   \   00000048   010051E3           CMP      R1,#+1
   \   0000004C   3080BDB8           POPLT    {R4,R5,PC}
    307            {
    308              if(type==LONG_AND_SHORT)
   \   00000050   ........           LDR      R5,??DataTable17  ;; tmr_key_proc
   \   00000054   030052E3           CMP      R2,#+3
   \   00000058   0D00001A           BNE      ??keyPress_0
    309              {
    310                pinMode(pin1, OUTPUT);
   \   0000005C   0110A0E3           MOV      R1,#+1
   \   00000060   FF0000E2           AND      R0,R0,#0xFF
   \   00000064   ........           BL       pinMode
    311                digitalWrite(pin1, HIGH);
   \   00000068   2C0094E5           LDR      R0,[R4, #+44]
   \   0000006C   0110A0E3           MOV      R1,#+1
   \   00000070   FF0000E2           AND      R0,R0,#0xFF
   \   00000074   ........           BL       digitalWrite
    312                GBS_StartTimerProc(&tmr_key, delay*225, tmr_key_proc);
   \   00000078   380094E5           LDR      R0,[R4, #+56]
   \   0000007C   0520A0E1           MOV      R2,R5
   \   00000080   E130A0E3           MOV      R3,#+225
   \   00000084   930001E0           MUL      R1,R3,R0
   \   00000088   600084E2           ADD      R0,R4,#+96
   \   0000008C   4D0000EF           SWI      +77
   \   00000090   3080BDE8           POP      {R4,R5,PC}
    313              }
    314              else if(type==DOUBLESHORT)
   \                     ??keyPress_0:
   \   00000094   020052E3           CMP      R2,#+2
   \   00000098   0400001A           BNE      ??keyPress_1
    315                {
    316                  pinMode(pin1, OUTPUT);
   \   0000009C   0110A0E3           MOV      R1,#+1
   \   000000A0   FF0000E2           AND      R0,R0,#0xFF
   \   000000A4   ........           BL       pinMode
    317                  digitalWrite(pin1, HIGH);
   \   000000A8   2C0094E5           LDR      R0,[R4, #+44]
   \   000000AC   0D0000EA           B        ??keyPress_2
    318                  GBS_StartTimerProc(&tmr_key, 10, tmr_key_proc);        
    319                }
    320              else if(type==SHORT)
   \                     ??keyPress_1:
   \   000000B0   000052E3           CMP      R2,#+0
   \   000000B4   1100001A           BNE      ??keyPress_3
    321                {
    322                  pinMode(pin1, OUTPUT);
   \   000000B8   0110A0E3           MOV      R1,#+1
   \   000000BC   FF0000E2           AND      R0,R0,#0xFF
   \   000000C0   ........           BL       pinMode
    323                  digitalWrite(pin1, HIGH);
   \   000000C4   2C0094E5           LDR      R0,[R4, #+44]
   \   000000C8   0110A0E3           MOV      R1,#+1
   \   000000CC   FF0000E2           AND      R0,R0,#0xFF
   \   000000D0   ........           BL       digitalWrite
    324                  pinMode(pin2, OUTPUT);
   \   000000D4   300094E5           LDR      R0,[R4, #+48]
   \   000000D8   0110A0E3           MOV      R1,#+1
   \   000000DC   FF0000E2           AND      R0,R0,#0xFF
   \   000000E0   ........           BL       pinMode
    325                  digitalWrite(pin2, HIGH);
   \   000000E4   300094E5           LDR      R0,[R4, #+48]
   \                     ??keyPress_2:
   \   000000E8   0110A0E3           MOV      R1,#+1
   \   000000EC   FF0000E2           AND      R0,R0,#0xFF
   \   000000F0   ........           BL       digitalWrite
    326                  GBS_StartTimerProc(&tmr_key, 10, tmr_key_proc);
   \   000000F4   0520A0E1           MOV      R2,R5
   \   000000F8   0A10A0E3           MOV      R1,#+10
   \   000000FC   140000EA           B        ??keyPress_4
    327                }
    328              else if(type==LONG)
   \                     ??keyPress_3:
   \   00000100   010052E3           CMP      R2,#+1
   \   00000104   3080BD18           POPNE    {R4,R5,PC}
    329                {
    330                  pinMode(pin1, OUTPUT);
   \   00000108   0110A0E3           MOV      R1,#+1
   \   0000010C   FF0000E2           AND      R0,R0,#0xFF
   \   00000110   ........           BL       pinMode
    331                  digitalWrite(pin1, HIGH);
   \   00000114   2C0094E5           LDR      R0,[R4, #+44]
   \   00000118   0110A0E3           MOV      R1,#+1
   \   0000011C   FF0000E2           AND      R0,R0,#0xFF
   \   00000120   ........           BL       digitalWrite
    332                  pinMode(pin2, OUTPUT);
   \   00000124   300094E5           LDR      R0,[R4, #+48]
   \   00000128   0110A0E3           MOV      R1,#+1
   \   0000012C   FF0000E2           AND      R0,R0,#0xFF
   \   00000130   ........           BL       pinMode
    333                  digitalWrite(pin2, HIGH);
   \   00000134   300094E5           LDR      R0,[R4, #+48]
   \   00000138   0110A0E3           MOV      R1,#+1
   \   0000013C   FF0000E2           AND      R0,R0,#0xFF
   \   00000140   ........           BL       digitalWrite
    334                  GBS_StartTimerProc(&tmr_key, delay * 225, tmr_key_proc);
   \   00000144   380094E5           LDR      R0,[R4, #+56]
   \   00000148   0520A0E1           MOV      R2,R5
   \   0000014C   E130A0E3           MOV      R3,#+225
   \   00000150   930001E0           MUL      R1,R3,R0
   \                     ??keyPress_4:
   \   00000154   600084E2           ADD      R0,R4,#+96
   \   00000158   4D0000EF           SWI      +77
    335                }
    336            }
    337          }
   \   0000015C   3080BDE8           POP      {R4,R5,PC}       ;; return
    338          /******************************************************************************/
    339          

   \                                 In segment CODE, align 4, keep-with-next
    340          void CheckCmd(char *cmd, SMS *sms)
    341          {
   \                     CheckCmd:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   0040A0E1           MOV      R4,R0
    342            char s[32];
    343            const char *snd;
    344            
    345            if(strcmp_nocase(cmd, start_word)==0)
   \   0000000C   ........           LDR      R6,??DataTable34  ;; sndLock
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   10129FE5           LDR      R1,??CheckCmd_0  ;; start_word
   \   00000018   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0A00001A           BNE      ??CheckCmd_1
    346            {
    347              keyPress(start_t, start_key1, start_key2, start_delay);
   \   00000024   ........           LDR      R0,??DataTable24  ;; start_delay
   \   00000028   003090E5           LDR      R3,[R0, #+0]
   \   0000002C   ........           LDR      R0,??DataTable25  ;; start_key2
   \   00000030   002090E5           LDR      R2,[R0, #+0]
   \   00000034   ........           LDR      R0,??DataTable26  ;; start_key1
   \   00000038   001090E5           LDR      R1,[R0, #+0]
   \   0000003C   ........           LDR      R0,??DataTable27  ;; start_t
   \                     ??CheckCmd_2:
   \   00000040   000090E5           LDR      R0,[R0, #+0]
   \   00000044   ........           BL       keyPress
    348              snd=sndUnlock;
   \   00000048   046096E5           LDR      R6,[R6, #+4]
   \   0000004C   5E0000EA           B        ??CheckCmd_3
    349            }
    350            else if(strcmp_nocase(cmd, stop_word)==0)
   \                     ??CheckCmd_1:
   \   00000050   D8119FE5           LDR      R1,??CheckCmd_0+0x4  ;; stop_word
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0900001A           BNE      ??CheckCmd_4
    351            {
    352              keyPress(stop_t, stop_key1, stop_key2, stop_delay);
   \   00000064   C8019FE5           LDR      R0,??CheckCmd_0+0x8  ;; stop_delay
   \   00000068   003090E5           LDR      R3,[R0, #+0]
   \   0000006C   C4019FE5           LDR      R0,??CheckCmd_0+0xC  ;; stop_key2
   \   00000070   002090E5           LDR      R2,[R0, #+0]
   \   00000074   C0019FE5           LDR      R0,??CheckCmd_0+0x10  ;; stop_key1
   \   00000078   001090E5           LDR      R1,[R0, #+0]
   \   0000007C   BC019FE5           LDR      R0,??CheckCmd_0+0x14  ;; stop_t
   \                     ??CheckCmd_5:
   \   00000080   000090E5           LDR      R0,[R0, #+0]
   \   00000084   ........           BL       keyPress
    353              snd=sndLock;
   \   00000088   4E0000EA           B        ??CheckCmd_6
    354            }
    355            else if(strcmp_nocase(cmd, unlock_word)==0)
   \                     ??CheckCmd_4:
   \   0000008C   B0119FE5           LDR      R1,??CheckCmd_0+0x18  ;; unlock_word
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0600001A           BNE      ??CheckCmd_7
    356            {
    357              keyPress(unlock_t, unlock_key1, unlock_key2, 0);
   \   000000A0   A0019FE5           LDR      R0,??CheckCmd_0+0x1C  ;; unlock_key2
   \   000000A4   0030A0E3           MOV      R3,#+0
   \   000000A8   002090E5           LDR      R2,[R0, #+0]
   \   000000AC   98019FE5           LDR      R0,??CheckCmd_0+0x20  ;; unlock_key1
   \   000000B0   001090E5           LDR      R1,[R0, #+0]
   \   000000B4   94019FE5           LDR      R0,??CheckCmd_0+0x24  ;; unlock_t
   \   000000B8   E0FFFFEA           B        ??CheckCmd_2
    358              snd=sndUnlock;
    359            }
    360            else if(strcmp_nocase(cmd, lock_word)==0)
   \                     ??CheckCmd_7:
   \   000000BC   90119FE5           LDR      R1,??CheckCmd_0+0x28  ;; lock_word
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   0600001A           BNE      ??CheckCmd_8
    361            {
    362              keyPress(lock_t, lock_key1, lock_key2, 0);
   \   000000D0   80019FE5           LDR      R0,??CheckCmd_0+0x2C  ;; lock_key2
   \   000000D4   0030A0E3           MOV      R3,#+0
   \   000000D8   002090E5           LDR      R2,[R0, #+0]
   \   000000DC   78019FE5           LDR      R0,??CheckCmd_0+0x30  ;; lock_key1
   \   000000E0   001090E5           LDR      R1,[R0, #+0]
   \   000000E4   74019FE5           LDR      R0,??CheckCmd_0+0x34  ;; lock_t
   \   000000E8   E4FFFFEA           B        ??CheckCmd_5
    363              snd=sndLock;
    364            }
    365            else if(strcmp_nocase(cmd, trunk_word)==0)
   \                     ??CheckCmd_8:
   \   000000EC   70119FE5           LDR      R1,??CheckCmd_0+0x38  ;; trunk_word
   \   000000F0   0400A0E1           MOV      R0,R4
   \   000000F4   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   0700001A           BNE      ??CheckCmd_9
    366            {
    367              keyPress(trunk_t, trunk_key1, trunk_key2, trunk_delay);
   \   00000100   60019FE5           LDR      R0,??CheckCmd_0+0x3C  ;; trunk_delay
   \   00000104   003090E5           LDR      R3,[R0, #+0]
   \   00000108   5C019FE5           LDR      R0,??CheckCmd_0+0x40  ;; trunk_key2
   \   0000010C   002090E5           LDR      R2,[R0, #+0]
   \   00000110   58019FE5           LDR      R0,??CheckCmd_0+0x44  ;; trunk_key1
   \   00000114   001090E5           LDR      R1,[R0, #+0]
   \   00000118   54019FE5           LDR      R0,??CheckCmd_0+0x48  ;; trunk_t
   \   0000011C   C7FFFFEA           B        ??CheckCmd_2
    368              snd=sndUnlock;
    369            }
    370            else if(strcmp_nocase(cmd, search_word)==0)
   \                     ??CheckCmd_9:
   \   00000120   50119FE5           LDR      R1,??CheckCmd_0+0x4C  ;; search_word
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   0000012C   000050E3           CMP      R0,#+0
   \   00000130   0700001A           BNE      ??CheckCmd_10
    371            {
    372              keyPress(search_t, search_key1, search_key2, search_delay);
   \   00000134   40019FE5           LDR      R0,??CheckCmd_0+0x50  ;; search_delay
   \   00000138   003090E5           LDR      R3,[R0, #+0]
   \   0000013C   3C019FE5           LDR      R0,??CheckCmd_0+0x54  ;; search_key2
   \   00000140   002090E5           LDR      R2,[R0, #+0]
   \   00000144   38019FE5           LDR      R0,??CheckCmd_0+0x58  ;; search_key1
   \   00000148   001090E5           LDR      R1,[R0, #+0]
   \   0000014C   34019FE5           LDR      R0,??CheckCmd_0+0x5C  ;; search_t
   \   00000150   BAFFFFEA           B        ??CheckCmd_2
    373              snd=sndUnlock;
    374            }  
    375            else if(strcmp_nocase(cmd, panicOn_word)==0)
   \                     ??CheckCmd_10:
   \   00000154   30119FE5           LDR      R1,??CheckCmd_0+0x60  ;; panicOn_word
   \   00000158   0400A0E1           MOV      R0,R4
   \   0000015C   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   00000160   000050E3           CMP      R0,#+0
   \   00000164   0900001A           BNE      ??CheckCmd_11
    376            {
    377              keyPress(panicOn_t, panicOn_key1, panicOn_key2, panicOn_delay);
   \   00000168   20019FE5           LDR      R0,??CheckCmd_0+0x64  ;; panicOn_delay
   \   0000016C   003090E5           LDR      R3,[R0, #+0]
   \   00000170   1C019FE5           LDR      R0,??CheckCmd_0+0x68  ;; panicOn_key2
   \   00000174   002090E5           LDR      R2,[R0, #+0]
   \   00000178   18019FE5           LDR      R0,??CheckCmd_0+0x6C  ;; panicOn_key1
   \   0000017C   001090E5           LDR      R1,[R0, #+0]
   \   00000180   14019FE5           LDR      R0,??CheckCmd_0+0x70  ;; panicOn_t
   \   00000184   000090E5           LDR      R0,[R0, #+0]
   \   00000188   ........           BL       keyPress
    378              snd=sndLock;
   \   0000018C   0D0000EA           B        ??CheckCmd_6
    379            }
    380            else if(strcmp_nocase(cmd, panicOff_word)==0)
   \                     ??CheckCmd_11:
   \   00000190   08119FE5           LDR      R1,??CheckCmd_0+0x74  ;; panicOff_word
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   0000019C   000050E3           CMP      R0,#+0
   \   000001A0   0700001A           BNE      ??CheckCmd_12
    381            {
    382              keyPress(panicOff_t, panicOff_key1, panicOff_key2, panicOff_delay);
   \   000001A4   F8009FE5           LDR      R0,??CheckCmd_0+0x78  ;; panicOff_delay
   \   000001A8   003090E5           LDR      R3,[R0, #+0]
   \   000001AC   F4009FE5           LDR      R0,??CheckCmd_0+0x7C  ;; panicOff_key2
   \   000001B0   002090E5           LDR      R2,[R0, #+0]
   \   000001B4   F0009FE5           LDR      R0,??CheckCmd_0+0x80  ;; panicOff_key1
   \   000001B8   001090E5           LDR      R1,[R0, #+0]
   \   000001BC   EC009FE5           LDR      R0,??CheckCmd_0+0x84  ;; panicOff_t
   \   000001C0   AEFFFFEA           B        ??CheckCmd_5
    383              snd=sndLock;
    384            }  
    385            else
    386            {
    387              cmd=NULL;
   \                     ??CheckCmd_12:
   \   000001C4   0040A0E3           MOV      R4,#+0
    388              snd=sndLock;
   \                     ??CheckCmd_6:
   \   000001C8   006096E5           LDR      R6,[R6, #+0]
    389            }
    390              
    391            IlluminationOn(ILL_DISP_RECV,ILL_KEYS_RECV,ILL_DYNL_RECV,ILL_RECV_TMR,ILL_RECV_FADE);
   \                     ??CheckCmd_3:
   \   000001CC   400FA0E3           MOV      R0,#+256
   \   000001D0   01002DE9           PUSH     {R0}
   \   000001D4   0330A0E3           MOV      R3,#+3
   \   000001D8   6420A0E3           MOV      R2,#+100
   \   000001DC   1E10A0E3           MOV      R1,#+30
   \   000001E0   1E00A0E3           MOV      R0,#+30
   \   000001E4   ........           BL       IlluminationOn
    392            Play(snd);
   \   000001E8   0600A0E1           MOV      R0,R6
   \   000001EC   ........           BL       Play
    393            
    394            if(cmd)
   \   000001F0   BC109FE5           LDR      R1,??CheckCmd_0+0x88  ;; `?<Constant "CarControl:\\n\\315\\345\\350\\347\\342\\`
   \   000001F4   000054E3           CMP      R4,#+0
   \   000001F8   04D08DE2           ADD      SP,SP,#+4
   \   000001FC   0400000A           BEQ      ??CheckCmd_13
    395            {
    396              sprintf(s,"CarControl:\n%s", cmd);
   \   00000200   0420A0E1           MOV      R2,R4
   \   00000204   241081E2           ADD      R1,R1,#+36
   \   00000208   0D00A0E1           MOV      R0,SP
   \   0000020C   160000EF           SWI      +22
    397              ShowMSG(0x11,(int)s);
   \   00000210   0D10A0E1           MOV      R1,SP
    398            }
    399            else
    400              ShowMSG(0x11,(int)"CarControl:\nНеизвестная команда!");
   \                     ??CheckCmd_13:
   \   00000214   1100A0E3           MOV      R0,#+17
   \   00000218   480100EF           SWI      +328
    401          
    402            mfree(sms);
   \   0000021C   0500A0E1           MOV      R0,R5
   \   00000220   150000EF           SWI      +21
    403          }
   \   00000224   20D08DE2           ADD      SP,SP,#+32
   \   00000228   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??CheckCmd_0:
   \   0000022C   ........           DC32     start_word
   \   00000230   ........           DC32     stop_word
   \   00000234   ........           DC32     stop_delay
   \   00000238   ........           DC32     stop_key2
   \   0000023C   ........           DC32     stop_key1
   \   00000240   ........           DC32     stop_t
   \   00000244   ........           DC32     unlock_word
   \   00000248   ........           DC32     unlock_key2
   \   0000024C   ........           DC32     unlock_key1
   \   00000250   ........           DC32     unlock_t
   \   00000254   ........           DC32     lock_word
   \   00000258   ........           DC32     lock_key2
   \   0000025C   ........           DC32     lock_key1
   \   00000260   ........           DC32     lock_t
   \   00000264   ........           DC32     trunk_word
   \   00000268   ........           DC32     trunk_delay
   \   0000026C   ........           DC32     trunk_key2
   \   00000270   ........           DC32     trunk_key1
   \   00000274   ........           DC32     trunk_t
   \   00000278   ........           DC32     search_word
   \   0000027C   ........           DC32     search_delay
   \   00000280   ........           DC32     search_key2
   \   00000284   ........           DC32     search_key1
   \   00000288   ........           DC32     search_t
   \   0000028C   ........           DC32     panicOn_word
   \   00000290   ........           DC32     panicOn_delay
   \   00000294   ........           DC32     panicOn_key2
   \   00000298   ........           DC32     panicOn_key1
   \   0000029C   ........           DC32     panicOn_t
   \   000002A0   ........           DC32     panicOff_word
   \   000002A4   ........           DC32     panicOff_delay
   \   000002A8   ........           DC32     panicOff_key2
   \   000002AC   ........           DC32     panicOff_key1
   \   000002B0   ........           DC32     panicOff_t
   \   000002B4   ........           DC32     `?<Constant "CarControl:\\n\\315\\345\\350\\347\\342\\`
    404          
    405          GBSTMR tmr_call;
    406          

   \                                 In segment CODE, align 4, keep-with-next
    407          void UnpackIncomingNumber(char *s)
    408          {
   \                     UnpackIncomingNumber:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    409            char *p=RamCallState()+ 0x5A;
   \   00000008   908200EF           SWI      +33424
   \   0000000C   5A0080E2           ADD      R0,R0,#+90
    410            //Длина номера в байтах
    411            int i=*p++;
   \   00000010   ........           LDRB     R1,[R0], #+1
    412            //Длина номера в ниблах
    413            i=s[i]&0x0F?(i-1)*8/4-1:(i-1)*8/4;
    414            //Если номер в международном формате добавляем '+'
    415            if (*p++==0x91) {*s='+'; s++;};  
    416            unsigned int m=0;
    417            char c=0;
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   0420D1E7           LDRB     R2,[R1, +R4]
   \   0000001C   011041E2           SUB      R1,R1,#+1
   \   00000020   8111A0E1           LSL      R1,R1,#+3
   \   00000024   0F0012E3           TST      R2,#0xF
   \   00000028   C120A0E1           ASR      R2,R1,#+1
   \   0000002C   221F81E0           ADD      R1,R1,R2, LSR #+30
   \   00000030   ........           LDRB     R2,[R0], #+1
   \   00000034   4111A0E1           ASR      R1,R1,#+2
   \   00000038   01104112           SUBNE    R1,R1,#+1
   \   0000003C   910052E3           CMP      R2,#+145
   \   00000040   2B20A003           MOVEQ    R2,#+43
   \   00000044   ........           STRBEQ   R2,[R4], #+1
   \   00000048   0020A0E3           MOV      R2,#+0
   \   0000004C   02C0A0E1           MOV      R12,R2
   \   00000050   000051E3           CMP      R1,#+0
   \   00000054   0400001A           BNE      ??UnpackIncomingNumber_0
    418            char c1;
    419            while(m<i)
    420            {
    421              if (m&1) c1=c>>4;
    422              else c1=(c=*p++)&0x0F;
    423              *s=c1+0x30; 
    424              s++;
    425              m++;
    426            }
    427            *s=0;   
   \                     ??UnpackIncomingNumber_1:
   \   00000058   0030C4E5           STRB     R3,[R4, #+0]
    428          }
   \   0000005C   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??UnpackIncomingNumber_2:
   \   00000060   30E08EE2           ADD      LR,LR,#+48
   \   00000064   ........           STRB     LR,[R4], #+1
   \   00000068   012082E2           ADD      R2,R2,#+1
   \                     ??UnpackIncomingNumber_0:
   \   0000006C   010052E1           CMP      R2,R1
   \   00000070   F8FFFF2A           BCS      ??UnpackIncomingNumber_1
   \   00000074   010012E3           TST      R2,#0x1
   \   00000078   ........           LDRBEQ   R12,[R0], #+1
   \   0000007C   0FE00C02           ANDEQ    LR,R12,#0xF
   \   00000080   2CE2A011           LSRNE    LR,R12,#+4
   \   00000084   F5FFFFEA           B        ??UnpackIncomingNumber_2
    429          

   \                                 In segment CODE, align 4, keep-with-next
    430          void tmr_call_proc()
    431          {
   \                     tmr_call_proc:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
    432            char s[32];
    433            
    434            UnpackIncomingNumber(s);
   \   00000008   0D00A0E1           MOV      R0,SP
   \   0000000C   ........           BL       UnpackIncomingNumber
    435            
    436            if (strcmp_nocase(s, MYNUMBER)==0)
   \   00000010   ........           LDR      R1,??DataTable23  ;; MYNUMBER
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0900001A           BNE      ??tmr_call_proc_0
    437            {
    438              keyPress(start_t, start_key1, start_key2, start_delay); // автозапуск двигателя
   \   00000024   ........           LDR      R0,??DataTable24  ;; start_delay
   \   00000028   003090E5           LDR      R3,[R0, #+0]
   \   0000002C   ........           LDR      R0,??DataTable25  ;; start_key2
   \   00000030   002090E5           LDR      R2,[R0, #+0]
   \   00000034   ........           LDR      R0,??DataTable26  ;; start_key1
   \   00000038   001090E5           LDR      R1,[R0, #+0]
   \   0000003C   ........           LDR      R0,??DataTable27  ;; start_t
   \   00000040   000090E5           LDR      R0,[R0, #+0]
   \   00000044   ........           BL       keyPress
    439              EndCall();
   \   00000048   650000EF           SWI      +101
    440            }
    441          }
   \                     ??tmr_call_proc_0:
   \   0000004C   20D08DE2           ADD      SP,SP,#+32       ;; stack cleaning
   \   00000050   0080BDE8           POP      {PC}             ;; return

   \                                 In segment DATA_I, align 4, align-sorted
   \                     ipc:
   \   00000000                      DS8 12
   \   0000000C                      REQUIRE `?<Initializer for ipc>`
   \                     maincsm_id:
   \   0000000C                      DS8 4
   \   00000010                      REQUIRE `?<Initializer for maincsm_id>`
   \                     blink_n:
   \   00000010                      DS8 4
   \   00000014                      REQUIRE `?<Initializer for blink_n>`
   \                     keytab:
   \   00000014                      DS8 20
   \   00000028                      REQUIRE `?<Initializer for keytab>`
   \                     type:
   \   00000028                      DS8 4
   \   0000002C                      REQUIRE `?<Initializer for type>`
   \                     pin1:
   \   0000002C                      DS8 4
   \   00000030                      REQUIRE `?<Initializer for pin1>`
   \                     pin2:
   \   00000030                      DS8 4
   \   00000034                      REQUIRE `?<Initializer for pin2>`
   \                     n:
   \   00000034                      DS8 4
   \   00000038                      REQUIRE `?<Initializer for n>`
   \                     delay:
   \   00000038                      DS8 4
   \   0000003C                      REQUIRE `?<Initializer for delay>`
    442          
    443          
    444          //============================ Voltage Control =================================
    445          
    446          extern const int VOLTAGE_CONTROL_ENA;
    447          extern const int MEASUREMENT_TIME;
    448          extern const int VConst;//разрешение для 1000 mV
    449          extern const int VOffset;//mV, коррекция
    450          extern const int VOffsetMode;
    451          int voltage=-1;
   \                     voltage:
   \   0000003C                      DS8 4
   \   00000040                      REQUIRE `?<Initializer for voltage>`
   \                     tmr_illumination:
   \   00000040                      DS8 16
   \   00000050                      REQUIRE `?<Initializer for tmr_illumination>`
   \                     tmr_blink:
   \   00000050                      DS8 16
   \   00000060                      REQUIRE `?<Initializer for tmr_blink>`
   \                     tmr_key:
   \   00000060                      DS8 16
   \   00000070                      REQUIRE `?<Initializer for tmr_key>`
   \                     tmr_call:
   \   00000070                      DS8 16
   \   00000080                      REQUIRE `?<Initializer for tmr_call>`
    452          
    453          GBSTMR tmr_voltage_control;
   \                     tmr_voltage_control:
   \   00000080                      DS8 16
   \   00000090                      REQUIRE `?<Initializer for tmr_voltage_control>`
    454          void meas_callback(int data);
    455          

   \                                 In segment CODE, align 4, keep-with-next
    456          void tmr_voltage_control_entry()
    457          {
    458            meas_get_volt_m2(meas_callback); 
   \                     tmr_voltage_control_entry:
   \   00000000   ........           LDR      R0,??DataTable38  ;; meas_callback
   \   00000004   ........           _BF      meas_get_volt_m2,??meas_get_volt_m2??rA  ;; tailcall
    459          }
    460          

   \                                 In segment DATA_Z, align 1, align-sorted
    461          char dat42;
   \                     dat42:
   \   00000000                      DS8 1

   \                                 In segment DATA_Z, align 1, align-sorted
    462          char dat44;
   \                     dat44:
   \   00000000                      DS8 1

   \                                 In segment DATA_Z, align 1, align-sorted
    463          char dat46;
   \                     dat46:
   \   00000000                      DS8 1
    464          

   \                                 In segment CODE, align 4, keep-with-next
    465          void meas_callback(int data)
    466          {
   \                     meas_callback:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   0040A0E1           MOV      R4,R0
    467            char s[32];
    468            int VOffset2=0;
    469            
    470            SetVibration(50);
   \   0000000C   3200A0E3           MOV      R0,#+50
   \   00000010   7C0000EF           SWI      +124
    471            
    472            //data: 0x800-значение при нуле, 0xFFF-макс. значение   
    473            int adata = data - 0x800;
   \   00000014   FF00E0E3           MVN      R0,#+255
   \   00000018   700EC0E3           BIC      R0,R0,#0x700
   \   0000001C   044080E0           ADD      R4,R0,R4
    474            if (VOffsetMode == 0)
   \   00000020   90009FE5           LDR      R0,??meas_callback_0  ;; VOffsetMode
   \   00000024   0050A0E3           MOV      R5,#+0
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   000050E3           CMP      R0,#+0
    475              VOffset2 = 0 - VOffset;
   \   00000030   84009F05           LDREQ    R0,??meas_callback_0+0x4  ;; VOffset
   \   00000034   00009005           LDREQ    R0,[R0, #+0]
   \   00000038   00506002           RSBEQ    R5,R0,#+0
    476            voltage = divide(VConst, adata * 1000) + VOffset2; 
   \   0000003C   FA0FA0E3           MOV      R0,#+1000
   \   00000040   900401E0           MUL      R1,R0,R4
   \   00000044   74009FE5           LDR      R0,??meas_callback_0+0x8  ;; VConst
   \   00000048   000090E5           LDR      R0,[R0, #+0]
   \   0000004C   BC0000EF           SWI      +188
    477            if (voltage < 0)
    478              voltage=0;
    479            
    480            sprintf(s, "MEAS:0x%X\nV: %dmV ", adata, voltage);
   \   00000050   6C109FE5           LDR      R1,??meas_callback_0+0xC  ;; `?<Constant "MEAS:0x%X\\nV: %dmV ">`
   \   00000054   003095E0           ADDS     R3,R5,R0
   \   00000058   ........           LDR      R5,??DataTable40  ;; ipc
   \   0000005C   0030A043           MOVMI    R3,#+0
   \   00000060   3C3085E5           STR      R3,[R5, #+60]
   \   00000064   0420A0E1           MOV      R2,R4
   \   00000068   0D00A0E1           MOV      R0,SP
   \   0000006C   160000EF           SWI      +22
    481            ShowMSG(1,(int)s );
   \   00000070   0D10A0E1           MOV      R1,SP
   \   00000074   0100A0E3           MOV      R0,#+1
   \   00000078   480100EF           SWI      +328
    482            
    483          /*  
    484            dat44=0x24;
    485            i2c_pmu_write(0x44, &dat44, NULL, 0, 1);
    486            dat46=0x5f;
    487            i2c_pmu_write(0x46, &dat46, NULL, 0, 1);     
    488            dat42=8;
    489            i2c_pmu_write(0x42, &dat42, NULL, 0, 1); 
    490           */ 
    491            if (VOLTAGE_CONTROL_ENA)
   \   0000007C   ........           LDR      R0,??DataTable42  ;; VOLTAGE_CONTROL_ENA
   \   00000080   000090E5           LDR      R0,[R0, #+0]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0700000A           BEQ      ??meas_callback_1
    492              GBS_StartTimerProc(&tmr_voltage_control, 225 * MEASUREMENT_TIME, tmr_voltage_control_entry);
   \   0000008C   ........           LDR      R0,??DataTable43  ;; MEASUREMENT_TIME
   \   00000090   ........           LDR      R2,??DataTable44  ;; tmr_voltage_control_entry
   \   00000094   000090E5           LDR      R0,[R0, #+0]
   \   00000098   E130A0E3           MOV      R3,#+225
   \   0000009C   930001E0           MUL      R1,R3,R0
   \   000000A0   800085E2           ADD      R0,R5,#+128
   \   000000A4   4D0000EF           SWI      +77
    493              
    494            SetVibration(0);
   \   000000A8   0000A0E3           MOV      R0,#+0
   \                     ??meas_callback_1:
   \   000000AC   7C0000EF           SWI      +124
    495          }
   \   000000B0   20D08DE2           ADD      SP,SP,#+32
   \   000000B4   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??meas_callback_0:
   \   000000B8   ........           DC32     VOffsetMode
   \   000000BC   ........           DC32     VOffset
   \   000000C0   ........           DC32     VConst
   \   000000C4   ........           DC32     `?<Constant "MEAS:0x%X\\nV: %dmV ">`
    496          
    497          //==============================================================================
    498          

   \                                 In segment CODE, align 4, keep-with-next
    499          void InitPath()
    500          {
   \                     InitPath:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    501            sndLock=malloc(strlen(DIR)+32);
   \   00000004   48409FE5           LDR      R4,??InitPath_0  ;; DIR
   \   00000008   ........           LDR      R5,??DataTable34  ;; sndLock
    502            sprintf(sndLock, "%sSounds\\lock.wav", DIR);
   \   0000000C   44609FE5           LDR      R6,??InitPath_0+0x4  ;; `?<Constant "%sSounds\\\\lock.wav">`
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   1B0000EF           SWI      +27
   \   00000018   200080E2           ADD      R0,R0,#+32
   \   0000001C   140000EF           SWI      +20
   \   00000020   000085E5           STR      R0,[R5, #+0]
   \   00000024   0420A0E1           MOV      R2,R4
   \   00000028   0610A0E1           MOV      R1,R6
   \   0000002C   160000EF           SWI      +22
    503            
    504            sndUnlock=malloc(strlen(DIR)+32);
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   1B0000EF           SWI      +27
   \   00000038   200080E2           ADD      R0,R0,#+32
   \   0000003C   140000EF           SWI      +20
   \   00000040   040085E5           STR      R0,[R5, #+4]
    505            sprintf(sndUnlock, "%sSounds\\unlock.wav", DIR); 
   \   00000044   0420A0E1           MOV      R2,R4
   \   00000048   141086E2           ADD      R1,R6,#+20
   \   0000004C   160000EF           SWI      +22
    506          }
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??InitPath_0:
   \   00000054   ........           DC32     DIR
   \   00000058   ........           DC32     `?<Constant "%sSounds\\\\lock.wav">`
    507          

   \                                 In segment CODE, align 4, keep-with-next
    508          void DeInitPath()
    509          {
   \                     DeInitPath:
   \   00000000   10402DE9           PUSH     {R4,LR}
    510            mfree(sndLock);
   \   00000004   ........           LDR      R4,??DataTable34  ;; sndLock
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   150000EF           SWI      +21
    511            mfree(sndUnlock);
   \   00000010   040094E5           LDR      R0,[R4, #+4]
   \   00000014   150000EF           SWI      +21
    512          }
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return
    513          

   \                                 In segment CODE, align 4, keep-with-next
    514          void destroyApp()
    515          {
    516            if(sms_simif_sm) DeleteSMSListener();
   \                     destroyApp:
   \   00000000   ........           LDR      R0,??DataTable35  ;; sms_simif_sm
   \   00000004   10402DE9           PUSH     {R4,LR}
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0000000A           BEQ      ??destroyApp_0
   \   00000014   ........           _BLF     DeleteSMSListener,??DeleteSMSListener??rA
    517            if(IsTimerProc(&tmr_illumination)) GBS_DelTimer(&tmr_illumination);
   \                     ??destroyApp_0:
   \   00000018   ........           LDR      R4,??DataTable40  ;; ipc
   \   0000001C   400084E2           ADD      R0,R4,#+64
   \   00000020   A60100EF           SWI      +422
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0100000A           BEQ      ??destroyApp_1
   \   0000002C   400084E2           ADD      R0,R4,#+64
   \   00000030   8C0100EF           SWI      +396
    518            if(IsTimerProc(&tmr_key)) GBS_DelTimer(&tmr_key);
   \                     ??destroyApp_1:
   \   00000034   600084E2           ADD      R0,R4,#+96
   \   00000038   A60100EF           SWI      +422
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0100000A           BEQ      ??destroyApp_2
   \   00000044   600084E2           ADD      R0,R4,#+96
   \   00000048   8C0100EF           SWI      +396
    519            if(IsTimerProc(&tmr_call)) GBS_DelTimer(&tmr_call);
   \                     ??destroyApp_2:
   \   0000004C   700084E2           ADD      R0,R4,#+112
   \   00000050   A60100EF           SWI      +422
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0100000A           BEQ      ??destroyApp_3
   \   0000005C   700084E2           ADD      R0,R4,#+112
   \   00000060   8C0100EF           SWI      +396
    520            if(IsTimerProc(&tmr_blink)) GBS_DelTimer(&tmr_blink);
   \                     ??destroyApp_3:
   \   00000064   500084E2           ADD      R0,R4,#+80
   \   00000068   A60100EF           SWI      +422
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0100000A           BEQ      ??destroyApp_4
   \   00000074   500084E2           ADD      R0,R4,#+80
   \   00000078   8C0100EF           SWI      +396
    521            if(IsTimerProc(&tmr_voltage_control)) GBS_DelTimer(&tmr_voltage_control);
   \                     ??destroyApp_4:
   \   0000007C   800084E2           ADD      R0,R4,#+128
   \   00000080   A60100EF           SWI      +422
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0100000A           BEQ      ??destroyApp_5
   \   0000008C   800084E2           ADD      R0,R4,#+128
   \   00000090   8C0100EF           SWI      +396
    522            
    523            DeInitPath();
   \                     ??destroyApp_5:
   \   00000094   ........           BL       DeInitPath
    524            RestorePin(TX);
   \   00000098   0100A0E3           MOV      R0,#+1
   \   0000009C   ........           BL       RestorePin
    525            RestorePin(RX);
   \   000000A0   0200A0E3           MOV      R0,#+2
   \   000000A4   ........           BL       RestorePin
    526            RestorePin(CTS);
   \   000000A8   0300A0E3           MOV      R0,#+3
   \   000000AC   ........           BL       RestorePin
    527            RestorePin(RTS);
   \   000000B0   0400A0E3           MOV      R0,#+4
   \   000000B4   ........           BL       RestorePin
    528            meas_deinit();
   \   000000B8   ........           _BLF     meas_deinit,??meas_deinit??rA
    529          }
   \   000000BC   1080BDE8           POP      {R4,PC}          ;; return
    530          

   \                                 In segment CODE, align 4, keep-with-next
    531          void startApp()
    532          {
    533            SetSMSListener((void*)my_sms_simif_sm);
   \                     startApp:
   \   00000000   98009FE5           LDR      R0,??startApp_0  ;; my_sms_simif_sm
   \   00000004   10402DE9           PUSH     {R4,LR}
    534            InitConnectorMap();
    535            InitPinSafe(TX,1); 
    536            InitPinSafe(RX,1);
    537            InitPinSafe(RTS,1);
    538            InitPinSafe(CTS,1);
    539            
    540            if (meas_init())
   \   00000008   94409FE5           LDR      R4,??startApp_0+0x4  ;; `?<Constant "CarControl \\347\\340\\357\\363\\371\\34`
   \   0000000C   ........           _BLF     SetSMSListener,??SetSMSListener??rA
   \   00000010   ........           BL       InitConnectorMap
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   0100A0E3           MOV      R0,#+1
   \   0000001C   ........           BL       InitPinSafe
   \   00000020   0110A0E3           MOV      R1,#+1
   \   00000024   0200A0E3           MOV      R0,#+2
   \   00000028   ........           BL       InitPinSafe
   \   0000002C   0110A0E3           MOV      R1,#+1
   \   00000030   0400A0E3           MOV      R0,#+4
   \   00000034   ........           BL       InitPinSafe
   \   00000038   0110A0E3           MOV      R1,#+1
   \   0000003C   0300A0E3           MOV      R0,#+3
   \   00000040   ........           BL       InitPinSafe
   \   00000044   ........           _BLF     meas_init,??meas_init??rA
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0600000A           BEQ      ??startApp_1
    541            {
    542              if (VOLTAGE_CONTROL_ENA)
   \   00000050   ........           LDR      R0,??DataTable42  ;; VOLTAGE_CONTROL_ENA
   \   00000054   000090E5           LDR      R0,[R0, #+0]
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0500000A           BEQ      ??startApp_2
    543                meas_get_volt_m2(meas_callback);
   \   00000060   ........           LDR      R0,??DataTable38  ;; meas_callback
   \   00000064   ........           _BLF     meas_get_volt_m2,??meas_get_volt_m2??rA
   \   00000068   020000EA           B        ??startApp_2
    544            }
    545            else
    546              ShowMSG(1,(int)"Sorry, MEAS driver not install:(");
   \                     ??startApp_1:
   \   0000006C   141084E2           ADD      R1,R4,#+20
   \   00000070   0100A0E3           MOV      R0,#+1
   \   00000074   480100EF           SWI      +328
    547            
    548            InitPath();
   \                     ??startApp_2:
   \   00000078   ........           BL       InitPath
    549            Play(sndUnlock);
   \   0000007C   24009FE5           LDR      R0,??startApp_0+0x8  ;; sndLock + 4
   \   00000080   000090E5           LDR      R0,[R0, #+0]
   \   00000084   ........           BL       Play
    550            Blink(2);
   \   00000088   0200A0E3           MOV      R0,#+2
   \   0000008C   ........           BL       Blink
    551            ShowMSG(0x11,(int)"CarControl запущен!");  
   \   00000090   0410A0E1           MOV      R1,R4
   \   00000094   1100A0E3           MOV      R0,#+17
   \   00000098   480100EF           SWI      +328
    552          }
   \   0000009C   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??startApp_0:
   \   000000A0   ........           DC32     my_sms_simif_sm
   \   000000A4   ........           DC32     `?<Constant "CarControl \\347\\340\\357\\363\\371\\34`
   \   000000A8   ........           DC32     sndLock + 4
    553          

   \                                 In segment CODE, align 4, keep-with-next
    554          void CheckDoubleRun(void)
    555          {
   \                     CheckDoubleRun:
   \   00000000   10402DE9           PUSH     {R4,LR}
    556            if ((int)ipc.data !=-1)
   \   00000004   ........           LDR      R4,??DataTable45  ;; ipc
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   010070E3           CMN      R0,#+1
   \   00000010   0700000A           BEQ      ??CheckDoubleRun_0
    557            {
    558              LockSched();
   \   00000014   460100EF           SWI      +326
    559              CloseCSM(maincsm_id);
   \   00000018   0C0094E5           LDR      R0,[R4, #+12]
   \   0000001C   FC0100EF           SWI      +508
    560              UnlockSched();
   \   00000020   470100EF           SWI      +327
    561              ShowMSG(0x11,(int)"CarControl был уже запущен!");   
   \   00000024   14109FE5           LDR      R1,??CheckDoubleRun_1  ;; `?<Constant "CarControl \\341\\373\\353 \\363\\346\\3`
   \   00000028   1100A0E3           MOV      R0,#+17
   \   0000002C   480100EF           SWI      +328
   \   00000030   1080BDE8           POP      {R4,PC}
    562            }
    563            else
    564            {
    565              SUBPROC((void *) startApp );
   \                     ??CheckDoubleRun_0:
   \   00000034   08009FE5           LDR      R0,??CheckDoubleRun_1+0x4  ;; startApp
   \   00000038   710100EF           SWI      +369
    566            }
    567          }
   \   0000003C   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??CheckDoubleRun_1:
   \   00000040   ........           DC32     `?<Constant "CarControl \\341\\373\\353 \\363\\346\\3`
   \   00000044   ........           DC32     startApp
    568          

   \                                 In segment CODE, align 4, keep-with-next
    569          int maincsm_onmessage(CSM_RAM* data,GBS_MSG* msg)
    570          { /* имеет смысл только если CTS замкнут на землю
   \                     maincsm_onmessage:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    571            if(msg->msg == 0x6161)//при вкл/выкл. зарядки, сообщение от AKKU_ANZEIGE(0x4e00)
    572            {
    573              InitPinSafe(TX,0); 
    574              InitPinSafe(RX,0);
    575              InitPinSafe(RTS,0);
    576              InitPinSafe(CTS,0); 
    577            }
    578          */  
    579            
    580            if((short)msg->pid_from==0x420E)// && msg->msg == 0x5A)  // вызов, сообщение от AOC_AL_P(0x420E) 
   \   00000004   ........           LDR      R5,??DataTable40  ;; ipc
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   F000D4E1           LDRSH    R0,[R4, #+0]
   \   00000010   0E10A0E3           MOV      R1,#+14
   \   00000014   421C81E3           ORR      R1,R1,#0x4200
   \   00000018   010050E1           CMP      R0,R1
   \   0000001C   0700001A           BNE      ??maincsm_onmessage_0
    581            {
    582              if (*RamCallState()==0)//0-входящий, 1-исходящий
   \   00000020   908200EF           SWI      +33424
   \   00000024   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0300001A           BNE      ??maincsm_onmessage_0
    583              {
    584                GBS_StartTimerProc(&tmr_call, 225*4, tmr_call_proc);   
   \   00000030   18219FE5           LDR      R2,??maincsm_onmessage_1  ;; tmr_call_proc
   \   00000034   E11FA0E3           MOV      R1,#+900
   \   00000038   700085E2           ADD      R0,R5,#+112
   \   0000003C   4D0000EF           SWI      +77
    585              }
    586            }
    587           
    588            if(msg->msg == MSG_RECONFIGURE_REQ) 
   \                     ??maincsm_onmessage_0:
   \   00000040   F200D4E1           LDRSH    R0,[R4, #+2]
   \   00000044   ........           LDR      R6,??DataTable46  ;; `?<Constant "CarControl:\\n\\355\\340\\361\\362\\360\\`
   \   00000048   F110A0E3           MOV      R1,#+241
   \   0000004C   C01F81E3           ORR      R1,R1,#0x300
   \   00000050   010050E1           CMP      R0,R1
   \   00000054   1F00001A           BNE      ??maincsm_onmessage_2
    589            {
    590              extern const char *successed_config_filename;
    591              if (strcmp_nocase(successed_config_filename,(char *)msg->data0)==0)
   \   00000058   F4009FE5           LDR      R0,??maincsm_onmessage_1+0x4  ;; successed_config_filename
   \   0000005C   081094E5           LDR      R1,[R4, #+8]
   \   00000060   000090E5           LDR      R0,[R0, #+0]
   \   00000064   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   1900001A           BNE      ??maincsm_onmessage_2
    592              {
    593                InitConfig();
   \   00000070   ........           _BLF     InitConfig,??InitConfig??rA
    594                InitPath();
   \   00000074   ........           BL       InitPath
    595                
    596                if (VOLTAGE_CONTROL_ENA)
   \   00000078   ........           LDR      R0,??DataTable42  ;; VOLTAGE_CONTROL_ENA
   \   0000007C   000090E5           LDR      R0,[R0, #+0]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   800085E2           ADD      R0,R5,#+128
   \   00000088   0A00000A           BEQ      ??maincsm_onmessage_3
    597                { 
    598                  if (IsTimerProc(&tmr_voltage_control)==NULL)
   \   0000008C   A60100EF           SWI      +422
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   0C00001A           BNE      ??maincsm_onmessage_4
    599                    GBS_StartTimerProc(&tmr_voltage_control, 225 * MEASUREMENT_TIME, tmr_voltage_control_entry);          
   \   00000098   ........           LDR      R0,??DataTable43  ;; MEASUREMENT_TIME
   \   0000009C   ........           LDR      R2,??DataTable44  ;; tmr_voltage_control_entry
   \   000000A0   000090E5           LDR      R0,[R0, #+0]
   \   000000A4   E130A0E3           MOV      R3,#+225
   \   000000A8   930001E0           MUL      R1,R3,R0
   \   000000AC   800085E2           ADD      R0,R5,#+128
   \   000000B0   4D0000EF           SWI      +77
   \   000000B4   040000EA           B        ??maincsm_onmessage_4
    600                }
    601                else
    602                {
    603                  if (IsTimerProc(&tmr_voltage_control))
   \                     ??maincsm_onmessage_3:
   \   000000B8   A60100EF           SWI      +422
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   0100000A           BEQ      ??maincsm_onmessage_4
    604                    GBS_DelTimer(&tmr_voltage_control);
   \   000000C4   800085E2           ADD      R0,R5,#+128
   \   000000C8   8C0100EF           SWI      +396
    605                }
    606                ShowMSG(0x11,(int)"CarControl:\nнастройки обновлены!");
   \                     ??maincsm_onmessage_4:
   \   000000CC   0610A0E1           MOV      R1,R6
   \   000000D0   1100A0E3           MOV      R0,#+17
   \   000000D4   480100EF           SWI      +328
    607              }
    608            }  
    609          //IPC
    610              if (msg->msg==MSG_IPC)
   \                     ??maincsm_onmessage_2:
   \   000000D8   F200D4E1           LDRSH    R0,[R4, #+2]
   \   000000DC   F210A0E3           MOV      R1,#+242
   \   000000E0   C01F81E3           ORR      R1,R1,#0x300
   \   000000E4   010050E1           CMP      R0,R1
   \   000000E8   1600001A           BNE      ??maincsm_onmessage_5
    611              {
    612                if (msg->submess!=392305998)
   \   000000EC   040094E5           LDR      R0,[R4, #+4]
   \   000000F0   60109FE5           LDR      R1,??maincsm_onmessage_1+0x8  ;; 0x17621d4e
   \   000000F4   010050E1           CMP      R0,R1
    613                {
    614                  IPC_REQ *ipc;
    615                  if ((ipc=(IPC_REQ*)msg->data0))
   \   000000F8   08709415           LDRNE    R7,[R4, #+8]
   \   000000FC   00005713           CMPNE    R7,#+0
   \   00000100   1000000A           BEQ      ??maincsm_onmessage_5
    616                  {
    617                    if (strcmp_nocase(ipc->name_to,ipc_my_name)==0)
   \   00000104   000097E5           LDR      R0,[R7, #+0]
   \   00000108   241086E2           ADD      R1,R6,#+36
   \   0000010C   ........           _BLF     strcmp_nocase,??strcmp_nocase??rA
   \   00000110   000050E3           CMP      R0,#+0
    618                    {
    619                      switch (msg->submess)
   \   00000114   04009405           LDREQ    R0,[R4, #+4]
   \   00000118   01005003           CMPEQ    R0,#+1
   \   0000011C   0900001A           BNE      ??maincsm_onmessage_5
    620                      {
    621                      case IPC_CHECK_DOUBLERUN:
    622          	    //Если приняли свое собственное сообщение, значит запускаем чекер
    623          	    if (ipc->name_from==ipc_my_name) SUBPROC((void *)CheckDoubleRun);
   \   00000120   040097E5           LDR      R0,[R7, #+4]
   \   00000124   241086E2           ADD      R1,R6,#+36
   \   00000128   010050E1           CMP      R0,R1
   \   0000012C   0300001A           BNE      ??maincsm_onmessage_6
   \   00000130   24009FE5           LDR      R0,??maincsm_onmessage_1+0xC  ;; CheckDoubleRun
   \   00000134   710100EF           SWI      +369
   \   00000138   0100A0E3           MOV      R0,#+1
   \   0000013C   F080BDE8           POP      {R4-R7,PC}
    624                      else ipc->data=(void *)maincsm_id;
   \                     ??maincsm_onmessage_6:
   \   00000140   0C0095E5           LDR      R0,[R5, #+12]
   \   00000144   080087E5           STR      R0,[R7, #+8]
    625          	    break;
    626                      }
    627                    }
    628                  }
    629                }
    630              }
    631            
    632            return (1);  
   \                     ??maincsm_onmessage_5:
   \   00000148   0100A0E3           MOV      R0,#+1
   \   0000014C   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??maincsm_onmessage_1:
   \   00000150   ........           DC32     tmr_call_proc
   \   00000154   ........           DC32     successed_config_filename
   \   00000158   4E1D6217           DC32     0x17621d4e
   \   0000015C   ........           DC32     CheckDoubleRun
    633          }
    634          

   \                                 In segment CODE, align 4, keep-with-next
    635          static void maincsm_oncreate(CSM_RAM *data)
    636          {
    637            ipc.name_to=ipc_my_name;
   \                     maincsm_oncreate:
   \   00000000   ........           LDR      R3,??DataTable45  ;; ipc
   \   00000004   ........           LDR      R0,??DataTable46  ;; `?<Constant "CarControl:\\n\\355\\340\\361\\362\\360\\`
   \   00000008   00402DE9           PUSH     {LR}
   \   0000000C   241080E2           ADD      R1,R0,#+36
   \   00000010   001083E5           STR      R1,[R3, #+0]
    638            ipc.name_from=ipc_my_name;
   \   00000014   240080E2           ADD      R0,R0,#+36
   \   00000018   040083E5           STR      R0,[R3, #+4]
    639            ipc.data=(void *)-1;
   \   0000001C   0000E0E3           MVN      R0,#+0
   \   00000020   080083E5           STR      R0,[R3, #+8]
    640            GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_CHECK_DOUBLERUN,&ipc);
   \   00000024   0120A0E3           MOV      R2,#+1
   \   00000028   F210A0E3           MOV      R1,#+242
   \   0000002C   C01F81E3           ORR      R1,R1,#0x300
   \   00000030   0900A0E3           MOV      R0,#+9
   \   00000034   420C80E3           ORR      R0,R0,#0x4200
   \   00000038   000100EF           SWI      +256
    641          }
   \   0000003C   0080BDE8           POP      {PC}             ;; return
    642          
    643          extern void kill_data(void *p, void (*func_p)(void *));

   \                                 In segment CODE, align 4, keep-with-next
    644          void ElfKiller(void)
    645          {
   \                     ElfKiller:
   \   00000000   00402DE9           PUSH     {LR}
    646            extern void *ELF_BEGIN;
    647            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
   \   00000004   158000EF           SWI      +32789
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   04009FE5           LDR      R0,??ElfKiller_0  ;; ELF_BEGIN
   \   00000010   0040BDE8           POP      {LR}             ;; Pop
   \   00000014   ........           _BF      kill_data,??kill_data??rA  ;; tailcall
   \                     ??ElfKiller_0:
   \   00000018   ........           DC32     ELF_BEGIN
    648          }
    649          

   \                                 In segment CODE, align 4, keep-with-next
    650          static void maincsm_onclose(CSM_RAM *csm)
    651          {
   \                     maincsm_onclose:
   \   00000000   00402DE9           PUSH     {LR}
    652            destroyApp();
   \   00000004   ........           BL       destroyApp
    653            SUBPROC((void *)ElfKiller);
   \   00000008   04009FE5           LDR      R0,??maincsm_onclose_0  ;; ElfKiller
   \   0000000C   710100EF           SWI      +369
    654          }
   \   00000010   0080BDE8           POP      {PC}             ;; return
   \                     ??maincsm_onclose_0:
   \   00000014   ........           DC32     ElfKiller
    655          

   \                                 In segment DATA_Z, align 4, align-sorted
    656          static unsigned short maincsm_name_body[140];
   \                     maincsm_name_body:
   \   00000000                      DS8 280
    657          
    658          static const struct
    659          {
    660            CSM_DESC maincsm;
    661            WSHDR maincsm_name;

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "CarControl2">`:
   \   00000000   436172436F6E       DC8 "CarControl2"
   \              74726F6C3200
   \   0000000C   ............       DC32 maincsm_onmessage, maincsm_oncreate, maincsm_onclose, 40, 1
   \              ............
   \              280000000100
   \              0000        
   \   00000020   ............       DC32 minus11, maincsm_name_body, 55AACCCCH, 3333AA55H, 0
   \              ....CCCCAA55
   \              55AA33330000
   \              0000        
   \   00000034   8B00               DC16 139
   \   00000036   0000               DC8 0, 0
    662          }MAINCSM =
    663          {
    664            {
    665            maincsm_onmessage,
    666            maincsm_oncreate,
    667          #ifdef NEWSGOLD
    668            0,
    669            0,
    670            0,
    671            0,
    672          #endif
    673            maincsm_onclose,
    674            sizeof(MAIN_CSM),
    675            1,
    676            &minus11
    677            },
    678            {
    679              maincsm_name_body,
    680              NAMECSM_MAGIC1,
    681              NAMECSM_MAGIC2,
    682              0x0,
    683              139
    684            }
    685          };
    686          
    687          
    688          static void UpdateCSMname(void)
    689          {
    690            wsprintf((WSHDR *)(&MAINCSM.maincsm_name),"CarControl2");
    691          }
    692          

   \                                 In segment CODE, align 4, keep-with-next
    693          void WriteLog(char *text)
    694          {
   \                     WriteLog:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
    695            unsigned int ul;
    696            if (!text) return;
   \   0000000C   3180BD08           POPEQ    {R0,R4,R5,PC}
    697            int f=fopen(LOGFILE,A_ReadWrite+A_Create+A_Append+A_BIN,P_READ+P_WRITE,&ul);
   \   00000010   50009FE5           LDR      R0,??WriteLog_0  ;; LOGFILE
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   602FA0E3           MOV      R2,#+384
   \   0000001C   0A10A0E3           MOV      R1,#+10
   \   00000020   811C81E3           ORR      R1,R1,#0x8100
   \   00000024   0A0000EF           SWI      +10
   \   00000028   0050A0E1           MOV      R5,R0
    698            if (f!=-1)
   \   0000002C   010075E3           CMN      R5,#+1
   \   00000030   0900000A           BEQ      ??WriteLog_1
    699            {    
    700              fwrite(f,text,strlen(text),&ul);
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   1B0000EF           SWI      +27
   \   0000003C   0D30A0E1           MOV      R3,SP
   \   00000040   0020A0E1           MOV      R2,R0
   \   00000044   0410A0E1           MOV      R1,R4
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   0C0000EF           SWI      +12
    701              fclose(f,&ul);
   \   00000050   0D10A0E1           MOV      R1,SP
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   0D0000EF           SWI      +13
    702            }
    703            mfree(text);
   \                     ??WriteLog_1:
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   150000EF           SWI      +21
    704          }
   \   00000064   3180BDE8           POP      {R0,R4,R5,PC}    ;; return
   \                     ??WriteLog_0:
   \   00000068   ........           DC32     LOGFILE
    705          

   \                                 In segment CODE, align 4, keep-with-next
    706          int main(void)
    707          {
   \                     main:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    708            InitConfig();
    709            CSM_RAM *save_cmpc;
    710            char dummy[sizeof(MAIN_CSM)];
    711            UpdateCSMname();  
   \   00000004   70409FE5           LDR      R4,??main_0      ;; `?<Constant "CarControl2">`
   \   00000008   28D04DE2           SUB      SP,SP,#+40
   \   0000000C   ........           _BLF     InitConfig,??InitConfig??rA
   \   00000010   0410A0E1           MOV      R1,R4
   \   00000014   240084E2           ADD      R0,R4,#+36
   \   00000018   240100EF           SWI      +292
    712            LockSched();
   \   0000001C   460100EF           SWI      +326
    713            save_cmpc=CSM_root()->csm_q->current_msg_processing_csm;
   \   00000020   068100EF           SWI      +33030
   \   00000024   080090E5           LDR      R0,[R0, #+8]
   \   00000028   045090E5           LDR      R5,[R0, #+4]
    714            CSM_root()->csm_q->current_msg_processing_csm=CSM_root()->csm_q->csm.first;
   \   0000002C   068100EF           SWI      +33030
   \   00000030   0060A0E1           MOV      R6,R0
   \   00000034   068100EF           SWI      +33030
   \   00000038   080090E5           LDR      R0,[R0, #+8]
   \   0000003C   081096E5           LDR      R1,[R6, #+8]
   \   00000040   080090E5           LDR      R0,[R0, #+8]
    715            maincsm_id=CreateCSM(&MAINCSM.maincsm,dummy,0);
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   040081E5           STR      R0,[R1, #+4]
   \   0000004C   0D10A0E1           MOV      R1,SP
   \   00000050   0C0084E2           ADD      R0,R4,#+12
   \   00000054   070100EF           SWI      +263
   \   00000058   20109FE5           LDR      R1,??main_0+0x4  ;; ipc + 12
   \   0000005C   000081E5           STR      R0,[R1, #+0]
    716            CSM_root()->csm_q->current_msg_processing_csm=save_cmpc;
   \   00000060   068100EF           SWI      +33030
   \   00000064   080090E5           LDR      R0,[R0, #+8]
   \   00000068   045080E5           STR      R5,[R0, #+4]
    717            UnlockSched();
   \   0000006C   470100EF           SWI      +327
    718          
    719            return 0;
   \   00000070   0000A0E3           MOV      R0,#+0
   \   00000074   28D08DE2           ADD      SP,SP,#+40
   \   00000078   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??main_0:
   \   0000007C   ........           DC32     `?<Constant "CarControl2">`
   \   00000080   ........           DC32     ipc + 12
    720          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     connector

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     tmr_blink_proc

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     tmr_key_proc

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     MYNUMBER

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     start_delay

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   ........           DC32     start_key2

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   ........           DC32     start_key1

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   ........           DC32     start_t

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   ........           DC32     sndLock

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   ........           DC32     sms_simif_sm

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   ........           DC32     meas_callback

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable40:
   \   00000000   ........           DC32     ipc

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   ........           DC32     VOLTAGE_CONTROL_ENA

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   ........           DC32     MEASUREMENT_TIME

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable44:
   \   00000000   ........           DC32     tmr_voltage_control_entry

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable45:
   \   00000000   ........           DC32     ipc

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable46:
   \   00000000   ........           DC32     `?<Constant "CarControl:\\n\\355\\340\\361\\362\\360\\`

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for ipc>`:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \                     `?<Initializer for maincsm_id>`:
   \   0000000C   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for blink_n>`:
   \   00000010   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for keytab>`:
   \   00000014   000000000100       DC32 0, 1, 2, 3, 4
   \              000002000000
   \              030000000400
   \              0000        
   \                     `?<Initializer for type>`:
   \   00000028   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for pin1>`:
   \   0000002C   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for pin2>`:
   \   00000030   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for n>`:
   \   00000034   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for delay>`:
   \   00000038   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for voltage>`:
   \   0000003C   FFFFFFFF           DC32 -1
   \                     `?<Initializer for tmr_illumination>`:
   \   00000040   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     `?<Initializer for tmr_blink>`:
   \   00000050   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     `?<Initializer for tmr_key>`:
   \   00000060   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     `?<Initializer for tmr_call>`:
   \   00000070   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     `?<Initializer for tmr_voltage_control>`:
   \   00000080   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "CarControl \\341\\373\\353 \\363\\346\\3`:
   \   00000000   436172436F6E       DC8 "CarControl \341\373\353 \363\346\345 \347\340\357\363\371\345\355!"
   \              74726F6C20E1
   \              FBEB20F3E6E5
   \              20E7E0EFF3F9
   \              E5ED2100    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "CarControl \\347\\340\\357\\363\\371\\34`:
   \   00000000   436172436F6E       DC8 "CarControl \347\340\357\363\371\345\355!"
   \              74726F6C20E7
   \              E0EFF3F9E5ED
   \              2100        
   \   00000014   536F7272792C       DC8 "Sorry, MEAS driver not install:("
   \              204D45415320
   \              647269766572
   \              206E6F742069
   \              6E7374616C6C
   \              3A2800      
   \   00000035   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%sSounds\\\\lock.wav">`:
   \   00000000   2573536F756E       DC8 "%sSounds\\lock.wav"
   \              64735C6C6F63
   \              6B2E77617600
   \   00000012   0000               DC8 0, 0
   \   00000014   2573536F756E       DC8 "%sSounds\\unlock.wav"
   \              64735C756E6C
   \              6F636B2E7761
   \              7600        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "MEAS:0x%X\\nV: %dmV ">`:
   \   00000000   4D4541533A30       DC8 "MEAS:0x%X\012V: %dmV "
   \              7825580A563A
   \              2025646D5620
   \              00          
   \   00000013   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "CarControl:\\n\\315\\345\\350\\347\\342\\`:
   \   00000000   436172436F6E       DC8 "CarControl:\012\315\345\350\347\342\345\361\362\355\340\377 \352\356\354\340\355\344\340!"
   \              74726F6C3A0A
   \              CDE5E8E7E2E5
   \              F1F2EDE0FF20
   \              EAEEECE0EDE4
   \              E02100      
   \   00000021   000000             DC8 0, 0, 0
   \   00000024   436172436F6E       DC8 "CarControl:\012%s"
   \              74726F6C3A0A
   \              257300      
   \   00000033   00                 DC8 0

   Maximum stack usage in bytes:

     Function                  CSTACK
     --------                  ------
     Blink                         8
     CheckCmd                     52
     CheckDoubleRun                8
     DeInitPath                    8
     ElfKiller                     4
     IlluminationOff               4
     IlluminationOn               28
     InitConnectorMap              0
     InitPath                     16
     InitPinSafe                  20
     Play                        236
     RestorePin                    8
     UnpackIncomingNumber          8
     WriteLog                     16
     destroyApp                    8
     digitalRead                   0
     digitalWrite                  0
     keyPress                     12
     main                         56
     maincsm_onclose               4
     maincsm_oncreate              4
     maincsm_onmessage            20
     meas_callback                44
     my_sms_simif_sm              32
     pinMode                       0
     pinSetIO                      0
     startApp                      8
     tmr_blink_proc                8
     tmr_call_proc                36
     tmr_key_proc                 16
     tmr_voltage_control_entry     4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     GPIO                            212
     CCU0                            256
     CCU1                            256
     connector                        60
     InitConnectorMap                 64
     InitPinSafe                     252
     RestorePin                      252
     pinSetIO                         68
     pinMode                          96
     digitalWrite                     96
     digitalRead                      36
     my_sms_simif_sm                 224
     minus11                           4
     ?<Constant "CarControl:\n\355\340\361\362\360\
                                      68
     ILL_DISP_RECV                     4
     ILL_KEYS_RECV                     4
     ILL_DYNL_RECV                     4
     ILL_DISP_SEND                     4
     ILL_RECV_TMR                      4
     ILL_RECV_FADE                     4
     ILL_OFF_FADE                      4
     SLI_State                         4
     IlluminationOff                  68
     IlluminationOn                  140
     tmr_blink_proc                  208
     Blink                           108
     sndLock                           8
     Play                            324
     tmr_key_proc                    276
     keyPress                        352
     CheckCmd                        696
     UnpackIncomingNumber            136
     tmr_call_proc                    84
     ipc                             144
     tmr_voltage_control_entry         8
     dat42                             1
     dat44                             1
     dat46                             1
     meas_callback                   200
     InitPath                         92
     DeInitPath                       28
     destroyApp                      192
     startApp                        172
     CheckDoubleRun                   72
     maincsm_onmessage               352
     maincsm_oncreate                 64
     ElfKiller                        28
     maincsm_onclose                  24
     maincsm_name_body               280
     ?<Constant "CarControl2">        56
     WriteLog                        108
     main                            132
     ??DataTable6                      4
     ??DataTable13                     4
     ??DataTable17                     4
     ??DataTable23                     4
     ??DataTable24                     4
     ??DataTable25                     4
     ??DataTable26                     4
     ??DataTable27                     4
     ??DataTable34                     4
     ??DataTable35                     4
     ??DataTable38                     4
     ??DataTable40                     4
     ??DataTable42                     4
     ??DataTable43                     4
     ??DataTable44                     4
     ??DataTable45                     4
     ??DataTable46                     4
     ?<Initializer for ipc>          144
     ?<Constant "CarControl \341\373\353 \363\346\3
                                      28
     ?<Constant "CarControl \347\340\357\363\371\34
                                      56
     ?<Constant "%sSounds\\lock.wav">
                                      40
     ?<Constant "MEAS:0x%X\nV: %dmV ">
                                      20
     ?<Constant "CarControl:\n\315\345\350\347\342\
                                      52
      Others                         280

 
 5 276 bytes in segment CODE
   724 bytes in segment DATA_AN
   356 bytes in segment DATA_C
   144 bytes in segment DATA_I
   144 bytes in segment DATA_ID
   351 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 5 020 bytes of CODE  memory (+ 280 bytes shared)
   500 bytes of CONST memory
   495 bytes of DATA  memory (+ 724 bytes shared)

Errors: none
Warnings: 1
