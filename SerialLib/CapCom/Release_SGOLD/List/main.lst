##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    06/Jul/2014  17:05:52 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  C:\Users\alfin_000\Documents\Siemens\IAR\ARM\alfinan #
#                       t\SerialLib\CapCom\main.c                            #
#    Command line    =  C:\Users\alfin_000\Documents\Siemens\IAR\ARM\alfinan #
#                       t\SerialLib\CapCom\main.c -D SGOLD -lCN              #
#                       C:\Users\alfin_000\Documents\Siemens\IAR\ARM\alfinan #
#                       t\SerialLib\CapCom\Release_SGOLD\List\ -la           #
#                       C:\Users\alfin_000\Documents\Siemens\IAR\ARM\alfinan #
#                       t\SerialLib\CapCom\Release_SGOLD\List\ -o            #
#                       C:\Users\alfin_000\Documents\Siemens\IAR\ARM\alfinan #
#                       t\SerialLib\CapCom\Release_SGOLD\Obj\ -z9            #
#                       --cpu_mode arm --endian little --cpu ARM926EJ-S      #
#                       --stack_align 4 --interwork -e --fpu None            #
#                       --dlib_config C:\Users\alfin_000\Documents\Siemens\I #
#                       AR\ARM\LIB\dl5tpainl8n.h -I                          #
#                       C:\Users\alfin_000\Documents\Siemens\IAR\ARM\INC\    #
#                       --inline_threshold=2                                 #
#    List file       =  C:\Users\alfin_000\Documents\Siemens\IAR\ARM\alfinan #
#                       t\SerialLib\CapCom\Release_SGOLD\List\main.lst       #
#    Object file     =  C:\Users\alfin_000\Documents\Siemens\IAR\ARM\alfinan #
#                       t\SerialLib\CapCom\Release_SGOLD\Obj\main.r79        #
#                                                                            #
#                                                                            #
##############################################################################

C:\Users\alfin_000\Documents\Siemens\IAR\ARM\alfinant\SerialLib\CapCom\main.c
      1          #include <siemens/swilib.h>
      2          #include <siemens/capcom.h>
      3          #include <siemens/i2c.h>

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs int i2cw_pmu(I2C_RAM *, short, char, void (*)(void *, int))
   \                     i2cw_pmu:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   31C0A0E3           MOV      R12,#+49
   \   00000008   ........           B        ?Subroutine11

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine11:
   \   00000000   00C0C0E5           STRB     R12,[R0, #+0]
   \   00000004   00C0A0E3           MOV      R12,#+0
   \   00000008   01C0C0E5           STRB     R12,[R0, #+1]
   \   0000000C   05C0C0E5           STRB     R12,[R0, #+5]
   \   00000010   04C0C0E5           STRB     R12,[R0, #+4]
   \   00000014   B210C0E1           STRH     R1,[R0, #+2]
   \   00000018   B6C0C0E1           STRH     R12,[R0, #+6]
   \   0000001C   141080E2           ADD      R1,R0,#+20
   \   00000020   0C1080E5           STR      R1,[R0, #+12]
   \   00000024   083080E5           STR      R3,[R0, #+8]
   \   00000028   0110A0E3           MOV      R1,#+1
   \   0000002C   101080E5           STR      R1,[R0, #+16]
   \   00000030   1420C0E5           STRB     R2,[R0, #+20]
   \   00000034   EC0200EF           SWI      +748
   \   00000038   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs int i2cr_pmu(I2C_RAM *, short, void (*)(void *, int))
   \                     i2cr_pmu:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   3130A0E3           MOV      R3,#+49
   \   00000008   0030C0E5           STRB     R3,[R0, #+0]
   \   0000000C   0030A0E3           MOV      R3,#+0
   \   00000010   0130C0E5           STRB     R3,[R0, #+1]
   \   00000014   ........           B        ?Subroutine12

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine12:
   \   00000000   0530C0E5           STRB     R3,[R0, #+5]
   \   00000004   0430C0E5           STRB     R3,[R0, #+4]
   \   00000008   B210C0E1           STRH     R1,[R0, #+2]
   \   0000000C   B630C0E1           STRH     R3,[R0, #+6]
   \   00000010   141080E2           ADD      R1,R0,#+20
   \   00000014   0C1080E5           STR      R1,[R0, #+12]
   \   00000018   082080E5           STR      R2,[R0, #+8]
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   101080E5           STR      R1,[R0, #+16]
   \   00000024   ED0200EF           SWI      +749
   \   00000028   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs int i2cw_cam(I2C_RAM *, short, char, void (*)(void *, int))
   \                     i2cw_cam:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   B0C0A0E3           MOV      R12,#+176
   \   00000008                      REQUIRE ?Subroutine11
   \   00000008                      ;; // Fall through to label ?Subroutine11

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs int i2cr_cam(I2C_RAM *, short, void (*)(void *, int))
   \                     i2cr_cam:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   B030A0E3           MOV      R3,#+176
   \   00000008   0030C0E5           STRB     R3,[R0, #+0]
   \   0000000C   0430A0E3           MOV      R3,#+4
   \   00000010   0130C0E5           STRB     R3,[R0, #+1]
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018                      REQUIRE ?Subroutine12
   \   00000018                      ;; // Fall through to label ?Subroutine12
      4          #include <siemens/gpio.h>
      5          #include <siemens/interrupt.h>

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs int disable_interrupts(void)
   \                     disable_interrupts:
   \   00000000   00000FE1           MRS      R0,CPSR
   \   00000004   1F1000E2           AND      R1,R0,#0x1F
   \   00000008   100051E3           CMP      R1,#+16
   \   0000000C   0000001A           BNE      ??disable_interrupts_0
   \   00000010   000000EF           SWI 0            
   \                     ??disable_interrupts_0:
   \   00000014   C01090E3           ORRS     R1,R0,#0xC0
   \   00000018   01F029E1           MSR      CPSR,R1
   \   0000001C   C00000E2           AND      R0,R0,#0xC0
   \   00000020   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void enable_interrupts(int)
   \                     enable_interrupts:
   \   00000000   00100FE1           MRS      R1,CPSR
   \   00000004   1F2001E2           AND      R2,R1,#0x1F
   \   00000008   100052E3           CMP      R2,#+16
   \   0000000C   0000001A           BNE      ??enable_interrupts_0
   \   00000010   000000EF           SWI 0            
   \                     ??enable_interrupts_0:
   \   00000014   C010C1E3           BIC      R1,R1,#0xC0
   \   00000018   010090E1           ORRS     R0,R0,R1
   \   0000001C   00F029E1           MSR      CPSR,R0
   \   00000020   1EFF2FE1           BX       LR               ;; return
      6          
      7          #define  SDA            GPIO_USART0_RTS +1
      8          

   \                                 In segment DATA_I, align 4, align-sorted
      9          int Prescaler = 1;
   \                     Prescaler:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for Prescaler>`

   \                                 In segment DATA_I, align 4, align-sorted
     10          int Frequency = 100000;
   \                     Frequency:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for Frequency>`
     11          int Dutycycle = 50; 
   \                     Dutycycle:
   \   00000004                      DS8 4
   \   00000008                      REQUIRE `?<Initializer for Dutycycle>`
     12          
     13          I2C_RAM msg_40, msg_42;
   \                     msg_40:
   \   00000008                      DS8 24
   \   00000020                      REQUIRE `?<Initializer for msg_40>`
   \                     msg_42:
   \   00000020                      DS8 24
   \   00000038                      REQUIRE `?<Initializer for msg_42>`

   \                                 In segment DATA_I, align 1, align-sorted
     14          char dat_40 = 0x26;
   \                     dat_40:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for dat_40>`

   \                                 In segment DATA_I, align 1, align-sorted
     15          char dat_42 = 0x04;
   \                     dat_42:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for dat_42>`
     16          
     17          #define _BV(bit) (1 << (bit))
     18          
     19          #ifdef SGOLD
     20          #define PM_RINGIN   GPIO_CC_VZ
     21          #endif
     22          #ifdef NEWSGOLD
     23          #define PM_RINGIN   GPIO_RF_STR1
     24          #endif
     25          
     26          extern void kill_data(void *p, void (*func_p)(void *));

   \                                 In segment CODE, align 4, keep-with-next
     27          void ElfKiller(void)
     28          {
   \                     ElfKiller:
   \   00000000   00402DE9           PUSH     {LR}
     29            extern void *ELF_BEGIN;
     30            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
   \   00000004   158000EF           SWI      +32789
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   04009FE5           LDR      R0,??ElfKiller_0  ;; ELF_BEGIN
   \   00000010   0040BDE8           POP      {LR}             ;; Pop
   \   00000014   ........           _BF      kill_data,??kill_data??rA  ;; tailcall
   \                     ??ElfKiller_0:
   \   00000018   ........           DC32     ELF_BEGIN
     31          }
     32          

   \                                 In segment CODE, align 4, keep-with-next
     33          void pwm_test_sound()
     34          {
   \                     pwm_test_sound:
   \   00000000   31402DE9           PUSH     {R0,R4,R5,LR}
     35            int period;
     36          
     37             PM_RINGIN = (ALT2 << OS); 
   \   00000004   50019FE5           LDR      R0,??pwm_test_sound_0  ;; 0xfffffffff4300098
     38             int input_clk = hw_clk;
     39             int saved = disable_interrupts();
     40             period = divide(Frequency << 10, input_clk) << 10;
   \   00000008   ........           LDR      R5,??DataTable5  ;; Frequency
   \   0000000C   3010A0E3           MOV      R1,#+48
   \   00000010   001080E5           STR      R1,[R0, #+0]
   \   00000014   ........           BL       disable_interrupts
   \   00000018   ........           LDR      R1,??DataTable6  ;; 0x18cba80
   \   0000001C   0040A0E1           MOV      R4,R0
   \   00000020   000095E5           LDR      R0,[R5, #+0]
   \   00000024   0005A0E1           LSL      R0,R0,#+10
   \   00000028   BC0000EF           SWI      +188
     41             CCU1->CLK = 0x100;
   \   0000002C   F014A0E3           MOV      R1,#-268435456
   \   00000030   411681E3           ORR      R1,R1,#0x4100000
   \   00000034   402FA0E3           MOV      R2,#+256
   \   00000038   002081E5           STR      R2,[R1, #+0]
     42             CCU1->T0REL = 65536 - period;
   \   0000003C   ........           LDR      R2,??DataTable7  ;; 0xfffffffff4100044
   \   00000040   0005A0E1           LSL      R0,R0,#+10
   \   00000044   401B60E2           RSB      R1,R0,#+65536
   \   00000048   001082E5           STR      R1,[R2, #+0]
     43             CCU1->T0 = 65536 - period; 
   \   0000004C   0420C2E3           BIC      R2,R2,#0x4
   \   00000050   001082E5           STR      R1,[R2, #+0]
     44             CCU1->CC5 = 65536 - divide(1000, Dutycycle * period * 10);
   \   00000054   041095E5           LDR      R1,[R5, #+4]
   \   00000058   900101E0           MUL      R1,R0,R1
   \   0000005C   0A00A0E3           MOV      R0,#+10
   \   00000060   900101E0           MUL      R1,R0,R1
   \   00000064   FA0FA0E3           MOV      R0,#+1000
   \   00000068   BC0000EF           SWI      +188
   \   0000006C   EC109FE5           LDR      R1,??pwm_test_sound_0+0x4  ;; 0xfffffffff4100064
   \   00000070   400B60E2           RSB      R0,R0,#+65536
   \   00000074   ........           STR      R0,[R1], #-52
     45             
     46             CCU1->CCSEM &= ~ _BV(CCSEM5);    //отключаем режим одного события
   \   00000078   002091E5           LDR      R2,[R1, #+0]
   \   0000007C   2000E0E3           MVN      R0,#+32
   \   00000080   022000E0           AND      R2,R0,R2
   \   00000084   ........           STR      R2,[R1], #-4
     47             CCU1->CCSEE &= ~ _BV(CCSEE5);     
   \   00000088   002091E5           LDR      R2,[R1, #+0]
   \   0000008C   020000E0           AND      R0,R0,R2
   \   00000090   000081E5           STR      R0,[R1, #+0]
     48             CCU1->CCM1  |=  (MODE_7 << CCM1_MOD5); /* Режим сравнения 3: При совпадении устанавливается флаг прерывания  и дополнительно выходной контакт CCxIO будет установлен в 1.При переполнение таймера выходной контакт сбрасывается. */
   \   00000094   140041E2           SUB      R0,R1,#+20
   \   00000098   001090E5           LDR      R1,[R0, #+0]
   \   0000009C   701081E3           ORR      R1,R1,#0x70
   \   000000A0   001080E5           STR      R1,[R0, #+0]
     49             CCU1->CCM1  &= ~ _BV(CCM1_ACC5);    /* Обнуляем  бит,регистр захвата/сравнения CC5 будет привязан к таймеру T0 */
   \   000000A4   001090E5           LDR      R1,[R0, #+0]
   \   000000A8   8010C1E3           BIC      R1,R1,#0x80
   \   000000AC   001080E5           STR      R1,[R0, #+0]
     50          
     51             CCU1->CCIOC &= ~ _BV(PL);
   \   000000B0   101080E2           ADD      R1,R0,#+16
   \   000000B4   000091E5           LDR      R0,[R1, #+0]
   \   000000B8   0200C0E3           BIC      R0,R0,#0x2
   \   000000BC   000081E5           STR      R0,[R1, #+0]
     52             CCU1->CCIOC |= _BV(STAG);      /* Если не установлен этот бит,значение пределителя увеличится в 8 раз */
   \   000000C0   000091E5           LDR      R0,[R1, #+0]
   \   000000C4   040080E3           ORR      R0,R0,#0x4
   \   000000C8   000081E5           STR      R0,[R1, #+0]
     53             CCU1->CCIOC &= ~ _BV(PDS);
   \   000000CC   002091E5           LDR      R2,[R1, #+0]
   \   000000D0   0800E0E3           MVN      R0,#+8
   \   000000D4   022000E0           AND      R2,R0,R2
   \   000000D8   002081E5           STR      R2,[R1, #+0]
     54          
     55          
     56             CCU1->T0IC  &= ~ _BV(CCU_INT_EN );  /* отключаем прерывание при переполнении таймера T0 */
   \   000000DC   ........           LDR      R2,??DataTable8  ;; 0xfffffffff41000fc
   \   000000E0   401DE0E3           MVN      R1,#+4096
   \   000000E4   003092E5           LDR      R3,[R2, #+0]
   \   000000E8   033001E0           AND      R3,R1,R3
   \   000000EC   003082E5           STR      R3,[R2, #+0]
     57             CCU1->CC5IC &= ~ _BV(CCU_INT_EN );  /* отключаем прерывание при совпадении значения регистра CC5 со значением таймера*/
   \   000000F0   1C20C2E3           BIC      R2,R2,#0x1C
   \   000000F4   003092E5           LDR      R3,[R2, #+0]
   \   000000F8   031001E0           AND      R1,R1,R3
   \   000000FC   001082E5           STR      R1,[R2, #+0]
     58             
     59             CCU1->T01CON  &= ~ _BV(T0I);  /* пределитель 1, входная частота для таймера 26 Мгц */
   \   00000100   D01042E2           SUB      R1,R2,#+208
   \   00000104   002091E5           LDR      R2,[R1, #+0]
   \   00000108   0120C2E3           BIC      R2,R2,#0x1
   \   0000010C   002081E5           STR      R2,[R1, #+0]
     60             CCU1->T01CON  &= ~ _BV(T0M);  /* обнуляем бит-режим таймера */
   \   00000110   002091E5           LDR      R2,[R1, #+0]
   \   00000114   020000E0           AND      R0,R0,R2
   \   00000118   000081E5           STR      R0,[R1, #+0]
     61             CCU1->T01CON  |= _BV(T0R);    /* установка этого бита запускает таймер */
   \   0000011C   000091E5           LDR      R0,[R1, #+0]
   \   00000120   400080E3           ORR      R0,R0,#0x40
   \   00000124   000081E5           STR      R0,[R1, #+0]
     62             enable_interrupts(saved);
   \   00000128   0400A0E1           MOV      R0,R4
   \   0000012C   ........           BL       enable_interrupts
     63          
     64             i2cw_pmu(&msg_42, 0x42, 4, 0); //устанавливаем PM_RINGIN источником входного сигнала на Dialog
   \   00000130   0030A0E3           MOV      R3,#+0
   \   00000134   0420A0E3           MOV      R2,#+4
   \   00000138   4210A0E3           MOV      R1,#+66
   \   0000013C   200085E2           ADD      R0,R5,#+32
   \   00000140   ........           BL       i2cw_pmu
     65             i2cw_pmu(&msg_40, 0x40, 0x26, 0); //громкость
   \   00000144   0030A0E3           MOV      R3,#+0
   \   00000148   2620A0E3           MOV      R2,#+38
   \   0000014C   4010A0E3           MOV      R1,#+64
   \   00000150   080085E2           ADD      R0,R5,#+8
   \   00000154   ........           BL       i2cw_pmu
     66          }
   \   00000158   3180BDE8           POP      {R0,R4,R5,PC}    ;; return
   \                     ??pwm_test_sound_0:
   \   0000015C   980030F4           DC32     0xfffffffff4300098
   \   00000160   640010F4           DC32     0xfffffffff4100064
     67          

   \                                 In segment CODE, align 4, keep-with-next
     68          void test_led_blink()
     69          {
   \                     test_led_blink:
   \   00000000   11402DE9           PUSH     {R0,R4,LR}
     70            int period;
     71            
     72             GPIO_DSPOUT0 = (ALT2 << OS); // pin 6
   \   00000004   ........           LDR      R0,??DataTable9  ;; 0xfffffffff430005c
     73             int input_clk = hw_clk;
     74             int saved = disable_interrupts();   
     75             period = divide(Frequency << 10, input_clk) << 10;
   \   00000008   ........           LDR      R4,??DataTable5  ;; Frequency
   \   0000000C   3010A0E3           MOV      R1,#+48
   \   00000010   001080E5           STR      R1,[R0, #+0]
   \   00000014   ........           BL       disable_interrupts
   \   00000018   ........           LDR      R1,??DataTable6  ;; 0x18cba80
   \   0000001C   000094E5           LDR      R0,[R4, #+0]
   \   00000020   0005A0E1           LSL      R0,R0,#+10
   \   00000024   BC0000EF           SWI      +188
     76             CCU1->CLK = 0x100;
   \   00000028   F014A0E3           MOV      R1,#-268435456
   \   0000002C   411681E3           ORR      R1,R1,#0x4100000
   \   00000030   402FA0E3           MOV      R2,#+256
   \   00000034   002081E5           STR      R2,[R1, #+0]
     77             CCU1->T0REL = 65536 - period;
   \   00000038   ........           LDR      R2,??DataTable7  ;; 0xfffffffff4100044
   \   0000003C   0005A0E1           LSL      R0,R0,#+10
   \   00000040   401B60E2           RSB      R1,R0,#+65536
   \   00000044   001082E5           STR      R1,[R2, #+0]
     78             CCU1->T0 = 65536 - period; 
   \   00000048   0420C2E3           BIC      R2,R2,#0x4
   \   0000004C   001082E5           STR      R1,[R2, #+0]
     79             CCU1->CC6 = 65536 - divide(1000, Dutycycle * period * 10);
   \   00000050   041094E5           LDR      R1,[R4, #+4]
   \   00000054   900101E0           MUL      R1,R0,R1
   \   00000058   0A00A0E3           MOV      R0,#+10
   \   0000005C   900101E0           MUL      R1,R0,R1
   \   00000060   FA0FA0E3           MOV      R0,#+1000
   \   00000064   BC0000EF           SWI      +188
   \   00000068   98109FE5           LDR      R1,??test_led_blink_0  ;; 0xfffffffff4100068
   \   0000006C   400B60E2           RSB      R0,R0,#+65536
   \   00000070   ........           STR      R0,[R1], #-56
     80             
     81             CCU1->CCSEM &= ~ _BV(CCSEM6);    //отключаем режим одного события
   \   00000074   002091E5           LDR      R2,[R1, #+0]
   \   00000078   4000E0E3           MVN      R0,#+64
   \   0000007C   022000E0           AND      R2,R0,R2
   \   00000080   ........           STR      R2,[R1], #-4
     82             CCU1->CCSEE &= ~ _BV(CCSEE6);     
   \   00000084   002091E5           LDR      R2,[R1, #+0]
   \   00000088   020000E0           AND      R0,R0,R2
   \   0000008C   000081E5           STR      R0,[R1, #+0]
     83             CCU1->CCM1  |=   (MODE_7 << CCM1_MOD6) ; /* Режим сравнения 3: Выходной контакт устанавливается на каждое совпадение.При переполнение таймера выходной контакт сбрасывается.Только одно прерывание за период таймера */
   \   00000090   140041E2           SUB      R0,R1,#+20
   \   00000094   001090E5           LDR      R1,[R0, #+0]
   \   00000098   701E81E3           ORR      R1,R1,#0x700
   \   0000009C   001080E5           STR      R1,[R0, #+0]
     84             CCU1->CCM1  &= ~ _BV(CCM1_ACC6);  /* Обнуляем  бит,регистр захвата/сравнения CC6 будет привязан к таймеру T0 */
   \   000000A0   001090E5           LDR      R1,[R0, #+0]
   \   000000A4   801EC1E3           BIC      R1,R1,#0x800
   \   000000A8   ........           STR      R1,[R0], #+16
     85             
     86             CCU1->CCIOC |= _BV(STAG);      /* Если не установлен этот бит,значение пределителя увеличится в 8 раз.Отключаем.. */
   \   000000AC   001090E5           LDR      R1,[R0, #+0]
   \   000000B0   041081E3           ORR      R1,R1,#0x4
   \   000000B4   001080E5           STR      R1,[R0, #+0]
     87                     
     88             CCU1->T0IC  &= ~ _BV(CCU_INT_EN);   /* отключаем прерывание при переполнении таймера T0 */ 
   \   000000B8   ........           LDR      R1,??DataTable8  ;; 0xfffffffff41000fc
   \   000000BC   400DE0E3           MVN      R0,#+4096
   \   000000C0   002091E5           LDR      R2,[R1, #+0]
   \   000000C4   022000E0           AND      R2,R0,R2
   \   000000C8   002081E5           STR      R2,[R1, #+0]
     89             CCU1->CC2IC &= ~ _BV(CCU_INT_EN);    /* отключаем прерывание при совпадении */
   \   000000CC   1010C1E3           BIC      R1,R1,#0x10
   \   000000D0   002091E5           LDR      R2,[R1, #+0]
   \   000000D4   020000E0           AND      R0,R0,R2
   \   000000D8   000081E5           STR      R0,[R1, #+0]
     90             
     91             CCU1->T01CON  &= ~ _BV(T0I);  /* пределитель 1, входная частота для таймера 26 Мгц */
   \   000000DC   DC0041E2           SUB      R0,R1,#+220
   \   000000E0   001090E5           LDR      R1,[R0, #+0]
   \   000000E4   0110C1E3           BIC      R1,R1,#0x1
   \   000000E8   001080E5           STR      R1,[R0, #+0]
     92             CCU1->T01CON  &= ~ _BV(T0M);  /* режим таймера */
   \   000000EC   001090E5           LDR      R1,[R0, #+0]
   \   000000F0   0810C1E3           BIC      R1,R1,#0x8
   \   000000F4   001080E5           STR      R1,[R0, #+0]
     93             CCU1->T01CON  |= _BV(T0R);    /* cтарт таймера */  
   \   000000F8   001090E5           LDR      R1,[R0, #+0]
   \   000000FC   401081E3           ORR      R1,R1,#0x40
   \   00000100   001080E5           STR      R1,[R0, #+0]
     94          }
   \   00000104   1180BDE8           POP      {R0,R4,PC}       ;; return
   \                     ??test_led_blink_0:
   \   00000108   680010F4           DC32     0xfffffffff4100068
     95          

   \                                 In segment CODE, align 4, keep-with-next
     96          void test_1Gz()
     97          {
     98            int period;
     99            
    100             GPIO_DSPOUT0 = (ALT2 << OS); // pin 6
   \                     test_1Gz:
   \   00000000   ........           LDR      R0,??DataTable9  ;; 0xfffffffff430005c
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   3010A0E3           MOV      R1,#+48
   \   0000000C   001080E5           STR      R1,[R0, #+0]
    101             int input_clk = hw_clk;
    102             int saved = disable_interrupts();   
   \   00000010   ........           BL       disable_interrupts
    103          
    104             CCU0->CLK = 0x100;
   \   00000014   F404A0E3           MOV      R0,#-201326592
   \   00000018   401FA0E3           MOV      R1,#+256
   \   0000001C   001080E5           STR      R1,[R0, #+0]
    105             CCU0->T0 =  0x3C00;
   \   00000020   F00DA0E3           MOV      R0,#+15360
   \   00000024   4010A0E3           MOV      R1,#+64
   \   00000028   F41481E3           ORR      R1,R1,#0xF4000000
   \   0000002C   000081E5           STR      R0,[R1, #+0]
    106             CCU0->T0REL = 0x3C00;
   \   00000030   041081E3           ORR      R1,R1,#0x4
   \   00000034   000081E5           STR      R0,[R1, #+0]
    107             CCU0->CC2 = 0x9E00;
   \   00000038   140081E2           ADD      R0,R1,#+20
   \   0000003C   9E1CA0E3           MOV      R1,#+40448
   \   00000040   001080E5           STR      R1,[R0, #+0]
    108             
    109             CCU0->CCSEM &= ~ _BV(CCSEM2);    //отключаем режим одного события
   \   00000044   3010A0E3           MOV      R1,#+48
   \   00000048   F41481E3           ORR      R1,R1,#0xF4000000
   \   0000004C   002091E5           LDR      R2,[R1, #+0]
   \   00000050   0400E0E3           MVN      R0,#+4
   \   00000054   022000E0           AND      R2,R0,R2
   \   00000058   ........           STR      R2,[R1], #-4
    110             CCU0->CCSEE &= ~ _BV(CCSEE2);     
   \   0000005C   002091E5           LDR      R2,[R1, #+0]
   \   00000060   020000E0           AND      R0,R0,R2
   \   00000064   000081E5           STR      R0,[R1, #+0]
    111             CCU0->CCM0  |=   (MODE_5 << CCM0_MOD2) ; /* Режим сравнения 3: Выходной контакт устанавливается на каждое совпадение.При переполнение таймера выходной контакт сбрасывается.Только одно прерывание за период таймера */
   \   00000068   180041E2           SUB      R0,R1,#+24
   \   0000006C   001090E5           LDR      R1,[R0, #+0]
   \   00000070   501E81E3           ORR      R1,R1,#0x500
   \   00000074   001080E5           STR      R1,[R0, #+0]
    112             CCU0->CCM0  &= ~ _BV(CCM0_ACC2);  /* Обнуляем  бит,регистр захвата/сравнения CC2 будет привязан к таймеру T0 */
   \   00000078   001090E5           LDR      R1,[R0, #+0]
   \   0000007C   801EC1E3           BIC      R1,R1,#0x800
   \   00000080   ........           STR      R1,[R0], #+20
    113             
    114             CCU0->CCIOC |= _BV(STAG);      /* Если не установлен этот бит,значение пределителя увеличится в 8 раз.Отключаем.. */
   \   00000084   001090E5           LDR      R1,[R0, #+0]
   \   00000088   041081E3           ORR      R1,R1,#0x4
   \   0000008C   001080E5           STR      R1,[R0, #+0]
    115                     
    116             CCU0->T0IC  &= ~ _BV(CCU_INT_EN);   /* отключаем прерывание при переполнении таймера T0 */ 
   \   00000090   FC10A0E3           MOV      R1,#+252
   \   00000094   F41481E3           ORR      R1,R1,#0xF4000000
   \   00000098   002091E5           LDR      R2,[R1, #+0]
   \   0000009C   400DE0E3           MVN      R0,#+4096
   \   000000A0   022000E0           AND      R2,R0,R2
   \   000000A4   002081E5           STR      R2,[R1, #+0]
    117             CCU0->CC2IC &= ~ _BV(CCU_INT_EN);    /* отключаем прерывание при совпадении */
   \   000000A8   1010C1E3           BIC      R1,R1,#0x10
   \   000000AC   002091E5           LDR      R2,[R1, #+0]
   \   000000B0   020000E0           AND      R0,R0,R2
   \   000000B4   000081E5           STR      R0,[R1, #+0]
    118             
    119             CCU0->T01CON  |= 6;  /* пределитель 1, входная частота для таймера 26 Мгц */
   \   000000B8   DC0041E2           SUB      R0,R1,#+220
   \   000000BC   001090E5           LDR      R1,[R0, #+0]
   \   000000C0   061081E3           ORR      R1,R1,#0x6
   \   000000C4   001080E5           STR      R1,[R0, #+0]
    120             CCU0->T01CON  &= ~ _BV(T0M);  /* режим таймера */
   \   000000C8   001090E5           LDR      R1,[R0, #+0]
   \   000000CC   0810C1E3           BIC      R1,R1,#0x8
   \   000000D0   001080E5           STR      R1,[R0, #+0]
    121             CCU0->T01CON  |= _BV(T0R);    /* cтарт таймера */  
   \   000000D4   001090E5           LDR      R1,[R0, #+0]
   \   000000D8   401081E3           ORR      R1,R1,#0x40
   \   000000DC   001080E5           STR      R1,[R0, #+0]
    122          }
   \   000000E0   0080BDE8           POP      {PC}             ;; return
    123          

   \                                 In segment CODE, align 4, keep-with-next
    124          int main(void)
    125          {   
    126          
    127             ShowMSG(1,(int)"ELF Started!" );
   \                     main:
   \   00000000   1C109FE5           LDR      R1,??main_0      ;; `?<Constant "ELF Started!">`
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   0100A0E3           MOV      R0,#+1
   \   0000000C   480100EF           SWI      +328
    128              test_led_blink();
   \   00000010   ........           BL       test_led_blink
    129          
    130             SUBPROC((void *)ElfKiller);
   \   00000014   0C009FE5           LDR      R0,??main_0+0x4  ;; ElfKiller
   \   00000018   710100EF           SWI      +369
    131             return 0;
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   0080BDE8           POP      {PC}             ;; return
   \                     ??main_0:
   \   00000024   ........           DC32     `?<Constant "ELF Started!">`
   \   00000028   ........           DC32     ElfKiller
    132          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     Frequency

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   80BA8C01           DC32     0x18cba80

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   440010F4           DC32     0xfffffffff4100044

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   FC0010F4           DC32     0xfffffffff41000fc

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   5C0030F4           DC32     0xfffffffff430005c

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for Prescaler>`:
   \   00000000   01000000           DC32 1

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for Frequency>`:
   \   00000000   A0860100           DC32 100000
   \                     `?<Initializer for Dutycycle>`:
   \   00000004   32000000           DC32 50
   \                     `?<Initializer for msg_40>`:
   \   00000008   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000018   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     `?<Initializer for msg_42>`:
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000030   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        

   \                                 In segment DATA_ID, align 1, align-sorted
   \                     `?<Initializer for dat_40>`:
   \   00000000   26                 DC8 38

   \                                 In segment DATA_ID, align 1, align-sorted
   \                     `?<Initializer for dat_42>`:
   \   00000000   04                 DC8 4

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "ELF Started!">`:
   \   00000000   454C46205374       DC8 "ELF Started!"
   \              617274656421
   \              00          
   \   0000000D   000000             DC8 0, 0, 0
    133          

   Maximum stack usage in bytes:

     Function           CSTACK
     --------           ------
     ElfKiller              4
     disable_interrupts     0
     enable_interrupts      0
     i2cr_cam               4
     i2cr_pmu               4
     i2cw_cam               4
     i2cw_pmu               4
     main                   4
     pwm_test_sound        16
     test_1Gz               4
     test_led_blink        12


   Segment part sizes:

     Function/Label               Bytes
     --------------               -----
     i2cw_pmu                       12
     ?Subroutine11                  60
     i2cr_pmu                       24
     ?Subroutine12                  44
     i2cw_cam                        8
     i2cr_cam                       24
     disable_interrupts             36
     enable_interrupts              36
     Prescaler                       4
     Frequency                      56
     dat_40                          1
     dat_42                          1
     ElfKiller                      28
     pwm_test_sound                356
     test_led_blink                268
     test_1Gz                      228
     main                           44
     ??DataTable5                    4
     ??DataTable6                    4
     ??DataTable7                    4
     ??DataTable8                    4
     ??DataTable9                    4
     ?<Initializer for Prescaler>    4
     ?<Initializer for Frequency>   56
     ?<Initializer for dat_40>       1
     ?<Initializer for dat_42>       1
     ?<Constant "ELF Started!">     16
      Others                        68

 
 1 244 bytes in segment CODE
    16 bytes in segment DATA_C
    62 bytes in segment DATA_I
    62 bytes in segment DATA_ID
    12 bytes in segment INITTAB
 
 1 188 bytes of CODE  memory (+ 68 bytes shared)
    78 bytes of CONST memory
    62 bytes of DATA  memory

Errors: none
Warnings: 2
